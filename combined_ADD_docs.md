## ADD_L1 Freezed


---

### **公理设计辅助系统 L1 公理设计文档 (V1.1)**

**状态:** 批准 (Approved)

**版本说明:** 本文档 (V1.1) 是对 V1.0 版本的重大修订，旨在响应并解决《评审意见报告：关于<公理设计辅助系统 L1 公理设计文档 (V1.0)>》中指出的根本性设计缺陷。本次修订的核心目标是：通过重构功能需求 (FRs) 和设计参数 (DPs) 的定义，消除原设计中违反独立公理的强耦合，建立一个职责清晰、功能独立的L1架构。

#### **1. 引言**

本文档是“公理设计辅助系统”本身的 L1 级公理设计文档。它系统地定义了顶层功能需求 (FRs) 和相应的设计参数 (DPs)，并对其对公理设计两大核心公理——独立公理 (Axiom 1) 和信息公理 (Axiom 2) 的遵循情况进行了分析。

本文档基于《软件用户需求文档 (URD) V1.6》中的用户需求 (URs)、功能描述和约束起草。设计过程遵循公理设计“之字形 (zig-zagging)”方法论，此 L1 设计作为整个分解过程的起点。

**文档范围：**
本文档在最高层级定义了公理设计辅助系统的关键功能和核心设计组件。具体包括：
*   系统 L1 级功能需求 (FRs) 集合。
*   满足 L1 FRs 的 L1 级设计参数 (DPs) 集合。
*   L1 FRs 与 L1 DPs 之间的映射矩阵及其分析。
*   L1 设计对公理一 (Axiom 1) 遵循情况的评估。
*   评估 L1 设计备选方案（公理二 Axiom 2）的框架。
*   后续设计分解步骤的规划。

#### **2. 系统级功能需求 (L1 FRs)**

基于 URD V1.6，我们提炼并定义了以下系统 L1 级功能需求。与V1.0相比，此版本对FR进行了根本性重构，将原先的功能集合（旧FR1）和过程描述（旧FR6）分解或消除，以确保每个FR都是一个原子的、独立的功能定义。

*   **FR1: 管理项目配置模板**
    *   定义：系统应提供创建、保存和应用项目模板的能力。模板可预设审查轮数、LLM角色的行为风格、文档结构、审查清单以及信息公理的量化评估指标。
    *   URD 来源：3.3 (FR-SYS-10)
    *   可追溯 UR：UR-6

*   **FR2: 管理项目级词汇与约束**
    *   定义：系统应维护一个全局性的“项目词汇与约束”文件，包括术语定义、缩写词、命名约定和格式化约束，并在所有文档生成和审查过程中强制应用这些规则。
    *   URD 来源：5.2 (FR-SYS-06)
    *   可追溯 UR：UR-8

*   **FR3: 从外部知识源检索信息**
    *   定义：系统应能根据当前任务上下文，通过一个抽象的知识库服务接口，从项目专属知识库中智能检索相关信息片段。
    *   URD 来源：1.4 (C-2), 5.1 (FR-SYS-04, FR-SYS-05)
    *   可追溯 UR：UR-7

*   **FR4: 应用知识源优先级规则**
    *   定义：当从不同来源获取的信息（如“项目词汇与约束”和“外部知识库”）发生冲突时，系统必须遵循一个预定义的优先级规则（词汇与约束 > 外部知识库）来解决冲突。
    *   URD 来源：5.3 (FR-SYS-31)
    *   可追溯 UR：UR-8

*   **FR5: 起草与修订文档内容**
    *   定义：系统应能基于输入（如上游文档、知识片段等）生成各类文档的草稿，并能根据指令（如审查意见、用户批注）修订内容。此功能包括生成文本图表代码和结构化内容（如FR-DP映射表）。
    *   URD 来源：1.3 (FR-SYS-01, C-1), 2.2 (FR-SYS-14), 2.3 (FR-SYS-15, FR-SYS-17), 2.5 (FR-SYS-25), 6.2 (FR-SYS-20), 6.3 (FR-SYS-21), 6.4 (FR-SYS-23), 7.2 (FR-SYS-02, C-16), 7.3 (FR-SYS-13)
    *   可追溯 UR：UR-1, UR-2, UR-9

*   **FR6: 评审与评估文档内容**
    *   定义：系统应能对照标准（如审查清单、上游文档、项目词汇）自动评审文档草稿，并生成结构化意见。评审需关注一致性、可追溯性以及对公理设计的应用评估。
    *   URD 来源：2.1 (Reviewer role), 2.3 (FR-SYS-16), 2.4 (FR-SYS-16), 4.2 (FR-SYS-12), 5.3 (FR-SYS-32), 6.3 (FR-SYS-22), 6.4 (FR-SYS-24, C-10, C-11, C-13)
    *   可追溯 UR：UR-1, UR-8, UR-10

*   **FR7: 管理文档版本与变更**
    *   定义：系统应通过与Git集成来管理文档的版本和状态。必须实现一个结构化的变更管理流程，用于处理对已冻结文档的修改，包括依赖分析、生成《变更影响报告》并记录用户决策。
    *   URD 来源：2.1 (Automated System Agent, C-3), 2.4 (FR-SYS-28, C-5; FR-SYS-29, C-6; FR-SYS-30), 3.2 (FR-SYS-08, C-7, C-8, C-9), 7.1 (FR-SYS-03)
    *   可追溯 UR：UR-3, UR-11, UR-12

*   **FR8: 处理用户交互与决策**
    *   定义：系统应能接收、解析并响应用户的命令和决策，包括流程控制（暂停/恢复）、用户仲裁、最终批准以及对内容的即时反馈批注。
    *   URD 来源：3.1 (FR-SYS-07), 4.3 (FR-SYS-09, FR-SYS-33, C-14), 7.3 (FR-SYS-13, C-17), 2.3 (User review), 2.4 (User review), 2.5 (FR-SYS-26)
    *   可追溯 UR：UR-4, UR-5, UR-9

#### **3. 系统级设计参数 (L1 DPs)**

为了满足上述重构后的L1 FRs，我们定义了以下L1级设计参数。此处的DPs与FRs一一对应，以实现功能独立。此外，引入了一个特殊的架构组件DP0，它不直接实现任何FR，而是作为协调器来组织其他DPs的执行流程。

*   **DP0: 工作流与状态控制器 (Workflow & State Controller)**
    *   职责：这是一个**纯粹的架构协调组件，没有对应的FR**。其唯一职责是根据系统预设的流程模型（如“撰写-审查-修订”循环），管理系统状态，并按顺序**调用**其他DPs的服务（DP5, DP6, DP7, DP8）来推进工作流。它通过清晰的接口与其它DPs交互，是解耦后系统流程控制的实现。
    *   **不实现任何FR**，但协调DP5, DP6, DP7, DP8去满足各自的FR。

*   **DP1: 项目模板管理器 (Project Template Manager)**
    *   职责：负责处理项目模板的CRUD（创建、读取、更新、删除）操作。它为系统的其他部分提供按需加载的配置数据。
    *   主要实现 L1 FRs：FR1。

*   **DP2: 项目词汇服务 (Project Lexicon Service)**
    *   职责：负责加载、存储和提供对“项目词汇与约束”文件内容的访问接口。它确保项目范围内的术语和规则的一致性应用。
    *   主要实现 L1 FRs：FR2。

*   **DP3: 知识检索服务 (Knowledge Retrieval Service)**
    *   职责：封装了与抽象知识库服务接口的交互。它接收检索请求，并返回相关的信息片段。
    *   主要实现 L1 FRs：FR3。

*   **DP4: 知识仲裁器 (Knowledge Arbiter)**
    *   职责：实现一个简单的逻辑模块，当接收到来自不同源的冲突信息时（例如，来自DP2和DP3的数据），应用预定义的优先级规则并输出最终采纳的信息。
    *   主要实现 L1 FRs：FR4。

*   **DP5: 内容生成与修订引擎 (Content Generation & Revision Engine)**
    *   职责：封装LLM的文本生成和编辑能力。它接收来自DP0的结构化指令和上下文，调用LLM生成或修改文档内容。
    *   主要实现 L1 FRs：FR5。

*   **DP6: 评审与评估引擎 (Review & Assessment Engine)**
    *   职责：封装LLM的文本分析和评估能力。它接收来自DP0的评审任务，对照标准执行内容评审，并生成结构化评审意见。
    *   主要实现 L1 FRs：FR6。

*   **DP7: 版本控制与变更服务 (Version Control & Change Service)**
    *   职责：提供与外部Git仓库交互的标准接口，并实现文档状态机和变更管理的核心逻辑。
    *   主要实现 L1 FRs：FR7。

*   **DP8: 用户交互接口 (User Interaction Interface)**
    *   职责：负责捕获所有用户输入（命令、决策、批注），将其解析为系统内部的标准化命令，并传递给DP0或其他相关模块。
    *   主要实现 L1 FRs：FR8。

#### **4. L1 设计矩阵**

基于重构后的FRs和DPs，我们构建了新的设计矩阵。此矩阵严格遵循公理设计的原则。

**耦合级别定义：**
*   **X (强耦合 / 实现关系):** DP是**唯一直接负责实现**FR核心功能的物理（或逻辑）组件。此关系**仅应出现在对角线上** `(FR_i, DP_i)`。
*   **O (弱耦合 / 依赖关系):** 非对角线关系，表示一个DP为了完成其任务，需要另一个DP提供的服务或数据。这种依赖通过稳定的、定义良好的接口来管理，不影响FR的独立性。
    *   **控制耦合 (O_c):** 一个DP（通常是协调器）调用另一个DP来执行任务。例如，DP0调用DP5。
    *   **数据耦合 (O_d):** 一个DP需要从另一个DP获取数据才能工作。例如，DP5需要从DP3获取知识。
    *   **公共耦合 (O_p):** 两个或多个DPs依赖于同一个公共数据源。例如，DP5和DP6都依赖于DP2提供的词汇表。

| FR / DP | DP0 (控制器) | DP1 (模板) | DP2 (词汇) | DP3 (知识) | DP4 (仲裁) | DP5 (内容) | DP6 (评审) | DP7 (版本) | DP8 (用户) |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **FR1: 模板管理** | | **X** | | | | | | | |
| **FR2: 词汇管理** | | | **X** | | | | | | |
| **FR3: 知识检索** | | | | **X** | | | | | |
| **FR4: 知识仲裁** | | | O_p | O_p | **X** | | | | |
| **FR5: 内容生成** | O_c | O_d | O_p | O_d | O_d | **X** | | | O_d |
| **FR6: 内容评审** | O_c | O_d | O_p | O_d | O_d | O_d | **X** | O_d | |
| **FR7: 版本管理** | O_c | | | | | O_d | O_d | **X** | O_d |
| **FR8: 用户交互** | O_c | | | | | | | | **X** |

**矩阵分析可视化 (Mermaid.js Syntax)**

```mermaid
graph TD
    subgraph 设计参数 (DPs)
        DP0[DP0: 工作流与状态控制器]
        DP1[DP1: 项目模板管理器]
        DP2[DP2: 项目词汇服务]
        DP3[DP3: 知识检索服务]
        DP4[DP4: 知识仲裁器]
        DP5[DP5: 内容生成与修订引擎]
        DP6[DP6: 评审与评估引擎]
        DP7[DP7: 版本控制与变更服务]
        DP8[DP8: 用户交互接口]
    end

    %% DP0作为协调器，通过控制耦合调用其他DP
    DP0 -- O_c (调用) --> DP5
    DP0 -- O_c (调用) --> DP6
    DP0 -- O_c (调用) --> DP7
    DP0 -- O_c (调用) --> DP8

    %% 数据和公共耦合
    DP1 -- O_d (提供配置) ---> DP5
    DP1 -- O_d (提供配置) ---> DP6
    
    DP2 -- O_p (提供词汇) ---> DP5
    DP2 -- O_p (提供词汇) ---> DP6
    DP2 -- O_p (提供词汇) ---> DP4

    DP3 -- O_d (提供知识) ---> DP5
    DP3 -- O_d (提供知识) ---> DP6
    DP3 -- O_p (提供知识) ---> DP4

    DP4 -- O_d (提供最终知识) ---> DP5
    DP4 -- O_d (提供最终知识) ---> DP6

    DP8 -- O_d (提供用户指令) ---> DP5
    DP8 -- O_d (提供用户决策) ---> DP7
    
    DP5 -- O_d (提供草稿) --> DP6
    DP6 -- O_d (提供意见) --> DP5
    DP5 -- O_d (提供文档) --> DP7
    DP6 -- O_d (提供意见) --> DP7

    %% 功能实现关系 (X) - 为清晰起见，此处不绘制，矩阵已明确
    %% FR1 --> DP1, FR2 --> DP2, etc.
```

#### **5. 公理一 (Independence Axiom) 分析**

**分析结论：新设计 (V1.1) 遵循独立公理。**

V1.1的设计通过对FRs和DPs的根本性重构，成功地解决并消除了V1.0版本中存在的严重耦合问题。原设计将“工作流编排”这一实现机制错误地定义为FR，导致了与所有其他DPs强耦合的“上帝模块”(旧DP6)。本设计通过以下方式维护了功能需求的独立性：

1.  **实现关系的对角化 (Diagonalization):** 新的设计矩阵呈现出一个清晰的对角线。每个功能需求FR_i都由且仅由一个设计参数DP_i直接实现（标记为'X'）。例如，FR5（起草与修订文档内容）的核心功能由DP5（内容生成与修订引擎）独立完成。这从根本上保证了功能需求的独立性。

2.  **分离“做什么”与“何时/如何做”:** 本设计的核心改进是引入了DP0（工作流与状态控制器）。DP0是一个纯粹的协调器，它不实现任何FR，而是通过定义良好的接口（控制耦合 `O_c`）来**调用**其他DPs。这实现了“关注点分离”：FRs/DPs（1到8）定义了系统**能做什么**，而DP0定义了**何时以及如何**将这些能力组织成一个完整的流程。这种架构模式消除了原设计中的过程性强耦合。

3.  **弱耦合的管理:** 矩阵中所有的非对角线元素均为弱耦合（'O'），并被明确分类。
    *   **控制耦合 (`O_c`):** DP0对DP5-DP8的调用关系是单向的、非侵入性的。DP5不知道也不关心自己是被DP0调用还是被测试脚本调用，只要输入合法即可。这通过接口隔离了依赖。
    *   **数据耦合 (`O_d`) 与公共耦合 (`O_p`):** 知识服务（DP1-DP4）为业务引擎（DP5, DP6）提供数据。这种依赖是自然的，并且通过稳定的服务接口进行管理。例如，对DP3内部检索算法的修改，只要其对外接口不变，就不会影响到DP5。这确保了实现细节的变更被封装在各自的DP内部。

4.  **消除了旧设计的缺陷：**
    *   **旧FR1/DP1被分解：** 原先臃肿的FR1/DP1被分解为四个独立的FR/DP对（FR1-DP1到FR4-DP4），每个都职责单一，易于独立开发、测试和维护。
    *   **旧FR6/DP6被废除和重构：** 旧的FR6被识别为非功能需求并移除。其对应的“上帝模块”DP6被一个纯粹的、解耦的协调器DP0所取代，彻底解决了系统的核心耦合问题。

综上所述，V1.1设计是一个解耦的、符合独立公理的设计。它为后续的L2层级分解提供了一个坚实、可靠的基础，避免了将耦合问题传递到更深的设计层级中。

#### **6. 公理二 (Information Axiom) 分析框架**

公理二：在所有满足独立公理的设计中，选择信息内容最少的设计。

本L1设计已满足公理一。信息公理的应用框架将用于指导后续层级的设计决策和评估潜在的L2设计备选方案。该框架严格遵循URD V1.6第6.4节的要求。

1.  **识别设计备选方案：** 在对L1 DPs（如DP5 内容生成引擎）进行L2分解时，可能会出现多种满足独立公理的内部设计方案。
2.  **定义评估标准和指标：** 严格遵循《项目模板》（URD V1.6 第3.3节）中定义的量化指标及其**可计算定义 (Computable Definition)**。示例指标包括：
    *   `接口复杂度`: 定义为“所有接口方法参数的总数”。
    *   `内部组件数量`: 定义为“L2层级新增的DPs数量”。
    *   `外部依赖数量`: 定义为“引入的未在项目知识库中定义的外部库或服务的数量”。
3.  **建立指标优先级或权重：** 严格遵循《项目模板》为上述指标设定的决策优先级或权重。
4.  **备选方案评估与决策：** 设计者在提出每个备选方案时，必须提供对上述指标的估算值。评审者将依据模板中定义的优先级或加权总分进行评估和推荐，并明确陈述决策依据。

此框架确保信息公理的应用是确定性的、可重复的，符合项目的工程化要求。

#### **7. 后续步骤**

此L1公理设计文档 (V1.1) 标志着系统设计已回归正轨。后续步骤如下：

1.  **L1设计的正式评审与批准：** 本文档将进入系统的“评审-修订”周期。
2.  **用户审计与L1设计冻结：** 评审员批准后，文档将提交用户进行最终审计。批准后，此文档将被系统标记为“已冻结”，作为下一层分解的基准。
3.  **启动L2分解：** 用户将根据“单一DP分解原则”选择一个已冻结的L1 DP（例如，`DP5: 内容生成与修订引擎`）启动L2设计。该DP所实现的FR（`FR5`）将作为L2子系统的顶层功能需求。
4.  **迭代与并行分解：** 对选定的L1 DP执行L2公理设计。由于L1 DPs之间已高度解耦，可以并行启动对多个L1 DPs（如DP5, DP6, DP7）的分解工作，从而加速整体设计进程。
5.  **生成和执行项目待办事项列表：** 随着各层级设计文档被冻结，系统将分析所有已批准的设计，生成“项目待办事项列表”，并逐项启动接口规范等后续文档的生成任务。
6.  **管理变更：** 在整个过程中，对任何已冻结文档的修改都将严格遵循URD V1.6中定义的变更管理流程。

---
Gemini 2.5 Pro 0605 writer

---

## ADD_L2_DP5 Freezed

好的，遵照指示。基于已批准并冻结的《公理设计辅助系统 L1 公理设计文档 (V1.1)》和《软件用户需求文档 (URD) V1.6》，我们现在开始L2层级的设计分解。

根据L1设计文档第7节“后续步骤”和URD V1.6第2.4节“单一DP分解原则”，我们选择一个已冻结的L1设计参数（DP）进行分解。

**选择分解对象：** `L1 DP5: 内容生成与修订引擎`。
选择此DP的理由是：它是系统的核心“生产”模块，其内部逻辑相对复杂，包含了解析任务、聚合上下文、与LLM交互等多个步骤，是进行L2分解的理想候选者。其对应的功能需求 `L1 FR5: 起草与修订文档内容` 将作为本L2子系统的顶层目标。

---

### **公理设计辅助系统 L2 公理设计文档 (子系统：内容生成与修订引擎) (V1.0)**

**状态:** 已批准 (Approved)

**版本说明:** 本文档 (V1.0) 是对 `L1 DP5: 内容生成与修订引擎` 的首次L2层级分解。它旨在将一个高层级的设计参数细化为一组更小、更具体的、功能独立的功能需求 (FRs) 和设计参数 (DPs)。

#### **1. 引言**

本文档是“公理设计辅助系统”中“内容生成与修订引擎”子系统的L2级公理设计文档。其设计的上游依据是《公理设计辅助系统 L1 公理设计文档 (V1.1)》中已批准并冻结的 `L1 DP5`。

本L2子系统的顶层功能需求由其父级FR定义：
*   **L2-Parent-FR (源自 L1 FR5): 起草与修订文档内容**
    *   定义：系统应能基于输入（如上游文档、知识片段等）生成各类文档的草稿，并能根据指令（如审查意见、用户批注）修订内容。此功能包括生成文本图表代码和结构化内容（如FR-DP映射表）。

**文档范围：**
本文档定义了“内容生成与修订引擎”子系统内部的关键功能和组件。具体包括：
*   子系统 L2 级功能需求 (FRs) 集合。
*   满足 L2 FRs 的 L2 级设计参数 (DPs) 集合。
*   L2 FRs 与 L2 DPs 之间的映射矩阵及其分析。
*   L2 设计对公理一 (Axiom 1) 遵循情况的评估。
*   后续设计分解步骤的规划。

#### **2. 子系统级功能需求 (L2 FRs)**

为了实现 `L2-Parent-FR`，我们将其分解为以下四个独立的、按逻辑顺序执行的L2级功能需求。

*   **FR1: 解析任务指令**
    *   定义：子系统必须能解析从其调用者（L1 DP0 或 L1 DP8）接收到的高级任务指令。例如，将“根据`review_feedback.md`修订`document_draft.md`”这样的指令，转换为包含具体目标（修订）、输入文件路径和操作模式的结构化数据对象。
    *   URD 来源：2.1 (Writer Context), 7.3

*   **FR2: 组装任务上下文**
    *   定义：子系统必须根据已解析的任务指令，从各个L1数据服务中获取并聚合所有必需的上下文信息。这包括调用L1 DP1（模板）、L1 DP2（词汇）、L1 DP3（知识）、L1 DP4（仲裁知识）以及处理来自L1 DP8的用户批注。聚合的结果是一个完整的、可供LLM使用的上下文包。
    *   URD 来源：2.1 (Writer Context), 5.1, 5.2, 5.3, 7.3

*   **FR3: 生成或修订内容**
    *   定义：子系统必须能将聚合后的任务上下文和内容草稿，构建成一个符合特定LLM API格式的、高质量的提示（Prompt）。然后，子系统需调用外部LLM服务，获取生成的文本、图表代码或其他结构化内容。
    *   URD 来源：1.3, 2.2, 7.2

*   **FR4: 格式化并封装输出**
    *   定义：子系统必须能接收来自LLM的原始输出，并将其格式化为符合项目规范的最终文档。这包括添加标准的文件头、元数据、确保Markdown语法正确，并将其封装成一个完整的、可供下游（如L1 DP6或L1 DP7）使用的文档对象或文件。
    *   URD 来源：1.3, 7.1

#### **3. 子系统级设计参数 (L2 DPs)**

为满足上述L2 FRs，我们定义了以下L2级设计参数，并同样引入了一个L2级的协调器 `DP0`。

*   **DP0: 内容生成工作流控制器 (Content Generation Workflow Controller)**
    *   职责：这是一个此L2子系统内部的**纯粹协调组件**。它负责按顺序调用DP1, DP2, DP3, DP4，并将上一步的输出作为下一步的输入，从而实现完整的“内容生成”流程。它封装了子系统内部的执行逻辑。
    *   **不实现任何L2 FR**。

*   **DP1: 任务指令解析器 (Task Instruction Parser)**
    *   职责：实现一个解析器模块，该模块接收来自L1的自由文本或半结构化指令，并输出一个标准化的、机器可读的“任务对象”（Task Object），其中明确定义了操作类型、源文件、参考资料等。
    *   主要实现 L2 FRs：FR1。

*   **DP2: 上下文聚合器 (Context Aggregator)**
    *   职责：实现一个数据聚合模块。它根据“任务对象”中的需求，通过调用L1层级的各个服务接口（DP1, DP2, DP3, DP4, DP8）来获取配置、词汇、知识和用户指令，并将所有信息整合到一个“上下文包”（Context Package）中。
    *   主要实现 L2 FRs：FR2。

*   **DP3: LLM Prompt 引擎与适配器 (LLM Prompt Engine & Adapter)**
    *   职责：封装与具体LLM模型交互的全部复杂性。它接收“上下文包”，动态构建最优的Prompt，处理API调用、重试和错误处理逻辑，并返回LLM的原始响应。这是一个适配器，可以为不同的LLM（如Gemini, GPT等）提供不同的实现。
    *   主要实现 L2 FRs：FR3。

*   **DP4: 输出文档封装器 (Output Document Packager)**
    *   职责：实现一个格式化模块。它接收LLM的原始响应，根据项目模板（从L1 DP1获取）的要求，进行清理、格式化，并组装成最终的Markdown文档字符串。
    *   主要实现 L2 FRs：FR4。

#### **4. L2 设计矩阵**

基于L2的FRs和DPs，我们构建了“内容生成与修订引擎”子系统的内部设计矩阵。

**耦合级别定义:**
*   **X (强耦合 / 实现关系):** DP是**唯一直接负责实现**FR核心功能的组件。
*   **O_c (控制耦合):** DP0调用其他DP来执行任务。
*   **O_d (数据耦合):** 一个DP的执行需要上一个DP的输出作为输入。

| FR / DP | DP0 (控制器) | DP1 (解析器) | DP2 (聚合器) | DP3 (LLM引擎) | DP4 (封装器) |
| :--- | :---: | :---: | :---: | :---: | :---: |
| **FR1: 解析指令** | O_c | **X** | | | |
| **FR2: 组装上下文** | O_c | O_d | **X** | | |
| **FR3: 生成内容** | O_c | | O_d | **X** | |
| **FR4: 封装输出** | O_c | | | O_d | **X** |

**矩阵分析可视化 (Mermaid.js Syntax)**

```mermaid
graph TD
    subgraph L2 子系统：内容生成与修订引擎
        DP0[DP0: 工作流控制器]
        DP1[DP1: 任务指令解析器]
        DP2[DP2: 上下文聚合器]
        DP3[DP3: LLM Prompt 引擎]
        DP4[DP4: 输出文档封装器]
    end

    %% DP0 控制耦合
    DP0 -- O_c (调用) --> DP1
    DP0 -- O_c (调用) --> DP2
    DP0 -- O_c (调用) --> DP3
    DP0 -- O_c (调用) --> DP4

    %% 数据耦合：形成一个清晰的顺序处理流水线
    DP1 -- O_d (任务对象) --> DP2
    DP2 -- O_d (上下文包) --> DP3
    DP3 -- O_d (LLM原始输出) --> DP4

    %% 最终输出
    DP4 -- (最终文档) --> 调用者(L1)
```

#### **5. 公理一 (Independence Axiom) 分析**

**分析结论：L2设计遵循独立公理。**

此L2设计是一个解耦的、理想的下三角矩阵设计。

1.  **实现关系的对角化:** 设计矩阵的对角线由'X'填充，表明每个L2功能需求（FR1-FR4）都由一个且仅一个专用的L2设计参数（DP1-DP4）来直接实现。这满足了独立公理的基本要求。

2.  **清晰的关注点分离:** 本设计将复杂的“内容生成”任务分解为四个独立的关注点：**解析 (Parsing)**、**聚合 (Aggregation)**、**生成 (Generation)** 和 **封装 (Packaging)**。每个DP都有单一、明确的职责。

3.  **受控的弱耦合:**
    *   **控制耦合 (`O_c`):** L2-DP0作为子系统内部的协调器，其存在将执行流程（"how"）与功能实现（"what"）分离，避免了过程性耦合。
    *   **数据耦合 (`O_d`):** 矩阵中的非对角线元素均为数据耦合，形成了一个清晰的、单向的数据流或“流水线”（Pipeline）。DP2依赖DP1的输出，DP3依赖DP2的输出，以此类推。这种耦合是良性的，因为每个DP都通过一个定义良好的数据接口（如“任务对象”、“上下文包”）与下一个DP通信。对任何一个DP内部实现的修改（例如，在DP3中更换LLM模型或优化Prompt模板），只要其输入/输出接口不变，就不会影响到其他DP。

4.  **可维护性与可扩展性:** 这种解耦设计具有很高的可维护性和可扩展性。例如，如果需要支持一种新的任务指令格式，只需修改DP1（任务指令解析器）即可。如果需要集成一个新的知识源，只需在DP2（上下文聚合器）中添加一个新的数据获取逻辑。如果需要支持一个新的LLM模型，只需在DP3（LLM Prompt引擎与适配器）中添加一个新的适配器。这些修改都被限制在独立的模块内部。

综上，本L2设计符合独立公理，为后续更深层级（L3）的分解或直接的工程实现提供了一个稳定、清晰的架构。

#### **6. 公理二 (Information Axiom) 分析框架**

公理二的应用将指导本L2层级中具体DP的实现决策。我们将继续沿用L1设计中建立的框架，并遵循URD V1.6第6.4节的要求。

*   **应用场景示例：** 在对 `L2 DP3: LLM Prompt 引擎与适配器` 进行L3分解或实现时，可能会出现两种备选方案：
    *   **方案A (单一Prompt方案):** 将所有上下文信息（任务指令、草稿、知识片段、审查意见等）整合成一个巨大的、单一的Prompt提交给LLM。
    *   **方案B (链式Prompt方案):** 采用“思维链”或“任务分解”的方法，先用一个Prompt让LLM分析审查意见并生成修订计划，再用第二个Prompt让LLM根据计划执行修订。

*   **评估与决策：** 为了在方案A和B之间做出选择，我们将依据《项目模板》中定义的量化指标进行评估。例如：
    *   **指标1 (高优先级): `LLM API调用成本`** (可计算定义: `(输入Token数 * 单价) + (输出Token数 * 单价)` 的总和)
    *   **指标2 (中优先级): `可预测性`** (可计算定义: 在标准测试集上，输出符合预期格式的成功率)
    *   **指标3 (低优先级): `接口复杂度`** (可计算定义: 模块内部方法的参数总数)

    设计者需为方案A和B估算这些指标的值。评审者将依据模板中定义的优先级（成本 > 可预测性 > 复杂度）做出决策。如果方案B的成本显著高于A，但可预测性大幅提升，评审者将基于此权衡进行推荐，并记录决策依据。

#### **7. 后续步骤**

1.  **L2设计的评审与批准：** 本文档将提交评审。
2.  **L2设计冻结：** 评审通过后，本L2设计将被冻结，作为其父级L1 DP5的最终实现蓝图。
3.  **启动并行L2分解：** 由于L1设计是解耦的，团队现在可以并行启动对其他L1 DPs（如 `L1 DP6: 评审与评估引擎` 或 `L1 DP7: 版本控制与变更服务`）的L2分解工作，而无需等待本L2设计的完成。
4.  **启动L3分解（可选）：** 如果L2 DPs中的任何一个（如 `L2 DP3: LLM Prompt 引擎与适配器`）仍然过于复杂，可以对其启动L3层级的分解。
5.  **更新《项目代办事项列表》：** 一旦本L2设计被批准，其中定义的DPs将成为《项目代办事项列表》中更具体的任务项，例如“实现任务指令解析器接口规范”、“定义上下文包数据结构”等。

---
Gemini 2.5 Pro 0605 writer

---

## ADD_L2_DP6 Freezed

好的，遵照您的指示，我将作为“Gemini 2.5 Pro 0605 writer”，基于已批准的 `ADD_L1 Freezed.md (V1.1)` 和 `URD Freezed.md (V1.6)`，对 `DP6: 评审与评估引擎` 进行L2级公理设计分解。

以下是完整的 `ADD_L2_DP6` 设计文档。

---

### **公理设计辅助系统 L2 公理设计文档：DP6 评审与评估引擎 (V1.0)**

**状态:** 已批准（Approved）

**版本说明:** 本文档 (V1.0) 是对 `L1 设计参数 DP6: 评审与评估引擎` 的首次L2层级设计分解。它旨在将 `DP6` 的高级职责细化为一组独立的、可实现的功能需求和相应的设计参数。

#### **1. 引言**

本文档是“公理设计辅助系统”的L2级公理设计文档，专注于对 `DP6: 评审与评估引擎` 的内部结构进行设计。其设计的上游依据是《公理设计辅助系统 L1 公理设计文档 (V1.1)》中定义的 `FR6` 和 `DP6`。

本文档遵循公理设计的“之字形 (zig-zagging)”分解方法，将L1层级的 `FR6` 作为本L2子系统的顶层功能需求，并将其分解为一系列更具体的L2功能需求（`FRs_L2_DP6`）和对应的L2设计参数（`DPs_L2_DP6`）。

**文档范围：**
*   **上游追溯:** 本文档直接响应并实现 `ADD_L1 Freezed.md (V1.1)` 中的 `FR6: 评审与评估文档内容`。
*   **L2设计定义:** 定义 `DP6` 内部的L2级功能需求 (FRs) 和设计参数 (DPs)。
*   **矩阵与分析:** 构建L2设计矩阵，并分析其对独立公理的遵循情况。
*   **后续规划:** 为L3层级的设计或实现提供基础。

#### **2. 系统级功能需求 (L2 FRs)**

顶层功能需求（`FR_L1_6`）被分解为以下四个独立的L2功能需求，以确保职责分离。

*   **FR2_DP6.1: 聚合与准备评审上下文**
    *   定义：系统应能接收来自 `DP0: 工作流与状态控制器` 的完整评审任务包，并将其解析、组织成一个结构化的“评审上下文对象”。该对象包含待审草稿、审查清单、所有相关的上游文档、项目词汇、以及从知识库检索到的片段。
    *   URD 来源：2.1 (Reviewer Context), 5.1, 5.2
    *   可追溯 L1 FR：FR6

*   **FR2_DP6.2: 执行确定性的清单指令检查**
    *   定义：系统必须能够解析审查清单（Checklist）中的结构化、机器可读的指令（例如 `[TraceabilityCheck]`、`[Axiom1-Check]`），并执行相应的、确定性的检查程序。检查结果应以结构化数据格式（如JSON）输出。
    *   URD 来源：4.2, 5.3, 6.3
    *   可追溯 L1 FR：FR6

*   **FR2_DP6.3: 执行整体性的质量与合规性评估**
    *   定义：系统应利用LLM，对文档草稿进行全面的、非确定性的质量评估。评估内容包括但不限于：文本的清晰度、逻辑连贯性、风格一致性，以及对项目词汇与约束的遵守情况（超出确定性检查范围的部分）。
    *   URD 来源：2.1 (Reviewer role), 6.4 (评估备选方案)
    *   可追溯 L1 FR：FR6

*   **FR2_DP6.4: 综合并格式化最终评审意见**
    *   定义：系统应能整合来自确定性检查（FR2_DP6.2）和整体性评估（FR2_DP6.3）的所有发现，生成一份单一、结构化且人类可读的评审意见文档（`review_feedback.md`）。意见必须是具体的、可执行的，并能明确指出是否批准文档。
    *   URD 来源：2.1 (Reviewer role - "提出具体的、可执行的修改意见"), 2.3
    *   可追溯 L1 FR：FR6

#### **3. 系统级设计参数 (L2 DPs)**

为满足上述L2 FRs，我们定义了以下四个相互独立的L2设计参数。

*   **DP2_DP6.1: 评审上下文聚合器 (Review Context Aggregator)**
    *   职责：作为评审引擎的入口，负责接收来自外部（`DP0`）的输入。它解析输入数据，并构建一个标准化的、包含所有必需信息的内部数据结构（“评审上下文对象”），供引擎内其他组件使用。
    *   主要实现 L2 FRs：FR2_DP6.1。

*   **DP2_DP6.2: 清单指令执行器 (Checklist Command Executor)**
    *   职责：实现一个基于规则的解析与执行引擎。它包含一个指令库，其中每个指令（如 `TraceabilityCheck`）都映射到一个具体的、可执行的函数。该模块的输入是“评审上下文对象”，输出是结构化的检查结果。
    *   主要实现 L2 FRs：FR2_DP6.2。

*   **DP2_DP6.3: LLM质量评估器 (LLM Quality Assessor)**
    *   职责：封装与LLM的交互，专注于文档的整体质量。它根据“评审上下文对象”构建一个复杂的Prompt，调用LLM模型，并解析返回的评估意见。
    *   主要实现 L2 FRs：FR2_DP6.3。

*   **DP2_DP6.4: 评审意见合成器 (Feedback Synthesizer)**
    *   职责：作为评审引擎的出口，负责将`DP2_DP6.2`输出的结构化检查结果和`DP2_DP6.3`输出的文本评估意见，融合成最终的Markdown格式评审报告。它包含格式化模板和逻辑，以确保输出的清晰性和一致性。
    *   主要实现 L2 FRs：FR2_DP6.4。

#### **4. L2 设计矩阵**

基于L2的FRs和DPs，我们构建了`DP6`内部的设计矩阵。

**耦合级别定义：**
*   **X (强耦合 / 实现关系):** DP是**唯一直接负责实现**FR核心功能的物理（或逻辑）组件。
*   **O_d (数据耦合):** 一个DP需要从另一个DP获取数据才能工作。

| FR / DP | DP2_DP6.1 (聚合器) | DP2_DP6.2 (执行器) | DP2_DP6.3 (评估器) | DP2_DP6.4 (合成器) |
| :--- | :---: | :---: | :---: | :---: |
| **FR2_DP6.1: 聚合上下文** | **X** | | | |
| **FR2_DP6.2: 执行指令** | O_d | **X** | | |
| **FR2_DP6.3: 评估质量** | O_d | | **X** | |
| **FR2_DP6.4: 合成意见** | | O_d | O_d | **X** |

**矩阵分析可视化 (Mermaid.js Syntax)**

```mermaid
graph TD
    subgraph L2 设计参数 (DPs within DP6)
        DP1[DP2_DP6.1: 评审上下文聚合器]
        DP2[DP2_DP6.2: 清单指令执行器]
        DP3[DP2_DP6.3: LLM质量评估器]
        DP4[DP2_DP6.4: 评审意见合成器]
    end

    %% 数据流
    DP1 -- O_d (提供评审上下文) --> DP2
    DP1 -- O_d (提供评审上下文) --> DP3
    
    DP2 -- O_d (提供确定性检查结果) --> DP4
    DP3 -- O_d (提供整体评估意见) --> DP4

    %% 功能实现关系 (X) - 矩阵已明确
    %% FR1 --> DP1, FR2 --> DP2, etc.
```

#### **5. 公理一 (Independence Axiom) 分析**

**分析结论：L2设计 (V1.0) 是一个解耦设计，完全遵循独立公理。**

本L2设计通过将评审过程分解为“输入处理”、“确定性检查”、“非确定性评估”和“输出合成”四个独立的功能，成功地构建了一个内部解耦的`评审与评估引擎`。

1.  **实现关系的对角化:** 设计矩阵是一个理想的下三角矩阵，其对角线由实现关系（'X'）构成。每个L2功能需求（`FR2_DP6.i`）都由且仅由一个对应的L2设计参数（`DP2_DP6.i`）直接实现。例如，`FR2_DP6.2`（执行指令）的核心功能完全由`DP2_DP6.2`（清单指令执行器）实现，与其他DP无关。

2.  **清晰的单向数据流:** 所有的非对角线元素均为弱数据耦合（`O_d`），它们共同构成了一个清晰、单向的数据处理流水线：
    *   `DP2_DP6.1` 首先作为入口，准备好所有数据。
    *   `DP2_DP6.2` 和 `DP2_DP6.3` 可以**并行**工作，它们都依赖 `DP2_DP6.1` 提供的上下文数据，但彼此之间完全独立，互不通信。对`LLM质量评估器`（DP3）的修改（例如更换LLM Prompt策略）不会影响`清单指令执行器`（DP2）的逻辑。
    *   `DP2_DP6.4` 最后作为出口，收集前两个并行组件的处理结果，并完成最终的合成任务。

3.  **高内聚，低耦合:** 每个DP都具有高度的内部聚合性。例如，所有与执行机器可读指令相关的逻辑都被封装在`DP2_DP6.2`中。这种设计使得每个组件都可以被独立开发、测试、替换和升级，而不会对引擎的其他部分产生连锁反应。

综上所述，此L2设计通过功能分解和数据流管理，成功地维护了功能需求的独立性，为构建一个健壮、可维护的评审引擎提供了坚实的设计基础。

#### **6. 公理二 (Information Axiom) 分析框架**

公理二：在所有满足独立公理的设计中，选择信息内容最少的设计。

本L2设计已满足公理一。信息公理将用于指导后续对L2 DPs进行更深层次设计或选择具体实现技术时的决策。

**具体应用场景示例：`DP2_DP6.2: 清单指令执行器`的实现方案选择**

在实现`DP2_DP6.2`时，可能存在多种技术方案，均能满足`FR2_DP6.2`。例如：

*   **备选方案A (简单实现):** 使用一组硬编码的正则表达式和字符串匹配函数来解析和执行指令。
    *   **优点:** 实现简单快速，无外部依赖。
    *   **缺点:** 扩展性差，每增加一个新指令都需要修改核心代码，指令语法复杂时难以维护。

*   **备选方案B (解释器模式):** 设计一个简单的指令语法，并为其构建一个小型解释器。
    *   **优点:** 扩展性好，可以通过定义新的语法规则和处理函数来增加新指令，无需修改解释器核心。
    *   **缺点:** 初始开发复杂度较高，引入了更多的内部组件（如词法分析器、语法分析器、执行单元）。

**决策框架:**
依据 URD V1.6 (6.4节) 和项目模板的设定，我们将使用以下量化指标来评估方案A和B：

1.  **评估指标 (来自项目模板):**
    *   `实现复杂度`: 以“代码行数”或“圈复杂度”的估算值衡量。
    *   `可扩展性`: 以“增加一个新指令所需修改的模块数量”衡量。
    *   `外部依赖数量`: 本例中两个方案均为0。

2.  **指标优先级 (来自项目模板):** 假设项目模板定义的优先级为：`1. 可扩展性 > 2. 实现复杂度`。

3.  **决策:**
    *   **方案A评估:** `实现复杂度`=低，`可扩展性`=低。
    *   **方案B评估:** `实现复杂度`=中，`可扩展性`=高。
    *   **结论:** 根据预设的优先级，`可扩展性`是更重要的考量。因此，尽管方案B的初始复杂度更高，但它提供了更少的信息内容（从长期维护和适应变化的角度看，其结构更简单）。因此，**应选择备选方案B**。

此框架确保了技术选型决策是基于项目预设的、客观的标准，而非个人偏好。

#### **7. 后续步骤**

1.  **L2设计的正式评审与批准：** 本文档将提交进行评审。
2.  **L2设计冻结：** 评审通过后，本文档将被冻结，作为`DP6`的正式设计规范。
3.  **启动L3分解或实现规范：** 根据项目需要，可以：
    *   选择一个复杂的L2 DP（如 `DP2_DP6.2: 清单指令执行器`）进行L3层级的进一步分解。
    *   为所有L2 DPs撰写详细的接口规范和实现伪代码，准备进入编码阶段。
4.  **接口定义:** 根据L2设计矩阵中定义的数据耦合，明确`DP2_DP6.1`, `DP2_DP6.2`, `DP2_DP6.3` 和 `DP2_DP6.4` 之间的内部接口标准（数据结构）。

---
Gemini 2.5 Pro 0605 writer

---

## ADD_L2_DP7 Freezed

好的，遵从您的指示。我将作为“撰写员 (Writer)”角色，接收《评审意见报告》，并对《公理设计辅助系统 L2-DP7 公理设计文档 (V1.0)》进行重大修订，生成一个遵循所有评审指令的新版本。

---

### **公理设计辅助系统 L2-DP7 公理设计文档 (V1.1)**

**状态:** 已批准（Approved）

**版本说明:** 本文档 (V1.1) 是对 V1.0 版本的重大修订，旨在响应并解决《评审意见报告：关于<公理设计辅助系统 L2-DP7 公理设计文档 (V1.0)>》中指出的关键设计缺陷。本次修订的核心目标是：
1.  **实现职责纯粹性:** 彻底解耦 `DP7-2: 文档状态机`，使其成为一个无副作用的纯逻辑模块。
2.  **强化依赖注入:** 重构 `DP7-4: 依赖分析引擎` 的数据流，使其成为一个接收数据、而非主动拉取数据的纯计算模块，提升其通用性与可测试性。
3.  **明确协调者职责:** 将所有外部I/O（如Git操作）和副作用的执行责任，集中到本地协调器 `DP7-3: 变更提议管理器` 中，确保职责清晰。

#### **1. 引言**

本文档是 `ADD_L1 Freezed.md (V1.1)` 中定义的 `DP7: 版本控制与变更服务` 的L2层级公理设计。本子系统的总体功能目标由其对应的L1功能需求 `FR7` 定义：

*   **L1-FR7 (顶层目标):** 系统应通过与Git集成来管理文档的版本和状态。必须实现一个结构化的变更管理流程，用于处理对已冻结文档的修改，包括依赖分析、生成《变更影响报告》并记录用户决策。

本文档将遵循公理设计“之字形 (zig-zagging)”方法论，将此单一的L1功能需求分解为一组更细粒度、相互独立的L2功能需求（FRs），并为它们设计相应的L2设计参数（DPs）。所有L2功能需求的可追溯性均指向 `软件用户需求文档 (URD) V1.6`。

**文档范围：**
*   定义 `版本控制与变更服务` 子系统的L2级功能需求 (FRs) 集合。
*   定义满足L2 FRs的L2级设计参数 (DPs) 集合。
*   构建L2 FRs与L2 DPs之间的设计矩阵并进行分析。
*   评估L2设计对独立公理 (Axiom 1) 的遵循情况。
*   为L2设计备选方案的评估建立信息公理 (Axiom 2) 的应用框架。
*   规划后续的设计活动。

#### **2. 子系统级功能需求 (L2 FRs for DP7)**

*(本节内容无变化)*

基于L1-FR7的目标和URD V1.6中的详细描述，我们将 `版本控制与变更服务` 的功能分解为以下L2级FRs：

*   **FR7-1: 提供文档版本化接口**
    *   定义：子系统必须提供一个原子化的、与具体版本控制工具（Git）实现细节隔离的接口，用于执行基本的文档版本化操作，如提交修订（Commit）和创建标签（Tag）。
    *   URD 来源：2.1 (Automated System Agent), 7.1 (FR-SYS-03)
    *   可追溯 UR：UR-3

*   **FR7-2: 管理文档状态生命周期**
    *   定义：子系统必须实现并强制执行一个明确的文档状态机模型（例如：`草案` -> `已冻结` -> `变更中` -> `已作废`）。状态的转换必须是受控的、可追溯的。
    *   URD 来源：2.4 (FR-SYS-28, FR-SYS-29), 3.2 (FR-SYS-08)
    *   可追溯 UR：UR-11

*   **FR7-3: 启动并管理变更提议流程**
    *   定义：当收到修改“已冻结”文档的请求时，子系统必须能启动一个变更管理会话，包括为此文档创建临时的变更副本（或分支），并将其状态标记为“变更中”。
    *   URD 来源：3.2.1, 3.2.2
    *   可追溯 UR：UR-11

*   **FR7-4: 执行变更依赖分析**
    *   定义：子系统必须能够分析指定“已冻结”文档的变更，以“尽力而为”的原则识别所有直接和间接的下游依赖文档，并为每个依赖关系计算可解释的“置信度评分”。
    *   URD 来源：3.2.3, 3.2.3.1 (C-8)
    *   可追溯 UR：UR-12

*   **FR7-5: 生成并归档变更影响报告**
    *   定义：子系统必须能够根据用户最终确认的作废清单，生成一份结构化的、Markdown格式的《变更影响报告》，并将其作为变更记录的一部分进行版本化归档。
    *   URD 来源：3.2.5 (C-9), 3.2.6
    *   可追溯 UR：UR-11

#### **3. 子系统级设计参数 (L2 DPs for DP7) - 修订版**

为满足上述L2 FRs，我们设计了以下L2 DPs。此版本对DP的职责描述进行了精确化修订，以消除耦合。

*   **DP7-1: Git 适配器 (Git Adapter)**
    *   职责：封装所有与底层Git命令行或库的直接交互。它对外暴露一个干净、抽象的接口（如`commit(file, message)`, `tag(tagName)`, `readFile(filePath)`)，隐藏了Git的具体实现细节。
    *   主要实现 L2 FRs：FR7-1。

*   **DP7-2: 文档状态机 (Document State Machine) - 已重构**
    *   职责：一个**纯逻辑、无副作用的模块**。其职责**仅限于**接收当前状态和事件，根据内部定义的状态转换图，计算并返回新的状态。它**绝不**执行任何I/O操作或调用其他DP。如果状态转换需要触发外部动作，它可以返回一个描述该动作的数据结构，供调用方（协调器）解释和执行。
    *   主要实现 L2 FRs：FR7-2。

*   **DP7-3: 变更提议管理器 (Change Proposal Manager) - 已重构**
    *   职责：作为此子系统唯一的**本地流程协调器**。它负责编排整个变更管理工作流。其职责包括：
        1.  调用 `DP7-2` 获取状态转换决策。
        2.  **解释** `DP7-2` 的结果，并**负责执行**所有相关的副作用，例如调用 `DP7-1` 来执行Git操作（创建分支、打标签等）。
        3.  负责调用 `DP7-1` 获取文件内容，并将其作为参数**注入**到 `DP7-4` 中。
        4.  按顺序调用 `DP7-4` 和 `DP7-5` 以完成分析和报告生成。
    *   主要实现 L2 FRs：FR7-3。

*   **DP7-4: 依赖分析引擎 (Dependency Analysis Engine) - 已重构**
    *   职责：一个**纯计算模块**，负责实现依赖关系识别和置信度评分的算法。它**接收**需要分析的文本内容作为输入参数，**不依赖**任何外部数据源。其核心方法签名类似于 `analyze(mainDocContent, dependentDocContents)`。
    *   主要实现 L2 FRs：FR7-4。

*   **DP7-5: 变更报告生成器 (Change Report Generator)**
    *   职责：接收结构化数据（变更源、用户决策、分析结果），并根据预定义的Markdown模板填充内容，生成最终的《变更影响报告》文件。
    *   主要实现 L2 FRs：FR7-5。

#### **4. L2 设计矩阵 - 修订版**

基于重构后的DPs，我们构建了新的、进一步解耦的设计矩阵。

**耦合级别定义：**
*   **X (强耦合 / 实现关系):** DP是**唯一直接负责实现**FR核心功能的组件。
*   **O (弱耦合 / 依赖关系):** 非对角线关系，表示一个DP为了完成其任务，需要调用另一个DP提供的服务或数据。
    *   **控制耦合 (O_c):** 一个DP调用另一个DP来执行任务。
    *   **数据耦合 (O_d):** 一个DP需要从另一个DP获取数据。

| FR / DP | DP7-1 (Git适配器) | DP7-2 (状态机) | DP7-3 (提议管理器) | DP7-4 (分析引擎) | DP7-5 (报告生成器) |
| :--- | :---: | :---: | :---: | :---: | :---: |
| **FR7-1: 版本化接口** | **X** | | | | |
| **FR7-2: 状态机管理** | | **X** | | | |
| **FR7-3: 变更流程管理** | O_c/O_d | O_c | **X** | O_c | O_c |
| **FR7-4: 依赖分析** | | | | **X** | |
| **FR7-5: 报告生成** | O_c | | | O_d | **X** |

**矩阵分析可视化 (Mermaid.js Syntax) - 修订版**
*箭头 `A --> B` 表示 `A` 依赖于 `B`。*

```mermaid
graph TD
    subgraph L2 设计参数 (DPs for DP7 v1.1)
        DP7_1[DP7-1: Git 适配器]
        DP7_2[DP7-2: 文档状态机]
        DP7_3[DP7-3: 变更提议管理器]
        DP7_4[DP7-4: 依赖分析引擎]
        DP7_5[DP7-5: 变更报告生成器]
    end

    %% DP7-3 (协调器) 的依赖关系
    DP7_3 -- "O_c/O_d (执行副作用/获取数据)" --> DP7_1
    DP7_3 -- "O_c (获取状态决策)" --> DP7_2
    DP7_3 -- "O_c (注入数据并调用)" --> DP7_4
    DP7_3 -- "O_c (调用)" --> DP7_5
    
    %% DP7-5 (报告生成器) 的依赖关系
    DP7_5 -- "O_d (获取分析结果)" --> DP7_4
    DP7_5 -- "O_c (归档报告)" --> DP7_1
    
    %% DP7-2 和 DP7-4 现已无出向依赖，成为纯粹的模块
```

#### **5. 公理一 (Independence Axiom) 分析 - 修订版**

**分析结论：本L2设计 (V1.1) 严格遵循独立公理，是一个高度解耦的理想设计。**

通过响应评审意见进行重构，V1.1设计消除了原设计中所有不必要的耦合，达到了更高的模块化水平。

1.  **实现关系的对角化:** 与前一版本一样，设计矩阵的对角线被清晰地建立起来，`FR7-i` 由 `DP7-i` 唯一实现。这是满足独立公理的基础。

2.  **职责纯粹性的实现 (核心改进):**
    *   **`DP7-2` 的纯化:** 本设计的关键改进是将 `DP7-2: 文档状态机` 重构为一个纯逻辑模块。它不再有任何出向依赖（如Mermaid图所示），彻底消除了原设计中违反其自身定义的副作用。这使得 `DP7-2` 可以在完全隔离的环境中进行确定性测试，极大地提高了其可靠性和可维护性。
    *   **`DP7-4` 的纯化:** 通过应用“依赖注入”模式，`DP7-4: 依赖分析引擎` 也被重构为一个纯计算模块。它不再依赖 `DP7-1` 来获取数据，而是由协调器 `DP7-3` 负责提供数据。这使得 `DP7-4` 完全独立于数据来源（Git、文件系统或网络），可以轻松地被重用和独立测试。

3.  **协调者模式的强化:** 本设计强化了 `DP7-3: 变更提议管理器` 作为唯一本地协调器的角色。所有与外部世界交互的副作用（通过 `DP7-1`）、所有的数据获取与注入，都由 `DP7-3` 统一管理。这完美地体现了“关注点分离”，将“做什么”（DPs 1, 2, 4, 5）与“何时以及如何做”（DP 3）彻底分开。

4.  **良性耦合的管理:** 矩阵中剩余的非对角线元素均为良性的、通过接口管理的弱耦合。`DP7-5` 对 `DP7-4` 的数据耦合是自然的，报告生成器需要分析结果。`DP7-5` 对 `DP7-1` 的控制耦合是必要的，生成的报告需要被归档。这些职责划分清晰，没有引入不必要的依赖。

综上所述，V1.1设计不仅遵循独立公理，而且通过实现职责纯粹性和强化协调者模式，构建了一个比V1.0更健壮、更易于测试和维护的架构。

#### **6. 公理二 (Information Axiom) 分析框架**

*(本节内容无变化)*

本L2设计已满足公理一。信息公理将用于指导对本层级DPs的进一步分解（L3设计）或具体实现技术的选型。

当对某个L2 DP（例如 `DP7-4: 依赖分析引擎`）的设计或实现存在多种备选方案时，将采用以下框架进行决策：

1.  **识别设计备选方案：** 例如，对于 `DP7-4`，备选方案可能包括：
    *   方案A：基于正则表达式和结构化标签（如 `[TraceabilityCheck: ...]`) 的解析器。
    *   方案B：基于AST（抽象语法树）的Markdown解析器，以获得更精确的链接关系。
    *   方案C：引入一个轻量级的嵌入式向量数据库，进行语义相似性分析。

2.  **定义评估标准和指标：** 依据项目模板（URD V1.6 第6.4节），使用预定义的量化指标及其**可计算定义**：
    *   `实现复杂度` (可定义为：代码行数估算，或所需核心算法的复杂度等级 O(n))。
    *   `接口复杂度` (定义为：接口方法参数的总数)。
    *   `外部依赖数量` (定义为：引入的第三方库的数量)。
    *   `执行性能` (定义为：处理一个标准大小文档的平均耗时)。

3.  **建立指标优先级或权重：** 遵循项目模板中为上述指标设定的优先级（例如：`外部依赖数量`（越少越好） > `实现复杂度`（越低越好） > `执行性能`）。

4.  **备选方案评估与决策：** 设计者必须为每个备选方案提供上述指标的估算值。评审者将依据模板中定义的优先级或加权总分进行评估，做出信息量最少的选择，并记录决策依据。

#### **7. 后续步骤**

*(本节内容无变化)*

1.  **L2设计的正式评审与批准：** 本文档将提交进行正式评审。
2.  **L2设计冻结：** 评审批准后，此L2设计将被冻结，作为后续开发和L3分解的基准。
3.  **接口规范定义：** 为本级所有DPs（DP7-1至DP7-5）创建详细的接口规范文档（例如 `IF_GitAdapter.md`），明确定义每个方法的签名、参数、返回值和异常。
4.  **启动L3分解（如需要）：** 对于内部逻辑仍然复杂的DP，如 `DP7-4: 依赖分析引擎`，可以启动L3层级的公理设计分解。
5.  **更新项目待办事项列表：** 将“实现DP7-1至DP7-5”和“撰写其接口规范”等任务添加到《项目代办事项列表》中。

---
Gemini 2.5 Pro 0605 writer

---

## ADD_L2_DP8 Freezed

好的，遵照您的指示。根据《项目代办事项列表 (V4.0)》中定义的P0优先级任务 `TODO-L2-003`，我将作为“撰写员 (Writer)”，对 `L1 DP8: 用户命令与控制` 进行L2级公理设计分解。

本次设计将严格遵循已批准的《公理设计辅助系统 L1 公理设计文档 (V1.1)》和《L1-DP8 用户命令与控制 API 接口规范 (V1.0)》，确保L2设计能够完全覆盖L1的职责定义和API契约。

---

### **公理设计辅助系统 L2 公理设计文档：DP8 用户命令与控制 (V1.0)**

**状态:** 已批准 (Approved)

**版本说明:** 本文档 (V1.0) 是对 `L1 设计参数 DP8: 用户命令与控制` 的首次L2层级设计分解。其目的是将 `L1-DP8` 的高级职责细化为一组独立的、可实现的功能需求和相应的设计参数。

#### **1. 引言**

本文档是“公理设计辅助系统”的L2级公理设计文档，专注于对 `L1-DP8: 用户命令与控制` 的内部结构进行设计。其设计的上游依据是《公理设计辅助系统 L1 公理设计文档 (V1.1)》中定义的 `FR8` 和 `DP8`，以及《L1-DP8 用户命令与控制 API 接口规范 (V1.0)》中定义的交互契约。

本L2子系统的顶层功能需求由其父级FR定义：
*   **L2-Parent-FR (源自 L1 FR8): 处理用户交互与决策**
    *   定义：系统应能接收、解析并响应用户的命令和决策，包括流程控制（暂停/恢复）、用户仲裁、最终批准以及对内容的即时反馈批注。

本文档将遵循公理设计的“之字形 (zig-zagging)”分解方法，将此单一的L1功能需求分解为一系列更具体的L2功能需求（`FRs`），并为它们设计相应的L2设计参数（`DPs`）。

**文档范围：**
*   **上游追溯:** 本文档直接响应并实现 `ADD_L1 Freezed.md (V1.1)` 中的 `FR8`。
*   **L2设计定义:** 定义 `L1-DP8` 内部的L2级功能需求 (FRs) 和设计参数 (DPs)。
*   **矩阵与分析:** 构建L2设计矩阵，并分析其对独立公理的遵循情况。
*   **后续规划:** 为L3层级的设计或实现提供基础。

#### **2. 子系统级功能需求 (L2 FRs)**

根据《L1-DP8 API 接口规范》，我们将 `L1-FR8` 分解为以下四个独立的L2功能需求，分别对应API提供的不同能力。

*   **FR1: 解析并分发即时命令**
    *   定义：子系统必须能够接收并解析同步的、一次性的流程控制命令（如 `START_PROCESS`, `PAUSE_PROCESS`），并将其转换为一个标准化的内部事件，以通知 `L1-DP0` 等核心控制器。
    *   URD 来源：3.1
    *   可追溯 API：`POST /api/v1/commands`

*   **FR2: 管理用户任务的生命周期**
    *   定义：子系统必须能够管理需要用户决策的异步任务的整个生命周期。这包括：响应来自 `L1-DP0` 的请求创建任务，为任务分配唯一ID，持久化任务上下文与状态（`PENDING`, `COMPLETED`, `EXPIRED`），并提供查询接口供外部轮询。
    *   URD 来源：4.3
    *   可追溯 API：`POST /user-tasks`, `GET /user-tasks`, `GET /user-tasks/{id}`

*   **FR3: 接收并验证用户决策**
    *   定义：当用户对一个待处理任务做出决策时，子系统必须能够接收该决策，验证其有效性（例如，决策代码是否是该任务允许的选项之一），然后将决策数据安全地附加到任务上，并更新任务状态为“已完成”。
    *   URD 来源：4.3.a, 4.3.b, 4.3.c, 4.3.d
    *   可追溯 API：`PUT /user-tasks/{id}/decision`

*   **FR4: 捕获并存储即时反馈批注**
    *   定义：子系统必须能够接收用户对文档内容进行的即时反馈批注，并根据《即时反馈批注数据规范 (priority_revisions.yaml)》的Schema，将其格式化并持久化到工作区，以供 `L1-DP5` 在下一轮修订时使用。
    *   URD 来源：7.3
    *   可追溯 API：`POST /api/v1/annotations`

#### **3. 子系统级设计参数 (L2 DPs)**

为满足上述L2 FRs，我们设计了以下L2设计参数。

*   **DP1: 命令解析与事件发布器 (Command Parser & Event Publisher)**
    *   职责：一个轻量级模块，负责解析来自 `POST /commands` 的请求。它将请求中的命令字符串映射为一个内部事件对象，并通过一个标准事件总线（Event Bus）或消息队列接口进行发布。`L1-DP0` 是此事件的主要订阅者。
    *   主要实现 L2 FRs：FR1。

*   **DP2: 用户任务存储与状态管理器 (User Task Store & State Manager)**
    *   职责：作为“用户任务”资源的存储库（Repository）。它提供CRUD（创建、读取、更新、删除）操作接口，负责任务的持久化。这可以是一个简单的内存中存储，或一个连接到文件系统/轻量级数据库的适配器。它还包含一个定时器逻辑，用于将超时的任务状态更新为 `EXPIRED`。
    *   主要实现 L2 FRs：FR2。

*   **DP3: 决策处理器 (Decision Processor)**
    *   职责：一个纯逻辑处理单元。它接收一个决策对象和一个任务ID。其工作流程是：1) 从 `DP2` 获取对应的任务。2) 验证决策是否在任务的 `decision_options` 中。3) 如果有效，将决策数据写入任务对象，并调用 `DP2` 将任务状态更新为 `COMPLETED`。4) 如果无效，则返回错误。
    *   主要实现 L2 FRs：FR3。

*   **DP4: 批注持久化服务 (Annotation Persistence Service)**
    *   职责：一个负责I/O操作的模块。它接收批注数据，使用模板或序列化器将其转换为 `priority_revisions.yaml` 格式的字符串，然后调用 `L1-DP7` 的接口将此文件写入版本控制系统的工作目录中。
    *   主要实现 L2 FRs：FR4。

#### **4. L2 设计矩阵**

基于L2的FRs和DPs，我们构建了`L1-DP8`内部的设计矩阵。

**耦合级别定义：**
*   **X (强耦合 / 实现关系):** DP是唯一直接负责实现FR核心功能的组件。
*   **O_c/O_d (控制/数据耦合):** 一个DP需要调用另一个DP的服务或获取其数据。

| FR / DP | DP1 (命令解析器) | DP2 (任务存储) | DP3 (决策处理器) | DP4 (批注服务) |
| :--- | :---: | :---: | :---: | :---: |
| **FR1: 解析命令** | **X** | | | |
| **FR2: 管理任务生命周期** | | **X** | | |
| **FR3: 处理用户决策** | | O_c/O_d | **X** | |
| **FR4: 存储批注** | | | | **X** |

**矩阵分析可视化 (Mermaid.js Syntax)**

```mermaid
graph TD
    subgraph L2 设计参数 (DPs within DP8)
        DP1[DP1: 命令解析与事件发布器]
        DP2[DP2: 用户任务存储与状态管理器]
        DP3[DP3: 决策处理器]
        DP4[DP4: 批注持久化服务]
    end

    %% DP3 依赖 DP2 来获取和更新任务
    DP3 -- "O_c/O_d (获取/更新任务)" --> DP2

    %% 其他DP之间相互独立
```

#### **5. 公理一 (Independence Axiom) 分析**

**分析结论：L2设计 (V1.0) 是一个解耦的、理想的设计，完全遵循独立公理。**

1.  **实现关系的对角化:** 设计矩阵是一个理想的下三角矩阵。每个L2功能需求（`FR_i`）都由且仅由一个对应的L2设计参数（`DP_i`）直接实现，这构成了满足独立公理的基础。

2.  **关注点分离:** 本设计成功地将 `L1-DP8` 的复杂职责分解为四个独立的关注点：
    *   `DP1`: 处理简单的、同步的命令。
    *   `DP2`: 管理异步任务资源的状态和持久化。
    *   `DP3`: 处理对异步任务的业务逻辑操作。
    *   `DP4`: 处理独立的批注数据流。
    这种分离使得每个组件的职责都非常单一和清晰。

3.  **良性且明确的耦合:**
    *   唯一的非对角线元素是 `DP3` 对 `DP2` 的依赖。这是一种经典且良性的“服务-存储库 (Service-Repository)”模式的弱耦合。`DP3`（服务）封装了业务逻辑，而 `DP2`（存储库）封装了数据访问和持久化逻辑。这种耦合是单向的、通过明确定义的接口进行交互的，它非但没有破坏独立性，反而加强了模块化。对 `DP2` 内部实现（例如，从内存存储切换到数据库）的任何修改，都不会影响 `DP3` 的业务逻辑。

4.  **高内聚，低耦合:** 每个DP都具有高度的内部聚合性，而它们之间的耦合被最小化并严格管理。这种设计使得每个DP都可以被独立地开发、测试、部署和扩展。

综上所述，此L2设计通过功能分解和清晰的职责划分，成功地维护了功能需求的独立性，为构建一个健壮、可维护的 `用户命令与控制` 服务提供了坚实的设计基础。

#### **6. 公理二 (Information Axiom) 分析框架**

公理二的应用将指导本L2层级中具体DP的实现决策。我们将继续沿用L1设计中建立的框架。

**具体应用场景示例：`DP2: 用户任务存储与状态管理器`的持久化方案选择**

在实现`DP2`时，可能存在多种技术方案来持久化用户任务：

*   **备选方案A (内存+文件):** 使用一个内存中的Map来存储活动任务，并在服务关闭时将其序列化到单个JSON文件中。
    *   **优点:** 实现简单，读写速度快。
    *   **缺点:** 无法处理服务异常崩溃，可能丢失数据；并发写入时需要复杂的锁机制。

*   **备选方案B (文件系统):** 每个任务都作为一个独立的JSON文件存储在文件系统的特定目录下（例如，`.workspace/.tasks/{task_id}.json`）。
    *   **优点:** 简单，持久性好，任务隔离。
    *   **缺点:** 在任务量巨大时，文件系统I/O可能成为瓶颈。

*   **备选方案C (嵌入式数据库):** 使用一个轻量级的嵌入式键值数据库（如SQLite, LevelDB）。
    *   **优点:** 提供了事务性、索引和更好的并发性能，持久性强。
    *   **缺点:** 引入了外部依赖，增加了实现和部署的复杂度。

**决策框架:**
依据项目模板的设定，我们将使用以下量化指标来评估方案：

1.  **评估指标 (来自项目模板):**
    *   `数据一致性保证`: 定义为一个枚举值 (无保证, 尽力而为, 强一致性)。
    *   `实现复杂度`: 以“代码行数”的估算值衡量。
    *   `外部依赖数量`: 引入的第三方库的数量。

2.  **指标优先级 (来自项目表模板):** 假设优先级为：`1. 数据一致性保证 > 2. 外部依赖数量 > 3. 实现复杂度`。

3.  **决策:**
    *   **方案A评估:** `数据一致性`=无保证, `实现复杂度`=低, `外部依赖`=0。
    *   **方案B评估:** `数据一致性`=尽力而为, `实现复杂度`=中, `外部依赖`=0。
    *   **方案C评估:** `数据一致性`=强一致性, `实现复杂度`=高, `外部依赖`=1。
    *   **结论:** 根据预设的优先级，`数据一致性`是首要考量。方案C提供了最强的保证。尽管它引入了外部依赖，但如果项目对任务的可靠性要求极高，**应选择备选方案C**。如果可以接受“尽力而为”的保证，则方案B因其无外部依赖而优于方案C。

#### **7. 后续步骤**

1.  **L2设计的正式评审与批准：** 本文档将提交进行评审。
2.  **L2设计冻结：** 评审通过后，本文档将被冻结，作为`DP8`的正式设计规范。
3.  **接口规范定义:** 为本级所有DPs（DP8-1至DP8-4）创建详细的内部接口规范文档，明确每个方法和数据结构。
4.  **更新项目待办事项列表:** 将“实现DP8-1至DP8-4”和“撰写其接口规范”等任务添加到《项目代办事项列表》中。

---
Gemini 2.5 Pro 0605 writer

---

## IF_L1-DP4_API_Specification Freezed

好的，遵照指示。

我将根据《项目代办事项列表 (V1.8)》中的待办事项，开始执行下一项工作：**撰写《L1-DP4 知识仲裁器 API 接口规范》**。

这份文档将定义 `L1-DP4` 作为一个独立组件的交互契约。它将形式化该模块的输入（一组可能冲突的信息源）和输出（一个经过仲裁的、一致的信息单元）的数据结构，使其可以被系统中的其他组件（如 `L1-DP5` 和 `L1-DP6`）以一种标准化的方式调用。

以下是本次工作的产出文档。

---

### **L1-DP4 知识仲裁器 API 接口规范 (V1.0)**

**状态:** 已批准(approved)

**版本说明:** 本文档 (V1.0) 是该 API 规范的初版。其目的是为 `L1-DP4: 知识仲裁器` 组件定义一个清晰、标准化的交互接口。该接口将《L1-DP4 知识冲突仲裁逻辑规则定义 (V1.0)》中形式化的逻辑封装成一个可供调用的服务。

#### **1. 引言**

本文档定义了 `L1-DP4: 知识仲裁器` 的应用程序编程接口（API）。`L1-DP4` 的唯一职责是解决来自不同内部知识源的信息冲突。此 API 规范定义了调用方如何向仲裁器提交一组可能冲突的信息，以及如何接收经过仲裁后的、唯一的、权威的决策结果。

**设计目标:**
*   **标准化:** 提供一个稳定的、定义良好的接口，将仲裁逻辑与调用方（如 `L1-DP5` 内容生成引擎）解耦。
*   **简单性:** 接口设计应尽可能简单，反映其作为单一职责纯函数的本质。
*   **确定性:** 对于任何给定的输入，输出必须是完全可预测的，严格遵循已批准的仲裁逻辑。

**设计依据:**
*   **《L1-DP4 知识冲突仲裁逻辑规则定义 (V1.0)》 (核心逻辑)**
*   《公理设计辅助系统 L1 公理设计文档 (V1.1)》
*   《项目代办事项列表 (V1.8)》

#### **2. 接口设计哲学与实现假设**

*   **同步函数调用 (Synchronous Function Call):** `L1-DP4` 被设计为一个**无状态的、纯粹的逻辑组件**。因此，其 API 最适合被实现为一个简单的、同步的函数或方法调用，而不是一个网络服务（如 RESTful API）。本规范将以函数签名的形式进行定义，其数据模型则以 JSON 结构进行说明，以便于跨语言实现。
*   **无状态 (Stateless):** 每次调用都是独立的。仲裁器不应依赖于任何先前的调用历史或外部状态。
*   **不可知性 (Agnostic):** 仲裁器不关心信息的主题或内容本身，它只关心信息单元的 `source_component` 标识符，并据此应用优先级规则。

#### **3. 数据模型 (Data Models)**

##### **3.1. `ConflictingInformationUnit` (冲突信息单元)**
这是提交给仲裁器的基本信息单元。

```json
{
  "source_component": "string",
  "content": "string",
  "metadata": {
    "type": "object",
    "optional": true
  }
}
```

*   `source_component` (string, 必需): 信息的来源组件标识。其值必须是系统中已知的、会产生知识冲突的组件ID。有效值包括：
    *   `"L1-DP2"` (来自项目词汇服务)
    *   `"L1-DP3"` (来自知识检索服务)
*   `content` (string, 必需): 信息单元的文本内容。
*   `metadata` (object, 可选): 一个键值对对象，用于携带原始的元数据，仲裁器会将其原样传递给获胜的单元。

##### **3.2. `ArbitrationRequest` (仲裁请求)**
这是调用仲裁接口时使用的输入数据结构。

```json
{
  "topic": "string",
  "units": [
    { "$ref": "#/definitions/ConflictingInformationUnit" }
  ]
}
```

*   `topic` (string, 必需): 描述当前正在仲裁的主题或术语。此字段主要用于日志记录和调试，帮助追溯决策过程。例如：`"术语 'FR' 的定义"`。
*   `units` (array, 必需): 一个 `ConflictingInformationUnit` 对象的数组，包含所有需要进行仲裁的信息。

##### **3.3. `ArbitrationResponse` (仲裁响应)**
这是仲裁接口返回的数据结构。

```json
{
  "winning_unit": {
    "type": "object",
    "value": { "$ref": "#/definitions/ConflictingInformationUnit" }
  }
}
```

*   `winning_unit` (object, **可为 null**): 经过仲裁后被选中的唯一 `ConflictingInformationUnit`。
    *   如果根据规则有明确的胜出者，此字段将包含该信息单元的完整对象。
    *   如果输入的 `units` 数组为空，或不包含任何来自有效来源组件的信息，此字段将为 `null`。

#### **4. 接口定义**

##### **`arbitrate(request: ArbitrationRequest) -> ArbitrationResponse`**

*   **描述:** 根据《L1-DP4 知识冲突仲裁逻辑规则定义》中定义的优先级规则，对一组冲突信息单元进行仲裁。
*   **输入 (Input):**
    *   `request` (`ArbitrationRequest`): 一个包含待仲裁信息单元的请求对象。
*   **输出 (Output):**
    *   一个 `ArbitrationResponse` 对象。该对象中的 `winning_unit` 字段将包含获胜的信息单元，或在没有有效信息时为 `null`。
*   **错误处理 (Error Handling):**
    *   **无效输入:** 如果 `request` 对象本身为 `null` 或其必需字段（如 `topic`, `units`）缺失，实现时应抛出一个明确的参数错误异常（例如，`IllegalArgumentException` 或等效的语言特性）。这属于调用方的契约违规。
    *   **执行逻辑:** 函数的执行逻辑**必须**严格遵循《L1-DP4 知识冲突仲裁逻辑规则定义 (V1.0)》中的伪代码。

#### **5. 示例调用流程**

##### **场景 A: 存在冲突，L1-DP2 胜出**

**背景:** 一个上游组件（如 `L1-DP5` 的上下文聚合器）需要获取术语 "FR" 的定义，并同时从词汇服务和知识库服务获取了信息。

1.  **调用方构建 `ArbitrationRequest`:**

    ```json
    {
      "topic": "Definition of term 'FR'",
      "units": [
        {
          "source_component": "L1-DP3",
          "content": "FR can stand for 'France' or 'Financial Review'.",
          "metadata": { "retrieval_score": 0.75 }
        },
        {
          "source_component": "L1-DP2",
          "content": "Functional Requirement",
          "metadata": { "source": "project_lexicon.json" }
        }
      ]
    }
    ```

2.  **调用 `arbitrate` 函数**。

3.  **函数返回 `ArbitrationResponse`:**
    仲裁器内部逻辑应用“L1-DP2 优先于 L1-DP3”的规则。

    ```json
    {
      "winning_unit": {
        "source_component": "L1-DP2",
        "content": "Functional Requirement",
        "metadata": { "source": "project_lexicon.json" }
      }
    }
    ```

4.  **调用方接收响应**，并使用 `winning_unit` 中的内容继续其工作流程。

##### **场景 B: 无冲突，只有 L1-DP3 的信息**

**背景:** 调用方需要了解 "微服务架构" 的信息，该术语未在项目词汇中定义。

1.  **调用方构建 `ArbitrationRequest`:**

    ```json
    {
      "topic": "Information about 'Microservice Architecture'",
      "units": [
        {
          "source_component": "L1-DP3",
          "content": "Microservices is an architectural style...",
          "metadata": { "retrieval_score": 0.91 }
        }
      ]
    }
    ```

2.  **调用 `arbitrate` 函数**。

3.  **函数返回 `ArbitrationResponse`:**
    由于没有来自 `L1-DP2` 的信息，`L1-DP3` 的信息单元成为唯一候选并胜出。

    ```json
    {
      "winning_unit": {
        "source_component": "L1-DP3",
        "content": "Microservices is an architectural style...",
        "metadata": { "retrieval_score": 0.91 }
      }
    }
    ```

##### **场景 C: 无有效输入**

1.  **调用方构建空的 `ArbitrationRequest`:**

    ```json
    {
      "topic": "An empty request",
      "units": []
    }
    ```

2.  **调用 `arbitrate` 函数**。

3.  **函数返回 `ArbitrationResponse`:**
    由于没有可供选择的信息单元，`winning_unit` 为 `null`。

    ```json
    {
      "winning_unit": null
    }
    ```

---
Gemini 2.5 Pro 0605 writer

---

## IF_L1-DP5_ContentEngine_API_Specification Freezed

好的，遵照指示。

我将依据《公理设计辅助系统 L1 公理设计文档 (V1.1)》中对 `L1-DP5` 的职责定义，以及它与其他设计参数 (DPs) 之间的交互关系，开始撰写《L1-DP5 内容生成与修订引擎 API 接口规范》。

此 API 的设计将严格遵循独立公理，确保 `L1-DP5` 作为一个纯粹的功能引擎，接收所有必要的上下文作为输入，并输出文档内容作为结果，而不耦合任何关于“如何获取上下文”或“如何存储结果”的逻辑。

以下是本次工作的产出文档。

---

### **L1-DP5 内容生成与修订引擎 API 接口规范 (V1.0)**

**状态:** 已批准 (Approved)s

**版本说明:** 本文档 (V1.0) 是该 API 接口规范的初版。

#### **1. 引言**

本文档详细定义了 `L1-DP5: 内容生成与修订引擎` 的应用程序编程接口（API）。根据《公理设计辅助系统 L1 公理设计文档 (V1.1)》，`L1-DP5` 的核心功能需求 (FR5) 是 **“起草与修订文档内容”**。它封装了大型语言模型 (LLM) 的文本生成和编辑能力，是系统内容创作的核心驱动力。

**设计哲学: 无副作用的纯函数 (Side-effect Free Pure Function)**
本 API 的设计严格遵循函数式编程思想。它将 `L1-DP5` 建模为一个无状态的、确定性的函数。其核心职责是：接收一个包含所有必要上下文的请求，并返回一份新生成的文档内容和一份修订摘要。

*   **输入 (Input):** 一个包含完整上下文的 `DocumentGenerationRequest` 对象。
*   **输出 (Output):** 一个包含新文档内容和元数据的 `DocumentGenerationResponse` 对象。
*   **无副作用 (Side-effect Free):** `L1-DP5` **不直接**与版本控制系统 (`L1-DP7`)、文件系统或任何其他持久化存储进行交互。它不负责获取其所需的上下文数据，也不负责存储其产出的结果。这些职责由其调用方（如 `L1-DP0`）和其他服务（如 `L1-DP2`, `L1-DP3`, `L1-DP7`）承担。这种设计确保了 `L1-DP5` 的高度独立性和可测试性。

**设计依据:**
*   《公理设计辅助系统 L1 公理设计文档 (V1.1)》 (FR5, DP5)
*   《软件用户需求文档 (URD) V1.6》 (§2.1, §7.3)
*   所有相关的 L1 Schema 规范文档 (项目模板, 词汇约束, 审查意见, 即时反馈批注)

#### **2. API 通用约定**

*   **主机地址 (Base URL):** 本规范不定义具体的主机地址。在实际部署中，应通过服务发现机制或配置文件来提供。所有路径均基于此 Base URL。
*   **API 版本:** API 版本通过 URL 路径进行标识。本规范定义的版本为 `v1`。
    *   示例: `https://<hostname>/api/v1/...`
*   **数据格式:** 所有请求体（`Request Body`）和响应体（`Response Body`）均使用 `application/json` 格式，并采用 `UTF-8` 编码。
*   **认证与授权:** 遵循系统统一规范。所有请求**必须**同时包含**身份标识**和**认证凭据**。
    *   **认证方式 (Authentication):** HTTP Header `Authorization: Bearer <system_component_token>`
    *   **身份标识 (Identification):** HTTP Header `X-System-Component-ID`
*   **错误处理:** API 使用标准的 HTTP 状态码。错误响应体应包含一个标准化的错误对象。

#### **3. 核心资源与数据模型**

##### **3.1. DocumentGenerationRequest (文档生成请求)**
这是一个综合性的请求对象，封装了 `L1-DP5` 执行任务所需的所有上下文信息。

```json
{
  "generation_mode": "string",
  "target_document_uri": "string (optional)",
  "current_content": "string (optional)",
  "context": {
    "llm_behavioral_style": "string",
    "upstream_documents": [
      {
        "uri": "string",
        "content": "string"
      }
    ],
    "lexicon_and_constraints": {
      "type": "object",
      "schema": "L1-DP2_LexiconConstraints_Schema (V1.2)"
    },
    "knowledge_fragments": [
      {
        "source": "string (URI)",
        "content": "string"
      }
    ],
    "review_feedback": {
      "type": "object",
      "optional": true,
      "schema": "L1-DP6_ReviewFeedback_Schema (V1.0) JSON mapping"
    },
    "priority_revisions": {
      "type": "object",
      "optional": true,
      "schema": "L1-DP8_PriorityRevisions_Schema (V1.1) JSON mapping"
    }
  }
}
```

*   `generation_mode` (string, enum, 必需): 生成模式。`FROM_SCRATCH` (从零撰写) 或 `REVISION` (修订)。
*   `target_document_uri` (string, 可选): 正在修订的文档的URI。在 `REVISION` 模式下必需。
*   `current_content` (string, 可选): 正在修订的文档的当前内容。在 `REVISION` 模式下必需。
*   `context` (object, 必需): 包含所有上下文信息的容器。
    *   `llm_behavioral_style` (string, 必需): 来自项目模板，定义了“撰写员”LLM的行为和风格。
    *   `upstream_documents` (array, 可选): 上游依赖文档的列表，每个对象包含其URI和完整内容。
    *   `lexicon_and_constraints` (object, 可选): 从 `L1-DP2` 获取的、完整的“项目词汇与约束”对象。
    *   `knowledge_fragments` (array, 可选): 从 `L1-DP3` 获取的相关知识片段列表。
    *   `review_feedback` (object, 可选): 来自 `L1-DP6` 的结构化审查意见。其JSON结构应精确映射自 `review_feedback.md` 的 Schema。仅在 `REVISION` 模式下提供。
    *   `priority_revisions` (object, 可选): 来自 `L1-DP8` 的、用户提供的即时反馈批注。其JSON结构应精确映射自 `priority_revisions.yaml` 的 Schema。仅在 `REVISION` 模式下提供。

##### **3.2. DocumentGenerationResponse (文档生成响应)**
这是 `L1-DP5` 成功执行后返回的对象。

```json
{
  "status": "string",
  "new_content": "string",
  "revision_summary": "string (Markdown)",
  "failure_reason": "string (optional)"
}
```

*   `status` (string, enum, 必需): `SUCCESS` 或 `FAILED`。
*   `new_content` (string): 当 `status` 为 `SUCCESS` 时，此字段包含新生成的完整文档内容 (Markdown 格式)。
*   `revision_summary` (string, Markdown): 当 `status` 为 `SUCCESS` 且 `generation_mode` 为 `REVISION` 时，此字段包含一份由 LLM 生成的、对本次修订的说明。该说明应明确回应审查意见中的每一项，便于 `L1-DP6` 进行下一轮审查。
*   `failure_reason` (string, 可选): 当 `status` 为 `FAILED` 时，此字段必须包含对失败原因的描述（例如，“无法解决审查意见中的关键冲突”）。

#### **4. 端点定义 (Endpoint Definition)**

遵循纯函数的设计哲学，系统仅需一个核心端点来处理所有内容生成和修订任务。

##### **POST /api/v1/documents/generate**
*   **描述:** 根据提供的完整上下文，执行一次文档生成或修订任务。这是一个同步的、计算密集型的操作。
*   **请求体:** `DocumentGenerationRequest` 对象。
*   **成功响应:**
    *   **状态码:** `200 OK`
    *   **响应体:** `DocumentGenerationResponse` 对象。即使内部LLM逻辑判定无法完成任务 (`status: FAILED`)，只要请求本身合法且被处理，API层面也应返回 `200 OK`，并将失败的细节体现在响应体中。
*   **错误响应:**
    *   `400 Bad Request`: 请求体不符合 `DocumentGenerationRequest` 的 Schema（例如，缺少必需字段）。
    *   `500 Internal Server Error`: `L1-DP5` 内部发生未预期的、无法处理的错误（例如，LLM服务本身不可用）。

#### **5. 示例：修订任务调用流程**

**背景:** `L1-DP0`（工作流控制器）需要 `L1-DP5` 修订一份L2设计文档。该修订需要同时考虑来自 `L1-DP6` 的正式审查意见和来自 `L1-DP8` 的用户即时批注。

1.  **上下文聚合:** `L1-DP0` (或其委托的上下文聚合器) 分别从 `L1-DP1`, `L1-DP2`, `L1-DP3`, `L1-DP7`, `L1-DP6`, `L1-DP8` 获取所有必需的数据。
2.  **构建请求:** `L1-DP0` 构建一个 `DocumentGenerationRequest` 对象。
3.  **API 调用:** `L1-DP0` 向 `L1-DP5` 发起 `POST /api/v1/documents/generate` 请求，请求体如下：

    ```json
    {
      "generation_mode": "REVISION",
      "target_document_uri": "vcs://project-alpha/docs/AD_L2_DP5_ContentEngine.md?commit=a1b2c3d4",
      "current_content": "# AD_L2_DP5_ContentEngine.md\n\n...",
      "context": {
        "llm_behavioral_style": "You are a meticulous system architect...",
        "upstream_documents": [
          {
            "uri": "vcs://project-alpha/docs/ADD_L1.md?commit=f4a3b2c1",
            "content": "# 公理设计辅助系统 L1 公理设计文档 (V1.1)\n\n..."
          }
        ],
        "lexicon_and_constraints": {
          "schemaVersion": "1.2",
          "lexicon": { "...": "..." }
        },
        "knowledge_fragments": [
          {
            "source": "file:///kb/architecture/functional-design.md",
            "content": "A pure function's return value is the same for the same arguments."
          }
        ],
        "review_feedback": {
          "review_id": "rev-20250608-x7y8z9",
          "overall_decision": "ARBITRATION_REQUIRED",
          "findings": [
            {
              "finding_id": "find-001",
              "severity": "CRITICAL",
              "description": "独立公理违反：L2设计矩阵显示FR2对DP3存在依赖...",
              "suggestion": "考虑创建一个新的L2-DP来处理..."
            }
          ]
        },
        "priority_revisions": {
          "targetDocumentUri": "vcs://project-alpha/docs/AD_L2_DP5_ContentEngine.md?commit=a1b2c3d4",
          "annotations": [
            {
              "annotationId": "prev-001",
              "comment": "请将'纯函数'这个概念在设计哲学部分进行更明确的阐述。"
            }
          ]
        }
      }
    }
    ```
4.  **处理与响应:** `L1-DP5` 接收请求，将其所有上下文整合后生成一个大的Prompt，调用内部的LLM。LLM执行修订，并生成新的内容和修订摘要。`L1-DP5` 封装后返回 `200 OK`，响应体如下：

    ```json
    {
      "status": "SUCCESS",
      "new_content": "# AD_L2_DP5_ContentEngine.md\n\n## 1. 设计哲学\n\n本API的设计严格遵循函数式编程思想，特别是'纯函数 (Pure Function)'的概念...\n\n### 4. L2 设计矩阵\n\n| FR / DP | DP1 | DP2 | DP_new | \n| :--- | :---: | :---: | :---: |\n| **FR1** | X | | |\n| **FR2** | O_d | X | |\n| **FR_new** | | | X |\n\n...",
      "revision_summary": "### 本次修订说明\n\n本次修订重点解决了审查意见和用户批注中的所有问题：\n\n1.  **回应用户批注 `prev-001`:** 在“设计哲学”一节中，增加了对“纯函数”概念的详细阐述。\n2.  **解决审查发现 `find-001` (CRITICAL):** 采纳了审查建议，对设计进行了重构。通过引入一个新的设计参数 `DP_new` 并将原 `FR2` 的部分功能拆分至新的 `FR_new`，成功消除了原设计矩阵中的耦合，使新矩阵符合独立公理。\n"
    }
    ```
5.  **后续步骤:** `L1-DP0` 接收到此响应后，会将 `new_content` 和 `revision_summary` 传递给 `L1-DP7` 服务，以创建一次新的Git提交，从而完成整个修订-提交的闭环。

---
Gemini 2.5 Pro 0605 writer

---

## IF_L1-DP6_API_Specification Freezed

好的，遵照指示。

我已收到并深入理解了《评审意见：关于<L1-DP6 评审与评估引擎 API 接口规范 (V1.0)>》中下达的强制性修订指令。评审结论为“驳回，需强制性修订”。

我将依据评审意见中列出的两项强制性修订指令和一项建议性修订意见，对该 API 规范进行重大修订。本次修订旨在解决原设计中存在的、关于核心工作流驱动和技术架构健壮性的致命缺陷与重大风险。

以下是根据上述评审意见修订后的完整文档。

---

### **L1-DP6 评审与评估引擎 API 接口规范 (V1.1)**

**状态:** **已批准 (Approved)**

**版本说明:** 本文档 (V1.1) 是对 V1.0 版本的重大修订。它依据《评审意见：关于<L1-DP6 评审与评估引擎 API 接口规范 (V1.0)>》进行了强制性修订，以解决核心工作流驱动和技术架构的健壮性问题。核心变更包括：
1.  **支持仲裁流程:** 为 `ReviewResponse` 模型增加了 `ARBITRATION_REQUIRED` 决策和 `decision_reason` 字段，使 API 能够将“需要用户仲裁”的关键事件通知给工作流控制器 (`L1-DP0`)，解决了原设计中无法驱动核心状态转换的致命缺陷 (URD §4.3)。
2.  **实现异步任务模式:** 将 `POST /api/v1/reviews` 端点重构为异步模式。调用后立即返回 `202 Accepted` 并提供一个任务URL，调用方通过轮询 `GET /api/v1/reviews/{review_id}` 端点获取最终结果。这解决了同步阻塞模式在处理长时任务时的超时风险和可扩展性问题。
3.  **增强类型安全:** 将 `ReviewRequest.context.upstream_documents.relationship` 字段明确为枚举类型，提高了 API 契约的健壮性。

#### **1. 引言**

本文档详细定义了 `L1-DP6: 评审与评估引擎` 的应用程序编程接口（API）。根据《公理设计辅助系统 L1 公理设计文档 (V1.1)》，`L1-DP6` 的核心职责是接收来自 `L1-DP0` 的评审任务，并依据项目模板中定义的标准（如审查清单）、项目词汇与约束、以及公理设计原则，对文档草稿进行全面的自动化评审。

**设计目标:**
*   **指令式调用 (Instructional Call):** API 接收一个高层级的评审指令，而不是海量的内容数据。引擎自身负责根据指令中的引用（URI）去获取所需的数据。
*   **结构化输出 (Structured Output):** API 的响应**必须**是一个结构化的 JSON 对象，而非纯文本。这确保了评审结果可以被系统确定性地解析和处理。
*   **解耦 (Decoupling):** 将评审逻辑与工作流控制逻辑 (`L1-DP0`) 彻底分离，使得评审策略的迭代不影响系统的核心流程。

**设计依据:**
*   《公理设计辅助系统 L1 公理设计文档 (V1.1)》 (对 L1-FR6 和 L1-DP6 的定义)
*   《软件用户需求文档 (URD) V1.6》 (特别是 §2.1, §4.2, §4.3, §6.3)
*   《评审意见：关于<L1-DP6 评审与评估引擎 API 接口规范 (V1.0)>》

#### **2. API 通用约定**

*   **主机地址 (Base URL):** 本规范不定义具体的主机地址。在实际部署中，应通过服务发现机制或配置文件来提供。所有路径均基于此 Base URL。
*   **API 版本:** API 版本通过 URL 路径进行标识。本规范定义的版本为 `v1`。
    *   示例: `https://<hostname>/api/v1/...`
*   **数据格式:** 所有请求体（`Request Body`）和响应体（`Response Body`）均使用 `application/json` 格式，并采用 `UTF-8` 编码。
*   **认证与授权:** 本 API 要求所有请求**必须**同时包含**身份标识**和**认证凭据**。
    *   **认证方式 (Authentication):** 请求方必须在 HTTP Header 中提供一个承载秘密信息的 `Authorization` 字段。
        *   **值格式:** `Bearer <token>`
    *   **身份标识 (Identification):** 请求方必须在 HTTP Header 中提供 `X-System-Component-ID` 字段，其值为调用方组件的标识符（例如 `L1-DP0`）。
*   **错误处理:** API 使用标准的 HTTP 状态码。错误响应体应包含一个标准化的错误对象。

#### **3. 核心概念**

*   **异步任务 (Asynchronous Task):** 评审是一个潜在的长时运行任务。API 调用通过启动一个后台任务来处理，并立即返回一个任务标识符。调用方必须通过该标识符异步轮询任务的状态和最终结果。
*   **评审决策 (Review Decision):** API 返回的最高级别结论，明确指出文档是被“批准”、“需要修订”还是需要“用户仲裁”。
*   **结构化发现 (Structured Finding):** 对文档中单个问题的具体描述，包含问题的严重性、位置、描述和建议，是构成审查意见的基本单元。
*   **统一资源标识符 (URI):** API 请求中不直接传递大型文档内容，而是通过 URI 进行引用。这要求 `L1-DP6` 的实现能够通过调用其他服务（如 `L1-DP7` 版本控制服务）来解析这些 URI 并获取内容。示例 URI 格式: `vcs://project-alpha/docs/AD_L2.md?commit=a1b2c3d4`。

#### **4. 数据模型 (Data Models)**

##### **4.1. ReviewRequest (评审请求)**
这是 `POST /api/v1/reviews` 端点的请求体。

```json
{
  "document_uri": "string",
  "context": {
    "template_uri": "string",
    "lexicon_uri": "string",
    "upstream_documents": [
      {
        "uri": "string",
        "relationship": "string"
      }
    ]
  },
  "previous_review_cycle": {
    "type": "object",
    "optional": true,
    "properties": {
      "review_feedback_uri": "string",
      "writer_summary_uri": "string"
    }
  }
}
```
*   `document_uri` (string, 必需): 待评审文档的唯一版本化 URI。
*   `context` (object, 必需): 评审所需的核心上下文引用。
    *   `template_uri` (string, 必需): 项目模板的 URI，`L1-DP6` 将从中获取审查清单和公理评估指标。
    *   `lexicon_uri` (string, 必需): 项目词汇与约束文件的 URI。
    *   `upstream_documents` (array, 必需): 一个对象数组，列出所有相关的上游文档。
        *   `uri` (string): 上游文档的 URI。
        *   `relationship` (string, enum): 关系类型。枚举值：`PARENT_DOCUMENT` (用于追踪性检查), `CHECKLIST_REFERENCE` (审查清单中引用的文档)。
*   `previous_review_cycle` (object, 可选): 如果是再次评审，此对象包含上一轮循环的产出。

##### **4.2. ReviewResponse (评审响应)**
这是成功评审后返回的数据结构，是 `GET /api/v1/reviews/{review_id}` 的最终成功响应体。

```json
{
  "review_id": "string",
  "overall_decision": "string",
  "decision_reason": {
    "type": "object",
    "optional": true,
    "$ref": "#/definitions/DecisionReason"
  },
  "executive_summary": "string",
  "checklist_responses": [
    { "$ref": "#/definitions/ChecklistResponseItem" }
  ],
  "findings": [
    { "$ref": "#/definitions/Finding" }
  ]
}
```
*   `review_id` (string): 本次评审任务的唯一标识符。
*   `overall_decision` (string): 最终评审决策。枚举值：`APPROVED`, `REVISION_REQUESTED`, `ARBITRATION_REQUIRED`。
*   `decision_reason` (object, 可选): 当 `overall_decision` 为 `ARBITRATION_REQUIRED` 时提供，用于解释触发仲裁的原因。
*   `executive_summary` (string): 对评审结果的总体摘要。
*   `checklist_responses` (array): 对模板中每个审查清单项目的逐项响应。
*   `findings` (array): 发现的具体问题列表。如果 `overall_decision` 为 `APPROVED`，此数组可以为空。

##### **4.3. ChecklistResponseItem (审查清单响应项)**
```json
{
  "checklist_item_text": "string",
  "status": "string",
  "evidence": "string"
}
```
*   `checklist_item_text` (string): 审查清单中的原始条目文本。
*   `status` (string): 该项检查的结果。枚举值：`PASSED`, `FAILED`, `NOT_APPLICABLE`。
*   `evidence` (string): 支持该状态的简要说明或证据。

##### **4.4. Finding (发现项)**
```json
{
  "finding_id": "string",
  "severity": "string",
  "description": "string",
  "location": {
    "document_uri": "string",
    "start_line": "integer",
    "end_line": "integer",
    "context_snippet": "string"
  },
  "suggestion": "string"
}
```
*   `finding_id` (string): 该发现项的唯一标识符。
*   `severity` (string): 问题的严重程度。枚举值：`CRITICAL`, `MAJOR`, `MINOR`, `SUGGESTION`。
*   `description` (string): 对问题的详细描述。
*   `location` (object): 问题在文档中的精确定位。
*   `suggestion` (string, 可选): 具体的修改建议。

##### **4.5. DecisionReason (决策原因)**
```json
{
  "code": "string",
  "message": "string"
}
```
*   `code` (string): 机器可读的触发代码。枚举值：`MAX_CYCLES_REACHED`, `STALEMATE_DETECTED`。
*   `message` (string): 对触发原因的人类可读描述。

##### **4.6. ReviewStatus (评审状态)**
这是 `POST /api/v1/reviews` 成功后的响应体，以及任务进行中时 `GET /api/v1/reviews/{review_id}` 的响应体。
```json
{
  "review_id": "string",
  "status": "string"
}
```
*   `review_id` (string): 评审任务的唯一标识符。
*   `status` (string): 评审任务的当前状态。枚举值: `PENDING`, `RUNNING`。

#### **5. 端点定义**

##### **POST /api/v1/reviews**
*   **描述:** 启动一个新的文档评审任务。这是一个**异步**操作。API 会验证请求的合法性，创建任务，然后立即返回 `202 Accepted`，并附带一个 `Location` 头，指向可用于查询任务状态和结果的资源 URL。
*   **请求体:** `ReviewRequest` 对象。
*   **成功响应:**
    *   **状态码:** `202 Accepted`
    *   **Headers:** `Location: /api/v1/reviews/{review_id}`
    *   **响应体:** 一个 `ReviewStatus` JSON 对象，其状态为 `PENDING`。
*   **错误响应:**
    *   `400 Bad Request`: 请求体格式错误，或缺少必需的字段。
    *   `404 Not Found`: 请求中引用的某个 URI 无法被解析或找到。
    *   `401 Unauthorized`, `403 Forbidden`。
    *   `500 Internal Server Error`: 启动评审任务时发生内部错误。

##### **GET /api/v1/reviews/{review_id}**
*   **描述:** 查询一个特定评审任务的状态或获取其最终结果。客户端应轮询此端点直至任务完成。
*   **路径参数:** `review_id` (string, 必需): 通过 `POST` 请求创建任务时返回的唯一ID。
*   **成功响应:**
    *   **当任务正在进行中:**
        *   **状态码:** `200 OK`
        *   **响应体:** 一个 `ReviewStatus` JSON 对象，其 `status` 字段为 `PENDING` 或 `RUNNING`。
    *   **当任务已完成:**
        *   **状态码:** `200 OK`
        *   **响应体:** 一个完整的 `ReviewResponse` JSON 对象。
*   **错误响应:**
    *   `404 Not Found`: 指定的 `review_id` 不存在。
    *   `401 Unauthorized`, `403 Forbidden`。
    *   `500 Internal Server Error`: 获取任务状态或结果时发生内部错误。

#### **6. 示例：调用流程与cURL**

**场景:** `L1-DP0` 提交一份文档草稿供评审。在多次修订后，评审已达到项目模板中设定的最大循环次数，引擎决定需要用户仲裁。

##### **步骤 1: 提交评审任务 (POST)**
`L1-DP0` 发起评审请求。
```bash
# L1-DP0 (工作流控制器) 请求评审一份文档草稿
curl -i -X POST \
  -H "Authorization: Bearer <system_component_token>" \
  -H "X-System-Component-ID: L1-DP0" \
  -H "Content-Type: application/json" \
  -d '{
    "document_uri": "vcs://project-alpha/docs/AD_L2_DP5_ContentEngine.md?commit=a1b2c3d4",
    "context": {
      "template_uri": "vcs://project-alpha/templates/default-engineering-v1-2.project.json?commit=f5e6d7c8",
      "lexicon_uri": "vcs://project-alpha/lexicon/project.lexicon.json?commit=b9a8c7d6",
      "upstream_documents": [
        {
          "uri": "vcs://project-alpha/docs/ADD_L1.md?commit=frozen-v1.1",
          "relationship": "PARENT_DOCUMENT"
        }
      ]
    }
  }' \
  'https://<hostname>/api/v1/reviews'

# 服务器接受请求，创建任务，并立即返回
# HTTP/1.1 202 Accepted
# Location: /api/v1/reviews/rev-20250608-x7y8z9
# Content-Type: application/json
#
# {
#   "review_id": "rev-20250608-x7y8z9",
#   "status": "PENDING"
# }
```

##### **步骤 2: 轮询任务状态 (GET)**
`L1-DP0` 使用 `Location` 头中的 URL 轮询任务状态。
```bash
# L1-DP0 轮询任务状态
curl -X GET \
  -H "Authorization: Bearer <system_component_token>" \
  -H "X-System-Component-ID: L1-DP0" \
  'https://<hostname>/api/v1/reviews/rev-20250608-x7y8z9'

# 任务正在进行中，服务器返回状态
# HTTP/1.1 200 OK
# Content-Type: application/json
#
# {
#   "review_id": "rev-20250608-x7y8z9",
#   "status": "RUNNING"
# }
```

##### **步骤 3: 获取最终结果 (GET)**
`L1-DP0` 继续轮询，直到任务完成并获得最终的 `ReviewResponse`。
```bash
# 最终，任务完成，服务器返回完整响应
# HTTP/1.1 200 OK
# Content-Type: application/json
#
# {
#   "review_id": "rev-20250608-x7y8z9",
#   "overall_decision": "ARBITRATION_REQUIRED",
#   "decision_reason": {
#     "code": "MAX_CYCLES_REACHED",
#     "message": "The document review has reached the maximum of 5 cycles without achieving approval."
#   },
#   "executive_summary": "The document still fails to address a critical Independence Axiom violation after multiple revisions. User arbitration is now required to proceed.",
#   "checklist_responses": [
#     {
#       "checklist_item_text": "[Axiom1-Check] Analyze the design matrix for any off-diagonal elements and challenge their necessity.",
#       "status": "FAILED",
#       "evidence": "Finding [find-001] remains unresolved: The L2 design matrix is still not diagonal or lower-triangular, indicating persistent coupling."
#     }
#   ],
#   "findings": [
#     {
#       "finding_id": "find-001",
#       "severity": "CRITICAL",
#       "description": "Independence Axiom Violation: The L2 design matrix shows a dependency of FR2 on DP3. This coupling must be eliminated by redefining the FRs or DPs to achieve a decoupled design.",
#       "location": {
#         "document_uri": "vcs://project-alpha/docs/AD_L2_DP5_ContentEngine.md?commit=a1b2c3d4",
#         "start_line": 85,
#         "end_line": 92,
#         "context_snippet": "| FR / DP | DP1 | DP2 | DP3 |\n| :--- | :---: | :---: | :---: |\n| **FR1** | X | | |\n| **FR2** | O_d | X | O_d |"
#       },
#       "suggestion": "Consider creating a new L2-DP to handle the functionality that FR2 needs from DP3, or redefine FR2 to not require this information directly."
#     }
#   ]
# }
```

---
Gemini 2.5 Pro 0605 writer

---

## IF_L1-DP7_API_Specification Freezed

好的，遵照指示。

我已收到并深入理解了《评审意见：关于<L1-DP7 版本控制与变更服务 API 接口规范 (V1.0)>》中下达的强制性修订指令。评审结论为“驳回，需强制性修订”。

我将依据评审意见中列出的两项强制性修订指令和两项建议性修订意见，对该 API 规范进行重大修订。本次修订旨在解决原设计中存在的、关于核心功能缺失和架构抽象泄漏的重大缺陷。

以下是根据上述评审意见修订后的完整文档。

---

### **L1-DP7 版本控制与变更服务 API 接口规范 (V1.1)**

**状态:** 已批准(Approved)

**版本说明:** 本文档 (V1.1) 是对 V1.0 版本的重大修订。它依据《评审意见：关于<L1-DP7 版本控制与变更服务 API 接口规范 (V1.0)>》进行了强制性修订，以解决核心功能缺失和架构抽象泄漏的问题。核心变更包括：
1.  **新增文档层级关系管理:** 新增了 `/metadata` 端点和 `DocumentMetadata` 数据模型，用于管理文档间的父子层级关系。此项变更是为了满足 URD §2.4.c 中对“之字形分解”可追溯性的核心需求，解决了 V1.0 中最重大的功能缺失。
2.  **封装实现细节 (消除抽象泄漏):** 重构了 `PUT .../state` 端点，从请求体中移除了 `tag_name` 字段。调用方现在只需声明“冻结”的业务意图，而无需关心底层的 Git 标签实现，这加强了服务的抽象和解耦。
3.  **增强 API 响应一致性:** 采纳了建议，将 `POST /api/v1/commits` 的响应更新为返回 `Location` 头和完整的 `VersionSummary` 对象，使其更符合 RESTful 实践。
4.  **明确临时分支生命周期:** 采纳了建议，在文档中明确指出用于变更管理的临时分支将在流程结束后被自动清理。

#### **1. 引言**

本文档详细定义了 `L1-DP7: 版本控制与变更服务` 的应用程序编程接口（API）。根据《公理设计辅助系统 L1 公理设计文档 (V1.1)》，`L1-DP7` 的核心职责是提供与外部 Git 仓库交互的标准接口，并实现文档状态管理和变更管理的核心逻辑。

本 API 的设计哲学是 **抽象化** 和 **面向资源**。它将 Git 的底层概念（如 commit, tree, blob, ref, tag）抽象为系统更高层级的业务概念，如 **文档 (Document)**、**版本 (Version)**、**元数据 (Metadata)**、**状态 (State)** 和 **变更提议 (Change Proposal)**。这使得调用方（如 `L1-DP0`, `L1-DP5`）可以不关心底层的 Git 实现细节。

**设计依据:**
*   《公理设计辅助系统 L1 公理设计文档 (V1.1)》
*   《软件用户需求文档 (URD) V1.6》 (特别是 §2.1, §2.4.c, §3.2, §7.1)
*   《评审意见：关于<L1-DP7 版本控制与变更服务 API 接口规范 (V1.0)>》

#### **2. API 通用约定**

*   **主机地址 (Base URL):** 本规范不定义具体的主机地址。在实际部署中，应通过服务发现机制或配置文件来提供。所有路径均基于此 Base URL。
*   **API 版本:** API 版本通过 URL 路径进行标识。本规范定义的版本为 `v1`。
    *   示例: `https://<hostname>/api/v1/...`
*   **数据格式:** 所有请求体（`Request Body`）和响应体（`Response Body`）均使用 `application/json` 格式，并采用 `UTF-8` 编码。
*   **认证与授权:** 本 API 要求所有请求**必须**同时包含**身份标识**和**认证凭据**。
    *   **认证方式 (Authentication):** 请求方必须在 HTTP Header 中提供一个承载秘密信息的 `Authorization` 字段。
        *   **值格式示例:** `Bearer <system_component_token>`
    *   **身份标识 (Identification):** 请求方必须在 HTTP Header 中提供 `X-System-Component-ID` 字段，其值为调用方组件的标识符（例如 `L1-DP0`）。
*   **路径编码:** 文档路径 `document_path` 在 URL 中必须进行标准的百分号编码（Percent-encoding）。
*   **错误处理:** API 使用标准的 HTTP 状态码。错误响应体应包含一个标准化的错误对象。

#### **3. 核心资源与数据模型**

##### **3.1. DocumentContent (文档内容)**
代表一个特定版本的文档内容。
```json
{
  "document_path": "string",
  "content": "string",
  "version_id": "string",
  "last_modified": "string (ISO 8601)"
}
```

##### **3.2. VersionSummary (版本摘要)**
代表版本历史中的一个节点。
```json
{
  "version_id": "string",
  "message": "string",
  "author": "string",
  "timestamp": "string (ISO 8601)"
}
```

##### **3.3. DocumentMetadata (文档元数据)**
存储与文档内容分离的、用于描述文档结构关系的元数据。
```json
{
  "document_path": "string",
  "parent_document_uri": "string (optional)",
  "associated_dp": "string (optional)"
}
```
*   `parent_document_uri` (string, 可选): 指向上游父文档的版本化 URI。
*   `associated_dp` (string, 可选): 指明本文档是上游父文档中哪个设计参数 (DP) 的分解。

##### **3.4. DocumentState (文档状态)**
代表一个文档的生命周期状态。
```json
{
  "document_path": "string",
  "state": "string",
  "version_id": "string"
}
```
*   `state` (string, enum): 枚举值：`DRAFT` (草稿), `FROZEN` (已冻结), `ARCHIVED` (已归档)。

##### **3.5. CommitRequest (提交请求)**
用于向版本库提交一次或多次文件变更的原子操作。
```json
{
  "commit_message": "string",
  "author_component_id": "string",
  "file_changes": [
    {
      "path": "string",
      "new_content": "string"
    }
  ],
  "change_impact_report_uri": "string (optional)"
}
```
*   `commit_message` (string, 必需): 提交信息的主体，服务会根据 URD §7.1 在其基础上添加标准前缀。
*   `author_component_id` (string, 必需): 触发本次提交的组件标识。
*   `file_changes` (array, 必需): 一个包含所有文件变更的数组。
*   `change_impact_report_uri` (string, 可选): 如果本次提交与一次变更管理流程相关，则必须引用《变更影响报告》的 URI。

#### **4. 文档与版本端点 (Document & Version Endpoints)**

##### **GET /api/v1/documents/{document_path}**
*   **描述:** 获取指定文档的最新版本内容。默认从主工作流分支 (e.g., `main`) 获取。
*   **成功响应:** `200 OK`，响应体为 `DocumentContent` 对象。
*   **错误响应:** `404 Not Found`。

##### **GET /api/v1/documents/{document_path}?version={version_id}**
*   **描述:** 获取指定文档的特定版本内容。
*   **成功响应:** `200 OK`，响应体为 `DocumentContent` 对象。
*   **错误响应:** `404 Not Found` (文档或版本不存在)。

##### **GET /api/v1/documents/{document_path}/versions**
*   **描述:** 获取指定文档的版本历史。
*   **成功响应:** `200 OK`，响应体为 `VersionSummary` 对象数组。
*   **错误响应:** `404 Not Found`。

##### **POST /api/v1/commits**
*   **描述:** 提交一次原子性的文件变更。这是系统主要的写入操作，由自动化系统代理 (`Operator`) 调用。
*   **请求体:** `CommitRequest` 对象。
*   **成功响应:**
    *   **状态码:** `201 Created`
    *   **Headers:** `Location: /api/v1/documents/{document_path}?version={new_version_id}`
    *   **响应体:** 一个完整的 `VersionSummary` 对象。
*   **错误响应:** `400 Bad Request`, `409 Conflict` (如发生编辑冲突)。

#### **5. 文档元数据管理端点 (Metadata Management Endpoints)**

此组端点用于管理文档的层级关系，是实现“之字形分解”可追溯性的关键。

##### **GET /api/v1/documents/{document_path}/metadata**
*   **描述:** 获取文档的元数据（如父文档引用）。
*   **成功响应:** `200 OK`，响应体为 `DocumentMetadata` 对象。
*   **错误响应:** `404 Not Found` (文档存在但元数据尚未设置)。

##### **PUT /api/v1/documents/{document_path}/metadata**
*   **描述:** 创建或完整替换文档的元数据。此操作通常在文档首次提交后，由工作流控制器 (`L1-DP0`) 调用以建立其与父文档的链接。
*   **请求体:** `DocumentMetadata` 对象（`document_path` 字段可省略）。
*   **成功响应:** `200 OK`，响应体为更新后的 `DocumentMetadata` 对象。
*   **错误响应:** `400 Bad Request`, `404 Not Found`。

#### **6. 文档状态管理端点 (State Management Endpoints)**

##### **GET /api/v1/documents/{document_path}/state**
*   **描述:** 获取文档的当前生命周期状态。服务通过检查是否存在特定的状态标签（如 `frozen-v1.1`）来确定。
*   **成功响应:** `200 OK`，响应体为 `DocumentState` 对象。
*   **错误响应:** `404 Not Found`。

##### **PUT /api/v1/documents/{document_path}/state**
*   **描述:** 更新文档的生命周期状态。主要用于“冻结”文档。此接口封装了底层的 Git 标签实现细节。
*   **请求体:**
    ```json
    {
      "state": "FROZEN",
      "version_id": "string"
    }
    ```
*   **成功响应:** `200 OK`，响应体为更新后的 `DocumentState` 对象。
*   **错误响应:** `400 Bad Request`, `404 Not Found`, `409 Conflict` (如该版本已被冻结)。

#### **7. 变更管理端点 (Change Management Endpoints)**

此组端点严格遵循 URD §3.2 中定义的变更管理流程。

##### **7.1. 临时分支生命周期**
为变更提议创建的隔离分支是临时性的。在变更流程结束（无论是被执行还是被放弃）后，服务将**自动清理并删除**该临时分支，以保持版本库的整洁。

##### **POST /api/v1/change-proposals**
*   **描述:** 为一个已冻结的文档发起一个变更提议。服务将在后端为此创建一个隔离的变更分支。
*   **请求体:** `{ "source_document_uri": "string" }`
*   **成功响应:** `202 Accepted`，响应体包含新提议的ID和可操作的URL：
    ```json
    {
      "proposal_id": "string",
      "status": "PROPOSED",
      "expires_at": "string (ISO 8601)",
      "actions": {
        "update_content": "/api/v1/change-proposals/{id}/document",
        "analyze": "/api/v1/change-proposals/{id}/analyze"
      }
    }
    ```

##### **PUT /api/v1/change-proposals/{proposal_id}/document**
*   **描述:** 在变更提议的隔离分支中，更新文档内容。
*   **请求体:** `{ "content": "string" }`
*   **成功响应:** `200 OK`。

##### **POST /api/v1/change-proposals/{proposal_id}/analyze**
*   **描述:** 触发对变更的依赖分析。这是一个异步操作。
*   **成功响应:** `202 Accepted`。

##### **GET /api/v1/change-proposals/{proposal_id}/analysis-report**
*   **描述:** 获取依赖分析的结果。客户端应轮询此端点。
*   **成功响应:**
    *   当分析正在进行时: `200 OK`, `{ "status": "ANALYZING" }`。
    *   当分析完成时: `200 OK`，响应体为结构化的依赖报告，包含置信度评分 (URD §3.2.3.1)。
*   **错误响应:** `404 Not Found`。

##### **POST /api/v1/change-proposals/{proposal_id}/confirm**
*   **描述:** 用户确认分析报告，并最终决定需要作废的下游文档清单。服务在此步骤生成并存储《变更影响报告》。
*   **请求体:** `{ "invalidated_documents": ["uri1", "uri2"] }`
*   **成功响应:** `200 OK`，响应体包含已生成的《变更影响报告》的URI。
*   **错误响应:** `409 Conflict` (如果分析尚未完成)。

##### **POST /api/v1/change-proposals/{proposal_id}/execute**
*   **描述:** 执行最终的变更。服务将合并变更分支，并使用《变更影响报告》的URI作为提交信息的一部分来创建一个新的提交。成功执行后，临时分支将被自动删除。
*   **成功响应:** `200 OK`，响应体包含新的 `version_id`。
*   **错误响应:** `409 Conflict` (如果确认步骤未完成)。

---
Gemini 2.5 Pro 0605 writer

---

## IF_L1-DP8_UserCommandControl_API_Specification Freezed

好的，遵照指示。

我将基于《公理设计辅助系统 L1 公理设计文档 (V1.1)》中对 `L1-DP8` 的职责定义，以及《软件用户需求文档 (URD) V1.6》中所有与用户交互相关的需求，设计一份全新的、职责清晰的 API 接口规范。

这份规范的设计将严格遵循系统内其他 API 规范（如 `L1-DP6`, `L1-DP7`）所建立的模式，特别是采用异步任务模型来处理需要用户等待和决策的交互，以确保架构的一致性和健壮性。

以下是为 `L1-DP8 用户命令与控制` 撰写的 API 接口规范文档。

---

### **L1-DP8 用户命令与控制 API 接口规范 (V1.0)**

**状态:** 已批准（Approved）

**版本说明:** 本文档是 `L1-DP8` API 接口规范的初始版本 (V1.0)。其设计旨在满足《公理设计辅助系统 L1 公理设计文档 (V1.1)》中定义的 `FR8: 处理用户交互与决策` 的功能需求，并为《软件用户需求文档 (URD) V1.6》中描述的各类用户交互场景（如流程控制、用户仲裁、变更决策、即时批注）提供一个明确、健壮且一致的编程接口。

#### **1. 引言**

本文档详细定义了 `L1-DP8: 用户命令与控制` 的应用程序编程接口（API）。根据 L1 设计，`L1-DP8` 是连接自动化系统（以 `L1-DP0` 为核心）与人类用户的唯一桥梁。其核心职责是捕获所有用户输入（命令、决策、批注），将其解析为系统内部的标准化事件和数据，并管理需要用户参与的异步任务。

**设计哲学:**
*   **命令与查询分离 (CQS):** API 明确区分改变系统状态的**命令** (Commands) 和需要用户决策的**任务** (Tasks)。
*   **异步任务模型:** 对于所有需要用户思考和决策的交互（如仲裁、变更影响确认），API 采用异步任务模型。系统控制器 (`L1-DP0`) 创建一个“用户任务”，并轮询其状态，从而将系统流程与不确定的用户响应时间解耦。
*   **事件驱动:** `L1-DP8` 接收用户的操作，并将其作为事件通知给 `L1-DP0`，以驱动工作流状态机的转换。

**设计依据:**
*   《公理设计辅助系统 L1 公理设计文档 (V1.1)》 (FR8, DP8)
*   《软件用户需求文档 (URD) V1.6》 (特别是 §3.1, §3.2, §4.3, §7.3)
*   《L1-DP0 工作流状态机定义文档 (V1.1)》

#### **2. API 通用约定**

*   **主机地址 (Base URL):** 本规范不定义具体的主机地址。在实际部署中，应通过服务发现机制或配置文件来提供。所有路径均基于此 Base URL。
*   **API 版本:** API 版本通过 URL 路径进行标识。本规范定义的版本为 `v1`。
    *   示例: `https://<hostname>/api/v1/...`
*   **数据格式:** 所有请求体和响应体均使用 `application/json` 格式，并采用 `UTF-8` 编码。
*   **认证与授权:** 本 API 代表着用户的直接意图，因此**必须**强制执行严格的认证和授权。
    *   **认证方式 (Authentication):** 请求方必须在 HTTP Header 中提供一个代表最终用户的承载秘密信息的 `Authorization` 字段。
        *   **值格式示例:** `Bearer <end_user_jwt_token>`
    *   **身份标识 (Identification):** 请求方必须在 HTTP Header 中提供 `X-System-Component-ID` 字段，其值为调用方组件的标识符（例如 `Web-UI`, `CLI-Tool`）。
*   **错误处理:** API 使用标准的 HTTP 状态码。错误响应体应包含一个标准化的错误对象。

#### **3. 核心概念**

*   **用户任务 (User Task):** 当系统工作流需要用户输入才能继续时（例如，批准文档、进行仲裁），`L1-DP0` 会通过 `L1-DP8` 创建一个“用户任务”。这是一个长生命周期的资源，代表一个待办事项。UI 层应监视这些任务并呈现给用户。
*   **决策 (Decision):** 用户在完成一个“用户任务”时提交的具体选择。它是一个结构化的数据对象，能够被 `L1-DP0` 确定性地解析和处理。

#### **4. 数据模型 (Data Models)**

##### **4.1. UserTask (用户任务)**
代表一个需要用户处理的异步任务。是 `GET /user-tasks/{task_id}` 的核心响应体。

```json
{
  "task_id": "string",
  "task_type": "string",
  "status": "string",
  "prompt": {
    "title": "string",
    "description": "string"
  },
  "context": "object",
  "decision_options": "array",
  "user_decision": {
    "type": "object",
    "optional": true
  },
  "created_at": "string (ISO 8601)",
  "expires_at": "string (ISO 8601)"
}
```
*   `task_type` (enum): `ARBITRATION`, `CHANGE_IMPACT_CONFIRMATION`, `FINAL_APPROVAL`。
*   `status` (enum): `PENDING_USER_ACTION`, `COMPLETED`, `EXPIRED`。
*   `context` (object): 根据 `task_type` 变化，包含决策所需的所有信息。例如，对于 `ARBITRATION`，它会包含文档URI、评审意见摘要等。
*   `decision_options` (array): 向用户展示的可选操作列表。
*   `user_decision` (object, 可选): 用户完成后，此字段将包含其决策。

##### **4.2. Decision (决策)**
`PUT /user-tasks/{task_id}/decision` 的请求体。

```json
{
  "decision_code": "string",
  "payload": {
    "type": "object",
    "optional": true
  }
}
```
*   `decision_code` (string, enum): 用户选择的机器可读的决策代码。例如 `APPROVE_CURRENT`, `RESET_CYCLE`, `CONFIRM_INVALIDATION`。
*   `payload` (object, 可选): 包含与决策相关的额外数据。例如，当 `decision_code` 是 `RESET_CYCLE` 时，`payload` 包含用户输入的新指令。

##### **4.3. Annotation (批注)**
`POST /annotations` 的请求体，用于实现即时反馈 (URD §7.3)。

```json
{
  "document_uri": "string",
  "target_context_snippet": "string",
  "comment": "string",
  "author_id": "string"
}
```
*   `target_context_snippet` (string, 必需): 作为“锚点”的上下文片段，用于鲁棒的定位。

##### **4.4. CommandRequest (命令请求)**
用于发送简单的、同步的流程控制命令。

```json
{
  "command": "string",
  "target_resource_uri": "string"
}
```
*   `command` (string, enum): `START_PROCESS`, `PAUSE_PROCESS`, `RESUME_PROCESS`, `TERMINATE_PROCESS`。

#### **5. 端点定义**

##### **5.1. 流程控制端点 (Process Control Endpoint)**

###### **POST /api/v1/commands**
*   **描述:** 发送一个全局的、同步的流程控制命令，如启动、暂停、恢复或终止一个流程。`L1-DP0` 将监听这些命令并采取行动。
*   **请求体:** `CommandRequest` 对象。
*   **成功响应:** `202 Accepted`。表示命令已被接受，正在处理。
*   **错误响应:** `400 Bad Request`, `404 Not Found` (如 `target_resource_uri` 无效)。

##### **5.2. 异步用户任务管理端点 (User Task Management Endpoints)**

###### **POST /api/v1/user-tasks**
*   **描述:** 由系统内部组件 (`L1-DP0`) 调用，用于创建一个需要用户决策的新任务。
*   **请求体:** 包含 `task_type`, `prompt`, `context`, `decision_options` 等字段的 `UserTask` 初始化对象。
*   **成功响应:**
    *   **状态码:** `201 Created`
    *   **Headers:** `Location: /api/v1/user-tasks/{task_id}`
    *   **响应体:** 创建的完整 `UserTask` 对象，状态为 `PENDING_USER_ACTION`。
*   **错误响应:** `400 Bad Request`。

###### **GET /api/v1/user-tasks**
*   **描述:** 获取当前用户的待办任务列表。UI 层应调用此接口来显示用户的任务清单。
*   **查询参数:** `?status=PENDING_USER_ACTION` (可选, 用于过滤)
*   **成功响应:** `200 OK`，响应体为一个 `UserTask` 对象数组。

###### **GET /api/v1/user-tasks/{task_id}**
*   **描述:** 获取单个用户任务的详细信息。`L1-DP0` 或 UI 层会轮询此端点以监控任务状态。
*   **成功响应:** `200 OK`，响应体为完整的 `UserTask` 对象。
*   **错误响应:** `404 Not Found`。

###### **PUT /api/v1/user-tasks/{task_id}/decision**
*   **描述:** 用户通过 UI 提交对某个任务的决策。这是用户交互的核心写入操作。
*   **请求体:** `Decision` 对象。
*   **成功响应:** `200 OK`，响应体为更新后的 `UserTask` 对象，其状态为 `COMPLETED`。
*   **错误响应:** `400 Bad Request`, `404 Not Found`, `409 Conflict` (如任务已被处理或过期)。

##### **5.3. 即时反馈端点 (Instant Feedback Endpoint)**

###### **POST /api/v1/annotations**
*   **描述:** 用户在查看文档时提交一个即时批注。这是一个独立的、同步的操作，其结果会作为输入提供给下一轮的“撰写员”(L1-DP5)。
*   **请求体:** `Annotation` 对象。
*   **成功响应:** `201 Created`。
*   **错误响应:** `400 Bad Request`, `404 Not Found` (文档URI无法解析)。

#### **6. 示例：用户仲裁流程 (URD §4.3)**

**场景:** `L1-DP6` 评审文档达到最大循环次数，`L1-DP0` 决定暂停流程，请求用户仲裁。

##### **步骤 1: `L1-DP0` 创建用户仲裁任务**
`L1-DP0` 调用 DP8 的 API，为用户创建一个待办任务。
```bash
# L1-DP0 -> L1-DP8
curl -X POST \
  -H "Authorization: Bearer <system_component_token>" \
  -H "X-System-Component-ID: L1-DP0" \
  -H "Content-Type: application/json" \
  -d '{
    "task_type": "ARBITRATION",
    "prompt": {
      "title": "仲裁请求：文档修订陷入僵局",
      "description": "文档 \'AD_L2.md\' 的自动化评审已达到最大次数，但仍有未解决的关键问题。请您决策如何继续。"
    },
    "context": {
      "document_uri": "vcs://project-alpha/docs/AD_L2.md?commit=a1b2c3d4",
      "unresolved_findings_summary": ["CRITICAL: 独立公理违规", "MAJOR: 未能追溯到UR-5.2"]
    },
    "decision_options": [
      {"code": "APPROVE_CURRENT", "label": "强制批准当前版本"},
      {"code": "RESET_CYCLE", "label": "提供新指令并重试", "needs_payload": true},
      {"code": "ABANDON_DOCUMENT", "label": "放弃此文档"}
    ]
  }' \
  'https://<hostname>/api/v1/user-tasks'

# L1-DP8 返回 201 Created 和任务URL
# Location: /api/v1/user-tasks/task-arb-12345
```

##### **步骤 2: UI 层获取并展示任务**
用户的 Web UI 定期调用 `GET /api/v1/user-tasks?status=PENDING_USER_ACTION`，发现了新任务 `task-arb-12345`。它获取任务详情并向用户渲染一个决策界面。

##### **步骤 3: 用户提交决策**
用户选择“提供新指令并重试”，并在文本框中输入了新的指令。UI 将此决策提交。```bash
# Web-UI -> L1-DP8 (代表最终用户)
curl -X PUT \
  -H "Authorization: Bearer <end_user_jwt_token>" \
  -H "X-System-Component-ID: Web-UI" \
  -H "Content-Type: application/json" \
  -d '{
    "decision_code": "RESET_CYCLE",
    "payload": {
      "new_instructions": "重点解决独立公理问题。可以考虑引入一个新的L2-DP来解耦FR2和FR3的功能。"
    }
  }' \
  'https://<hostname>/api/v1/user-tasks/task-arb-12345/decision'

# L1-DP8 返回 200 OK 和更新后的任务
# { "task_id": "task-arb-12345", "status": "COMPLETED", ... }
```

##### **步骤 4: `L1-DP0` 检测到决策并继续工作流**
`L1-DP0` 在其轮询周期中调用 `GET /api/v1/user-tasks/task-arb-12345`，发现 `status` 已变为 `COMPLETED`。它读取 `user_decision` 字段，解析出 `decision_code` 和 `payload`，然后在其状态机中触发向 `DOCUMENT_WRITING` 状态的转换，并将新的指令传递给 `L1-DP5`。

---
Gemini 2.5 Pro 0605 writer

---

## L1-DP0_WorkflowStateMachine_Definition Freezed


---

### **L1-DP0 工作流状态机定义文档 (V1.1)**

**状态:** 批准(Approved)

**版本说明:** 本文档 (V1.1) 是对 V1.0 版本的 **重大修订**。此修订旨在响应并解决《评审意见：关于<L1-DP0 工作流状态机定义文档 (V1.0)>》中指出的根本性设计缺陷。本次修订的核心目标是：通过重构状态转换逻辑，确保 `L1-DP0` 严格遵循《公理设计辅助系统 L1 公理设计文档 (V1.1)》中定义的 **纯粹协调器** 角色，消除原设计中违反独立公理的耦合问题。

#### **1. 引言**

本文档详细定义了“公理设计辅助系统”的 **文档级生命周期状态机**。该状态机是 `L1-DP0 工作流与状态控制器` 的核心逻辑实现，负责管理 **单份文档** 从创建、撰写、审查、批准直至冻结的完整生命周期。

**设计范围澄清：** 此状态机 **不负责** 项目级的流程管理（如决定下一个要撰写的文档是什么，或判断项目何时结束）。它专注于单个文档的流程，并在完成其生命周期（进入 `FROZEN` 状态）或被终止时结束。项目级的控制逻辑由一个更高层的实体（或 `L1-DP0` 的另一个实例）负责，该实体通过触发此状态机的启动来编排整个项目。

设计依据包括：
*   《软件用户需求文档 (URD) V1.6》中定义的核心流程。
*   《公理设计辅助系统 L1 公理设计文档 (V1.1)》中对 `L1-DP0` 作为纯粹协调器的职责定义。
*   《评审意见：关于<L1-DP0 工作流状态机定义文档 (V1.0)>》中的修订指令。

本文档的目标是提供一个无歧义的、职责清晰的、可直接转化为代码实现的状态机模型。

#### **2. 核心状态定义**

以下是系统在 **单份文档** 的生命周期中可能处于的核心状态。

*   **`IDLE` (空闲)**
    *   **定义:** 状态机的初始状态。等待一个外部指令来启动新的文档任务。

*   **`REQUIREMENT_CAPTURE` (需求捕获中)**
    *   **定义:** 针对特定文档（如《用户需求文档》本身），系统正在通过与用户的结构化对话捕获需求。此状态仅在特定文档类型的生命周期中被激活。

*   **`DOCUMENT_WRITING` (文档撰写中)**
    *   **定义:** 系统已接收到撰写或修订指令。`L1-DP5` (内容生成与修订引擎) 正在活动，根据上游输入生成或修订文档草稿。

*   **`DOCUMENT_REVIEWING` (文档审查中)**
    *   **定义:** 一份文档草稿已提交审查。`L1-DP6` (评审与评估引擎) 正在活动，对草稿进行评估并生成审查意见。

*   **`USER_ARBITRATION` (用户仲裁中)**
    *   **定义:** 自动化流程暂停，等待用户通过 `L1-DP8` 进行决策。此状态在发生审查僵局或达到最大审查次数时被触发。

*   **`FROZEN` (已冻结)**
    *   **定义:** **本文档的生命周期终点**。文档已通过所有审查和用户批准，其版本被锁定。进入此状态后，该状态机实例的工作即告完成，并将“任务完成”事件报告给调用方。

*   **`CHANGE_MANAGEMENT` (变更管理中)**
    *   **定义:** 当外部指令请求修改一份已 `FROZEN` 的文档时，可能会启动一个新的状态机实例进入此状态。`L1-DP7` (版本控制与变更服务) 正在执行依赖分析。

*   **`TERMINATED` (已终止)**
    *   **定义:** **本文档的生命周期终点**。文档任务被用户手动放弃或终止。这是一个终结状态。

#### **3. 状态转换图**

以下使用 Mermaid.js 语法描述 **文档级** 核心工作流的状态转换图。

```mermaid
stateDiagram-v2
    direction LR

    [*] --> IDLE

    IDLE --> REQUIREMENT_CAPTURE: 收到启动需求捕获指令
    REQUIREMENT_CAPTURE --> DOCUMENT_WRITING: 需求捕获完成

    IDLE --> DOCUMENT_WRITING: 收到启动文档撰写指令

    state "文档迭代循环" as DocLifecycle {
        direction TB
        DOCUMENT_WRITING --> DOCUMENT_REVIEWING: 提交草稿
        DOCUMENT_REVIEWING --> DOCUMENT_WRITING: 请求修订 (未通过)
        DOCUMENT_REVIEWING --> USER_ARBITRATION: 达到仲裁条件
        USER_ARBITRATION --> DOCUMENT_WRITING: 用户决策: 继续修订
    }

    DOCUMENT_REVIEWING --> FROZEN: 审查通过 & 用户批准
    USER_ARBITRATION --> FROZEN: 用户决策: 批准当前版

    FROZEN --> [*]: 报告任务完成
    USER_ARBITRATION --> TERMINATED: 用户决策: 放弃文档
    TERMINATED --> [*]: 报告任务终止

    IDLE --> CHANGE_MANAGEMENT: 收到启动变更管理指令
    CHANGE_MANAGEMENT --> FROZEN: 用户确认变更

```

#### **4. 状态转换表**

下表详细定义了每个状态转换的触发事件、`L1-DP0` 作为协调器执行的 **指令式调用**，以及最终进入的新状态。所有具体的业务逻辑均被封装在被调用的 DP 内部。

| 当前状态 | 触发事件/条件 | 执行动作 (对其他DP的指令式调用) | 下一个状态 | 备注/URD来源 |
| :--- | :--- | :--- | :--- | :--- |
| `IDLE` | 收到启动“需求捕获”任务的指令 | 调用 `L1-DP8` 启动与用户的结构化对话 | `REQUIREMENT_CAPTURE` | 适用于 URD 本身的生成 |
| `IDLE` | 收到基于上游文档的“撰写新文档”指令 | 调用 `L1-DP5`，指令其启动撰写任务 | `DOCUMENT_WRITING` | 适用于下游文档 |
| `REQUIREMENT_CAPTURE` | 收到来自 `L1-DP8` 的“需求捕获完成”事件 | 调用 `L1-DP5`，指令其基于捕获的需求撰写文档 | `DOCUMENT_WRITING` | URD 2.2 |
| `DOCUMENT_WRITING` | 收到来自 `L1-DP5` 的“草稿完成”事件 | 调用 `L1-DP7` 提交版本，并调用 `L1-DP6` 启动审查 | `DOCUMENT_REVIEWING` | URD 2.3 |
| `DOCUMENT_REVIEWING` | 收到来自 `L1-DP6` 的“请求修订”事件 | 调用 `L1-DP7` 记录意见，并调用 `L1-DP5` 启动修订任务 | `DOCUMENT_WRITING` | URD 2.3 |
| `DOCUMENT_REVIEWING` | 收到来自 `L1-DP6` 的“达到仲裁条件”事件 | 调用 `L1-DP8` 向用户发出仲裁请求 | `USER_ARBITRATION` | URD 4.3 |
| `DOCUMENT_REVIEWING` | 收到来自 `L1-DP6` 的“审查通过”及 `L1-DP8` 的“用户最终批准”事件 | 调用 `L1-DP7` 将文档标记为 "frozen" | `FROZEN` | URD 2.3 |
| `USER_ARBITRATION` | 收到来自 `L1-DP8` 的“用户决策：批准”事件 | 调用 `L1-DP7` 将文档标记为 "frozen" | `FROZEN` | URD 4.3.a, 4.3.b |
| `USER_ARBITRATION` | 收到来自 `L1-DP8` 的“用户决策：重置循环”事件 | 调用 `L1-DP5` 启动新的修订任务 | `DOCUMENT_WRITING` | URD 4.3.d |
| `USER_ARBITRATION` | 收到来自 `L1-DP8` 的“用户决策：放弃文档”事件 | 调用 `L1-DP7` 执行文档任务清理 | `TERMINATED` | URD 4.3.c |
| `IDLE` | 收到针对已冻结文档的“变更请求”指令 | 调用 `L1-DP7` 启动变更管理流程 | `CHANGE_MANAGEMENT` | URD 3.2 |
| `CHANGE_MANAGEMENT`| 收到来自 `L1-DP8` 的“变更确认”事件 | 调用 `L1-DP7` 合并变更并更新文档状态 | `FROZEN` | URD 3.2.5 |

#### **5. 与其他DP的交互**

根据《公理设计辅助系统 L1 公理设计文档 (V1.1)》，`L1-DP0` 是一个 **纯粹的协调器**。它 **不直接调用** `L1-DP1` 至 `L1-DP4` 等数据服务，也 **不执行** 任何具体的业务逻辑（如解析文档、准备上下文）。其唯一职责是根据状态转换逻辑，向 `L1-DP5` 至 `L1-DP8` 等功能引擎和服务发送指令。

*   **调用 L1-DP5 (内容生成与修订引擎):**
    *   在进入 `DOCUMENT_WRITING` 状态时被调用，指令其生成或修订文档。
*   **调用 L1-DP6 (评审与评估引擎):**
    *   在进入 `DOCUMENT_REVIEWING` 状态时被调用，指令其审查文档草稿。
*   **调用 L1-DP7 (版本控制与变更服务):**
    *   在文档提交、批准、放弃或变更时被调用，指令其执行版本控制、状态变更和清理归档等操作。
*   **调用 L1-DP8 (用户交互接口):**
    *   触发事件的主要来源。`L1-DP0` 接收来自 `L1-DP8` 的用户决策和命令。
    *   在需要用户输入时（如仲裁），`L1-DP0` 会调用 `L1-DP8` 来触发相应的用户交互。
*   **与其他DP的关系:** `L1-DP0` **不关心** `L1-DP5` 和 `L1-DP6` 如何获取它们所需的数据（如模板、词汇、知识）。根据L1设计，`L1-DP5` 和 `L1-DP6` 会自行通过其接口从 `L1-DP1`, `DP2`, `DP3`, `DP4` 获取所需数据。`L1-DP0` 的关注点被严格分离。

#### **6. 正交状态处理机制 (Orthogonal State Handling)**

某些系统级状态（如 `PAUSED`, `TERMINATED`）与文档的生命周期状态是正交的，它们可以随时中断主流程。它们不应被视为核心生命周期的一部分，而是一种叠加在主状态机之上的全局控制机制。

*   **`PAUSED` (已暂停)**
    *   **触发:** 任何时候，`L1-DP0` 收到来自 `L1-DP8` 的“暂停”命令。
    *   **机制:** 主状态机控制器将保存其当前状态和上下文 `(State, Context)`，并停止响应除“恢复”和“终止”之外的任何事件。
    *   **恢复:** 收到“恢复”命令后，控制器将加载已保存的状态和上下文，并从中断处继续执行。

*   **`TERMINATED` (已终止 - 项目级)**
    *   **触发:** 任何时候，`L1-DP0` 收到来自 `L1-DP8` 的“终止项目”命令。
    *   **机制:** 这被视为一个最高优先级的事件。`L1-DP0` 将立即停止当前所有活动，并进入一个专用的终止流程。
    *   **执行动作:** 调用 `L1-DP7` 执行项目级的清理和归档，并调用 `L1-DP8` 向用户确认项目已终止。此后，所有相关的状态机实例都将被销毁。

---
Gemini 2.5 Pro 0605 writer

---

## L1-DP1_ProjectTemplate_Schema Freezed


---

### **项目模板 Schema 规范 (V1.2)**

**状态:** 批准 (Approved)

**版本说明:** 本文档 (V1.2) 是对 V1.1 版本的修订。此次修订旨在响应《评审意见：关于<项目模板 Schema 规范 (V1.1)>》中提出的强制性修订指令。核心变更包括：1) 增强了对 `informationAxiom` 中 `metrics` 优先级唯一性约束的描述，以消除不确定性风险；2) 禁止在 `componentSettings` 中使用未在 Schema 中定义的属性，以提高配置的健壮性。

#### **1. 引言**

本文档使用 JSON Schema 格式，详细定义了“项目模板”文件（推荐使用 `.project.json` 作为文件扩展名）的数据结构。项目模板允许用户预设项目的核心参数，从而确保项目在创建时具有一致的基线配置。

V1.2 的核心设计哲学依然是“配置随组件走”。所有配置项均被归类到其所属的系统组件（设计参数 DP）之下，实现了关注点分离，并遵循了公理设计的独立公理原则。所有与本项目模板管理器 (`L1-DP1`) 交互的组件，都应遵循此 Schema 来读取或生成模板文件。

设计依据包括：
*   《公理设计辅助系统 L1 公理设计文档 (V1.1)》中定义的系统架构。
*   《评审意见：关于<项目模板 Schema 规范 (V1.1)>》中的强制性修订指令。
*   《软件用户需求文档 (URD) V1.6》。

#### **2. JSON Schema 定义**

以下是项目模板文件的完整 JSON Schema 定义 (V1.2)。

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Axiomatic Design Assistant Project Template",
  "description": "Defines a modular structure for a project template, mirroring the system's component architecture (DPs). It includes settings for workflow control, content generation, review, and evaluation.",
  "type": "object",
  "required": [
    "templateSchemaVersion",
    "projectName",
    "componentSettings"
  ],
  "properties": {
    "templateSchemaVersion": {
      "description": "The version of this template schema itself. Ensures compatibility.",
      "type": "string",
      "const": "1.2"
    },
    "projectName": {
      "description": "A user-friendly name for the project this template configures.",
      "type": "string",
      "minLength": 1
    },
    "componentSettings": {
      "description": "A container for component-specific settings, mapping directly to the system's Design Parameters (DPs). This structure ensures configuration modularity.",
      "type": "object",
      "properties": {
        "dp0": {
          "description": "Settings for DP0: Workflow & State Controller.",
          "type": "object",
          "properties": {
            "maxReviewCycles": {
              "description": "The maximum number of review-revision cycles before forcing user arbitration. (URD 2.3)",
              "type": "integer",
              "default": 5,
              "minimum": 1
            },
            "maxArbitrationResets": {
              "description": "The maximum number of times a user can reset the review cycle during an arbitration. (URD 4.3.d)",
              "type": "integer",
              "default": 2,
              "minimum": 0
            }
          },
          "required": ["maxReviewCycles", "maxArbitrationResets"]
        },
        "dp5": {
          "description": "Settings for DP5: Content Generation & Revision Engine.",
          "type": "object",
          "properties": {
            "llmConfig": {
              "description": "Configuration for the LLM used by the Writer role in this component.",
              "type": "object",
              "properties": {
                "modelId": { "type": "string", "description": "Identifier for the LLM model." },
                "behavioralStyle": { "type": "string", "description": "A detailed prompt describing the desired writing style and personality." }
              },
              "required": ["modelId", "behavioralStyle"]
            }
          },
          "required": ["llmConfig"]
        },
        "dp6": {
          "description": "Settings for DP6: Review & Assessment Engine.",
          "type": "object",
          "properties": {
            "llmConfig": {
              "description": "Configuration for the LLM used by the Reviewer role in this component.",
              "type": "object",
              "properties": {
                "modelId": { "type": "string", "description": "Identifier for the LLM model." },
                "behavioralStyle": { "type": "string", "description": "A detailed prompt describing the desired reviewing style and critical perspective." }
              },
              "required": ["modelId", "behavioralStyle"]
            },
            "reviewChecklist": {
              "description": "A list of standard checks for the Reviewer. Items are natural language instructions. Items enclosed in `[...]` are special directives that may be parsed by dedicated logic within DP6.",
              "type": "array",
              "items": { "type": "string" }
            },
            "documentStructure": {
                "description": "Defines structural rules or templates for documents. (Placeholder for future expansion)",
                "type": "object",
                "properties": {}
            },
            "informationAxiom": {
              "description": "Defines quantitative metrics and decision strategy for applying the Information Axiom. (URD 6.4)",
              "type": "object",
              "properties": {
                "metrics": {
                  "description": "A list of metrics used to evaluate design alternatives.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "metricId": { "type": "string", "description": "A unique, machine-friendly identifier for the metric (e.g., 'interfaceComplexity')." },
                      "name": { "type": "string", "description": "A human-readable name for the metric (e.g., '接口复杂度')." },
                      "computableDefinition": { "type": "string", "description": "The precise, computable definition of the metric as required by URD 6.4." },
                      "priority": {
                        "description": "关键约束：此优先级在数组内必须唯一。当前 Schema 无法在语法层面强制此约束，依赖于模板创建者和审查工具来保证。重复的优先级将导致系统在决策时产生不确定的、不可靠的行为。",
                        "type": "integer"
                       }
                    },
                    "required": ["metricId", "name", "computableDefinition", "priority"]
                  }
                },
                "decisionStrategy": {
                  "description": "The strategy to use when comparing designs based on the metrics.",
                  "type": "string",
                  "enum": ["priority"],
                  "default": "priority"
                }
              },
              "required": ["metrics", "decisionStrategy"]
            }
          },
          "required": ["llmConfig", "reviewChecklist", "informationAxiom"]
        }
      },
      "additionalProperties": false
    }
  }
}
```

#### **3. 关键字段说明**

*   **`templateSchemaVersion` (string, 必需):** 模式版本。用于确保模板文件的兼容性。本文档定义的版本为 "1.2"。
*   **`projectName` (string, 必需):** 项目名称。用于在用户界面中识别模板。
*   **`componentSettings` (object, 必需):** **核心结构**。这是一个容器，其下的每个键都直接对应一个需要配置的 L1 设计参数（DP）。这种结构将配置项与其所属的组件绑定，确保了配置的模块化和解耦。**V1.2 更新：** 此对象不再接受任何未在 `properties` 中明确定义的键（如`"dp0"`, `"dp5"`, `"dp6"`），以防止因拼写错误等导致的配置静默失败。
    *   **`dp0` (object):** `DP0: 工作流与状态控制器` 的专属配置。
        *   `maxReviewCycles`: 定义了在强制进入“用户仲裁”前，系统自动执行“审查-修订”循环的最大次数。
        *   `maxArbitrationResets`: 定义了在单次用户仲裁中，用户可以重置审查循环的最大次数。
    *   **`dp5` (object):** `DP5: 内容生成与修订引擎` 的专属配置。
        *   `llmConfig`: 定义了“撰写员”角色的LLM模型和行为风格。
    *   **`dp6` (object):** `DP6: 评审与评估引擎` 的专属配置。
        *   `llmConfig`: 定义了“审查员”角色的LLM模型和行为风格。
        *   `reviewChecklist`: 审查员必须遵循的审查清单。
        *   `documentStructure`: 用于定义文档结构规则的占位符。
        *   `informationAxiom`: 应用信息公理的完整框架。**V1.2 更新：** 其 `metrics` 数组中 `priority` 字段的描述已更新，明确强调其唯一性是保证系统决策确定性的关键，并警示了当前 Schema 的局限性。

#### **4. 示例 (`example.project.json`)**

以下是一个符合 V1.2 Schema 规范的完整项目模板文件示例。

```json
{
  "templateSchemaVersion": "1.2",
  "projectName": "Default Engineering Design Template (Modular & Robust)",
  "componentSettings": {
    "dp0": {
      "maxReviewCycles": 5,
      "maxArbitrationResets": 2
    },
    "dp5": {
      "llmConfig": {
        "modelId": "gemini-1.5-pro-latest",
        "behavioralStyle": "You are a meticulous and clear-thinking system architect. Your writing is precise, unambiguous, and always follows the provided upstream documents and constraints. You prioritize creating decoupled designs."
      }
    },
    "dp6": {
      "llmConfig": {
        "modelId": "gemini-1.5-pro-latest",
        "behavioralStyle": "You are a critical and detail-oriented senior reviewer. Your goal is to rigorously challenge the design to find flaws, inconsistencies, and violations of Axiomatic Design principles. Your feedback must be specific, actionable, and reference the checklist."
      },
      "reviewChecklist": [
        "Verify all Functional Requirements (FRs) are addressed.",
        "[TraceabilityCheck] Ensure every L2 FR traces back to the parent L1 FR.",
        "[Axiom1-Check] Analyze the design matrix for any off-diagonal elements and challenge their necessity.",
        "Check for consistency with the project's Lexicon & Constraints file.",
        "Evaluate the clarity and unambiguity of the language used."
      ],
      "documentStructure": {},
      "informationAxiom": {
        "metrics": [
          {
            "metricId": "componentCount",
            "name": "组件数量",
            "computableDefinition": "Count the total number of new Design Parameters (DPs) introduced at the current design level.",
            "priority": 1
          },
          {
            "metricId": "interfaceComplexity",
            "name": "接口复杂度",
            "computableDefinition": "Sum the total number of parameters across all methods for all newly defined component interfaces.",
            "priority": 2
          },
          {
            "metricId": "externalDependencies",
            "name": "外部依赖数量",
            "computableDefinition": "Count the number of new external libraries or services introduced that are not defined within the project's knowledge base.",
            "priority": 3
          }
        ],
        "decisionStrategy": "priority"
      }
    }
  }
}
```

---
Gemini 2.5 Pro 0605 writer

---

## L1-DP1_TemplateService_API_Specification Freezed

好的，我已收到并深入理解了《评审意见：关于<L1-DP1 模板服务 API 接口规范 (V1.2)>》中下达的全部强制性修订指令。

本次修订旨在解决评审意见中指出的系统性设计缺陷，包括：API 能力与 L1 设计职责的根本性矛盾、数据完整性契约的缺失、服务韧性的不足，以及数据模型信息含量的欠缺。我将严格遵循指令，对 V1.2 规范进行全面重构和增强。

以下是根据上述修订指令完成的《L1-DP1 模板服务 API 接口规范》V1.3 版本。

---

### **L1-DP1 模板服务 API 接口规范 (V1.3)**

**状态:** **已批准 (Approved)**

**版本说明:** 本文档 (V1.3) 是对 V1.2 版本的重大修订。它依据《关于<L1-DP1 模板服务 API 接口规范 (V1.2)>的评审意见与强制性修订指令》（日期：2024-06-07）进行了强制性修订。核心变更包括：
1.  **扩展 API 能力：** 新增 `POST`、`PUT`、`DELETE` 端点，以完全匹配 L1 设计文档中为 `DP1` 定义的 CRUD (创建、读取、更新、删除) 职责，解决了 API 能力与系统架构职责不一致的根本性矛盾。
2.  **强化数据完整性：** 在服务端强制执行关键业务规则验证（如 `informationAxiom.metrics` 中 `priority` 的唯一性），并扩展了 `409 Conflict` 错误以报告语义验证失败，将数据契约的守护责任落实到服务端。
3.  **增强服务韧性：** 明确了列表端点 (`GET /templates`) 在遇到部分无效模板文件时的行为，确保其跳过无效文件并返回所有有效模板的列表，从而提升了服务的健壮性。
4.  **丰富数据模型：** 在 `TemplateSummary` 模型中增加了 `templateSchemaVersion` 字段，以优化客户端的模板发现与筛选能力，避免了潜在的 N+1 查询问题。

#### **1. 引言**

本文档详细定义了 `L1-DP1: 项目模板管理器` 对外提供服务的应用程序编程接口（API）。此 API 的核心职责是为系统提供一个管理项目模板的标准化接口，支持模板的创建、读取、更新和删除（CRUD）操作。

本规范遵循公理设计原则，确保 `L1-DP1` 作为一个独立的服务，通过稳定的接口与其他设计参数（DPs）进行解耦的交互。所有调用方应遵循此规范来与模板服务进行通信。本规范的设计与《公理设计辅助系统 L1 公理设计文档 (V1.1)》中对 `DP1` 的职责定义完全保持一致。

**设计依据:**
*   《公理设计辅助系统 L1 公理设计文档 (V1.1)》
*   《项目模板 Schema 规范 (V1.2)》
*   《软件用户需求文档 (URD) V1.6》
*   《关于<L1-DP1 模板服务 API 接口规范 (V1.2)>的评审意见与强制性修订指令》

#### **2. API 通用约定**

*   **主机地址 (Base URL):** 本规范不定义具体的主机地址。在实际部署中，应通过服务发现机制或配置文件来提供。所有路径均基于此 Base URL。
*   **API 版本:** API 版本通过 URL 路径进行标识。本规范定义的版本为 `v1`。
    *   示例: `https://<hostname>/api/v1/...`
*   **数据格式:** 所有请求体（`Request Body`）和响应体（`Response Body`）均使用 `application/json` 格式，并采用 `UTF-8` 编码。
*   **认证与授权:** 本 API 要求所有请求**必须**同时包含**身份标识**和**认证凭据**。
    *   **认证方式 (Authentication):** 请求方必须在 HTTP Header 中提供一个承载秘密信息的 `Authorization` 字段。
        *   **HTTP Header:** `Authorization`
        *   **值格式:** `Bearer <token>` 或 `ApiKey <key>`。
    *   **身份标识 (Identification):** 请求方必须在 HTTP Header 中提供 `X-System-Component-ID` 字段，其值为调用方组件的标识符（例如 `L1-DP5`）。
    *   **授权逻辑 (Authorization):** 服务实现层应包含一个可配置的访问控制列表（ACL）。读取操作（`GET`）通常允许更广泛的组件访问，而写入操作（`POST`, `PUT`, `DELETE`）的权限应被严格限制，通常仅限于系统管理组件或特定的用户界面代理。
*   **错误处理:** API 使用标准的 HTTP 状态码。错误响应体应包含一个标准化的错误对象。

##### **2.1. 模板标识符 (`template_name`) 规范**

`template_name` 是项目模板的唯一标识符，通常作为其物理文件名（不含扩展名）。它必须遵循 URL-safe 字符集（例如 `[a-zA-Z0-9_-]`），且在模板库中必须唯一。

#### **3. 数据模型 (Data Models)**

##### **3.1. Template (模板)**

完整的模板数据结构由《项目模板 Schema 规范 (V1.2)》定义。本 API 接收和返回的模板对象 **必须** 严格遵循该 Schema。

##### **3.2. Error (错误响应)**

```json
{
  "error": {
    "code": "string",
    "message": "string",
    "details": "string (optional)"
  }
}
```

*   `code` (string): 机器可读的错误代码（例如：`TEMPLATE_NOT_FOUND`, `TEMPLATE_SEMANTIC_VALIDATION_FAILED`）。
*   `message` (string): 人类可读的错误信息。
*   `details` (string, 可选): 详细技术信息。

##### **3.3. TemplateSummary (模板摘要)**

用于在列表中展示模板的核心信息。

```json
{
  "template_name": "string",
  "projectName": "string",
  "templateSchemaVersion": "string"
}
```

*   `template_name` (string): 模板的唯一标识符。
*   `projectName` (string): 模板中定义的、对用户友好的项目名称。
*   `templateSchemaVersion` (string): 该模板文件所遵循的 Schema 版本号。

#### **4. 端点定义 (Endpoint Definitions)**

##### **4.1. 读取操作 (Read Operations)**

###### **GET /api/v1/templates**
*   **描述:** 返回一个包含所有可用且有效的模板摘要信息的数组。此端点将返回所有有效且可访问模板的摘要列表。存储库中任何格式错误、不符合 Schema 或违反业务规则的模板文件将被忽略，并在服务端记录错误，但不会导致此 API 调用失败。
*   **成功响应:**
    *   **状态码:** `200 OK`
    *   **响应体:** 一个 `TemplateSummary` 对象的 JSON 数组。若无可用模板，则返回空数组 `[]`。
        ```json
        [
          {
            "template_name": "default-engineering-v1-2",
            "projectName": "Default Engineering Design Template (Modular & Robust)",
            "templateSchemaVersion": "1.2"
          },
          {
            "template_name": "ur-capture-template-v1-0",
            "projectName": "User Requirement Capture Template",
            "templateSchemaVersion": "1.1"
          }
        ]
        ```
*   **错误响应:** `401 Unauthorized`, `403 Forbidden`, `500 Internal Server Error` (仅当发生无法访问模板库等致命错误时)。

###### **GET /api/v1/templates/{template_name}**
*   **描述:** 根据模板名称检索完整的项目模板。在返回前，服务器**必须**对模板内容进行完整的语法和语义验证。
*   **路径参数:** `template_name` (string, 必需)。
*   **成功响应:**
    *   **状态码:** `200 OK`
    *   **响应体:** 符合《项目模板 Schema 规范 (V1.2)》的完整 JSON 对象。
*   **错误响应:**
    *   `401 Unauthorized`, `403 Forbidden`, `404 Not Found`。
    *   **状态码:** `409 Conflict`
        *   **描述:** 当模板文件存在但其内容未能通过验证时返回。这包括 JSON Schema 语法验证失败和业务规则（语义）验证失败。
        *   **响应体示例 (语义验证失败):**
            ```json
            {
              "error": {
                "code": "TEMPLATE_SEMANTIC_VALIDATION_FAILED",
                "message": "The template violates a semantic business rule.",
                "details": "Validation failed: 'informationAxiom.metrics' contains duplicate 'priority' values."
              }
            }
            ```
    *   `500 Internal Server Error`。

##### **4.2. 写入操作 (Write Operations)**

###### **POST /api/v1/templates**
*   **描述:** 创建一个新的项目模板。请求体中 `projectName` 会被用作生成唯一的、URL-safe 的 `template_name`。
*   **请求体:** 一个符合《项目模板 Schema 规范 (V1.2)》的完整 JSON 对象。
*   **成功响应:**
    *   **状态码:** `201 Created`
    *   **Headers:** `Location: /api/v1/templates/{generated_template_name}`
    *   **响应体:** 包含新创建模板摘要的 `TemplateSummary` 对象。
*   **错误响应:**
    *   `400 Bad Request`: 请求体为空或非法的 JSON 格式。
    *   `401 Unauthorized`, `403 Forbidden`。
    *   `409 Conflict`:
        *   如果根据 `projectName` 生成的 `template_name` 已存在。
        *   如果请求体中的模板内容未能通过语法或语义验证（同 `GET`）。
    *   `500 Internal Server Error`。

###### **PUT /api/v1/templates/{template_name}**
*   **描述:** 创建或完整替换一个指定名称的项目模板。这是一个幂等操作。
*   **路径参数:** `template_name` (string, 必需)。
*   **请求体:** 一个符合《项目模板 Schema 规范 (V1.2)》的完整 JSON 对象。
*   **成功响应:**
    *   **状态码:** `200 OK` (替换现有模板) 或 `201 Created` (创建新模板)。
    *   **响应体:** 包含模板摘要的 `TemplateSummary` 对象。
*   **错误响应:**
    *   `400 Bad Request`, `401 Unauthorized`, `403 Forbidden`。
    *   `409 Conflict`: 如果请求体中的模板内容未能通过语法或语义验证（同 `GET`）。
    *   `500 Internal Server Error`。

###### **DELETE /api/v1/templates/{template_name}**
*   **描述:** 删除一个指定的项目模板。
*   **路径参数:** `template_name` (string, 必需)。
*   **成功响应:**
    *   **状态码:** `204 No Content`
*   **错误响应:**
    *   `401 Unauthorized`, `403 Forbidden`, `404 Not Found`。
    *   `500 Internal Server Error`。

#### **5. 示例：调用流程与cURL**

**场景1: `L1-DP5` 获取模板配置**
```bash
# L1-DP5 (内容生成引擎) 请求获取模板 'default-engineering-v1-2' 的配置
# -H "Authorization" 用于安全认证
# -H "X-System-Component-ID" 用于身份标识
curl -X GET \
  -H "Authorization: Bearer <component_token>" \
  -H "X-System-Component-ID: L1-DP5" \
  'https://<hostname>/api/v1/templates/default-engineering-v1-2'

# 成功时返回 200 OK 和完整的模板 JSON
```

**场景2: 管理员创建一个新模板**
```bash
# 管理员通过UI代理组件创建一个新模板
# 注意：template_name 不在URL中，将由服务器根据 projectName 生成
curl -X POST \
  -H "Authorization: Bearer <admin_user_token>" \
  -H "X-System-Component-ID: Admin-UI-Proxy" \
  -H "Content-Type: application/json" \
  -d '{
    "templateSchemaVersion": "1.2",
    "projectName": "New Custom Robotics Template",
    "componentSettings": { ... }
  }' \
  'https://<hostname>/api/v1/templates'

# 成功时返回 201 Created，Location header 指向新资源，响应体包含摘要
# Location: /api/v1/templates/new-custom-robotics-template
# Body:
# {
#   "template_name": "new-custom-robotics-template",
#   "projectName": "New Custom Robotics Template",
#   "templateSchemaVersion": "1.2"
# }
```

**场景3: 管理员删除一个模板**
```bash
# 管理员删除一个过时的模板
curl -X DELETE \
  -H "Authorization: Bearer <admin_user_token>" \
  -H "X-System-Component-ID: Admin-UI-Proxy" \
  'https://<hostname>/api/v1/templates/old-template-v1'

# 成功时返回 204 No Content
```

---
Gemini 2.5 Pro 0605 writer

---

## L1-DP2_LexiconConstraints_Schema Freezed

好的，我已收到并完全理解了《评审意见：关于<项目词汇与约束文件 Schema 规范 (V1.1)>》中下达的强制性修订指令。

我将依据评审意见中列出的所有核心修订指令，对 V1.1 版本进行根本性重构。本次修订旨在解决评审指出的所有设计缺陷，特别是通过为规则引入唯一的、机器可解析的标识符来消除应用规则时的模糊性，修正示例中的正则表达式转义错误，并明确相关转换工具的规范责任。

以下是根据上述指令完成的《项目词汇与约束文件 Schema 规范》的修订版本。

---

### **项目词汇与约束文件 Schema 规范 (V1.2)**

**状态:** 已批准(approved)

**版本说明:** 本文档 (V1.2) 是对 V1.1 版本的重大修订，旨在解决《评审意见：关于<项目词汇与约束文件 Schema 规范 (V1.1)>》中指出的致命设计缺陷。核心变更包括：
1.  **消除规则应用模糊性 (指令1):** 重构了 `namingConventions` 和 `formattingConstraints` 的数据结构。原先作为模糊字符串的 `target` 和 `dataType` 字段，现已变更为包含唯一、机器可解析 `id` 的对象。这使得自动化系统（如 `DP1`, `DP5`, `DP6`）能够以程序化的、确定性的方式将规则与项目模板中定义的特定工件类型或数据类型关联起来，从而可靠地应用约束。
2.  **修正正则表达式错误 (指令2):** 修正了示例文件中所有正则表达式的JSON字符串转义问题。所有反斜杠均已进行双重转义，以确保跨平台的正确解析和执行。
3.  **明确规范责任 (指令3):** 在引言部分明确指出，任何用于将其他格式（如 Markdown）转换为此标准 JSON 格式的工具，其本身及其源格式都必须有独立的规范文档，这是 `L1-DP2` 组件的下游设计责任。

#### **1. 引言**

本文档使用 JSON Schema 格式，详细定义了“项目词汇与约束”文件的数据结构。该文件是项目的“知识范式 (Canon)”，是确保整个项目范围内术语、命名和格式高度一致性的基础。根据 URD 5.3 的规定，此文件中的定义拥有最高知识优先级，将覆盖所有其他知识源（如外部知识库）的冲突信息。

`L1-DP2: 项目词汇服务` 负责加载、解析、验证并提供对此文件内容的查询服务。所有需要确保一致性的组件（如 `L1-DP5` 内容生成引擎, `L1-DP6` 评审与评估引擎）都将通过 `L1-DP2` 的 API 来访问这些规则。

本文档定义的是该文件的 canonical (标准) JSON 结构。**根据指令3，任何用于将用户更易于维护的格式（如 Markdown）转换为此标准 JSON 格式的工具，其本身和它所解析的源格式都必须拥有其独立的规范文档。该规范的制定与实现是 `L1-DP2: 项目词汇服务` 的下游设计责任，以确保整个信息链条的有据可查和可预测性。**

**设计依据:**
*   《软件用户需求文档 (URD) V1.6》§5.2, §5.3
*   《公理设计辅助系统 L1 公理设计文档 (V1.1)》
*   《评审意见：关于<项目词汇与约束文件 Schema 规范 (V1.1)>》

#### **2. JSON Schema 定义**

以下是“项目词汇与约束”文件 (推荐使用 `.lexicon.json` 作为文件扩展名) 的完整 JSON Schema 定义。

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Project Lexicon and Constraints File Schema",
  "description": "Defines the structure for a project's canonical lexicon, including glossary, acronyms, naming conventions, and formatting constraints. This file serves as the single source of truth for project-specific terminology and rules, as per URD 5.2 and URD 5.3.",
  "type": "object",
  "required": [
    "schemaVersion",
    "lexicon"
  ],
  "additionalProperties": false,
  "properties": {
    "schemaVersion": {
      "description": "The version of this schema. Ensures compatibility and proper parsing.",
      "type": "string",
      "const": "1.2"
    },
    "lexicon": {
      "description": "The container for all lexicon and constraint definitions.",
      "type": "object",
      "properties": {
        "glossary": {
          "description": "A map of core project terms to their official definitions. The keys of this object are the terms themselves, ensuring uniqueness.",
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "properties": {
              "definition": {
                "description": "The unambiguous, official definition of the term.",
                "type": "string"
              },
              "aliases": {
                "description": "An optional list of synonyms or alternative phrases for the term.",
                "type": "array",
                "items": { "type": "string" }
              }
            },
            "required": ["definition"]
          }
        },
        "acronyms": {
          "description": "A map of all official project acronyms to their expansions. The keys of this object are the acronyms themselves, ensuring uniqueness.",
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "properties": {
              "expansion": {
                "description": "The fully expanded phrase (e.g., 'User Requirements Document').",
                "type": "string"
              }
            },
            "required": ["expansion"]
          }
        },
        "namingConventions": {
          "description": "A set of enforceable naming rules for various project artifacts. Each rule is linked to an artifact type via a unique ID.",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "target": {
                "description": "The artifact type this rule applies to, identified by a unique, machine-readable ID.",
                "type": "object",
                "properties": {
                  "id": {
                    "description": "A unique, machine-readable identifier for the artifact type (e.g., 'ARTIFACT_TYPE_IF_SPEC'). This ID is intended to be referenced in project templates.",
                    "type": "string"
                  },
                  "description": {
                    "description": "A human-readable description of the artifact type (e.g., 'Interface Specification Document').",
                    "type": "string"
                  }
                },
                "required": ["id", "description"]
              },
              "pattern": {
                "description": "A regular expression (regex) that valid names for the target artifact must match.",
                "type": "string",
                "format": "regex"
              },
              "description": {
                "description": "A user-friendly explanation of the naming rule itself.",
                "type": "string"
              }
            },
            "required": ["target", "pattern", "description"]
          }
        },
        "formattingConstraints": {
          "description": "A set of enforceable formatting rules for specific data types. Each rule is linked to a data type via a unique ID.",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "dataType": {
                "description": "The data type this rule applies to, identified by a unique, machine-readable ID.",
                "type": "object",
                "properties": {
                  "id": {
                    "description": "A unique, machine-readable identifier for the data type (e.g., 'DATA_TYPE_SEMVER'). This ID is intended to be referenced in document templates or schemas.",
                    "type": "string"
                  },
                  "description": {
                    "description": "A human-readable description of the data type (e.g., 'Semantic Version String').",
                    "type": "string"
                  }
                },
                "required": ["id", "description"]
              },
              "pattern": {
                "description": "A regular expression (regex) that valid data of this type must match.",
                "type": "string",
                "format": "regex"
              },
              "description": {
                "description": "A user-friendly explanation of the formatting rule itself.",
                "type": "string"
              }
            },
            "required": ["dataType", "pattern", "description"]
          }
        }
      },
      "additionalProperties": false
    }
  }
}
```

#### **3. 关键字段说明**

*   **`schemaVersion` (string, 必需):** Schema 版本号。本文档定义的版本为 "1.2"。
*   **`lexicon` (object, 必需):** 包含所有定义的核心对象。
    *   **`glossary` (object):** 术语表，保持“对象即映射”结构。
    *   **`acronyms` (object):** 缩写词表，保持“对象即映射”结构。
    *   **`namingConventions` (array):** **(V1.2 修订)** 命名约定。用于强制执行文档、组件等的命名规则。
        *   `target` (object, 必需): 规则应用的目标工件，包含：
            *   `id` (string, 必需): 机器可解析的**唯一ID**，用于在项目模板中引用，从而实现规则的确定性应用。
            *   `description` (string, 必需): 对工件类型的人类可读描述。
        *   `pattern` (string, 必需): 用于验证名称的**正则表达式**。
        *   `description` (string, 必需): 对规则本身的人类可读描述。
    *   **`formattingConstraints` (array):** **(V1.2 修订)** 格式化约束。用于强制执行特定数据的格式。
        *   `dataType` (object, 必需): 规则应用的数据类型，包含：
            *   `id` (string, 必需): 机器可解析的**唯一ID**，用于在文档模板或其他Schema中引用，从而实现格式的确定性验证。
            *   `description` (string, 必需): 对数据类型的人类可读描述。
        *   `pattern` (string, 必需): 用于验证格式的**正则表达式**。
        *   `description` (string, 必需): 对格式规则本身的人类可读描述。

#### **4. 示例 (`example.lexicon.json`)**

以下是一个符合 V1.2 Schema 规范的完整“项目词汇与约束”文件示例。该示例已根据评审意见修正了正则表达式的转义问题。

```json
{
  "schemaVersion": "1.2",
  "lexicon": {
    "glossary": {
      "Design Matrix": {
        "definition": "A matrix that maps Functional Requirements (FRs) to Design Parameters (DPs) to visualize and analyze the relationships between them.",
        "aliases": [
          "FR-DP Matrix"
        ]
      },
      "Frozen Document": {
        "definition": "A document that has been approved by both the Reviewer and the User, and is now locked as a baseline for subsequent work. Changes require a formal Change Management process."
      }
    },
    "acronyms": {
      "URD": {
        "expansion": "User Requirements Document"
      },
      "DP": {
        "expansion": "Design Parameter"
      },
      "FR": {
        "expansion": "Functional Requirement"
      }
    },
    "namingConventions": [
      {
        "target": {
          "id": "ARTIFACT_TYPE_IF_SPEC_DOC",
          "description": "Interface Specification Document"
        },
        "pattern": "^IF_([A-Z0-9]+_)*[A-Z0-9]+\\.md$",
        "description": "Interface specification documents must start with 'IF_' and end with '.md'. Example: 'IF_L1_DP2_API_Spec.md'"
      },
      {
        "target": {
          "id": "ARTIFACT_TYPE_AD_L2_DOC",
          "description": "L2 Design Document"
        },
        "pattern": "^AD_L2_[A-Za-z0-9_]+\\.md$",
        "description": "Level 2 Axiomatic Design documents must start with 'AD_L2_'. Example: 'AD_L2_Content_Engine.md'"
      }
    ],
    "formattingConstraints": [
      {
        "dataType": {
          "id": "DATA_TYPE_ISO_DATE",
          "description": "Date"
        },
        "pattern": "^\\\\d{4}-\\\\d{2}-\\\\d{2}$",
        "description": "All dates must be in YYYY-MM-DD format."
      },
      {
        "dataType": {
          "id": "DATA_TYPE_SEMVER",
          "description": "Semantic Version"
        },
        "pattern": "^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)$",
        "description": "Version numbers must follow semantic versioning (e.g., 1.2.0)."
      }
    ]
  }
}
```

---
Gemini 2.5 Pro 0605 writer

---

## L1-DP2_LexiconService_API_Specification Freezed

好的，遵照指示。

我已收到并仔细研究了《评审意见：关于<L1-DP2 词汇服务 API 接口规范 (V1.1)>》。评审结论为“驳回，需强制性修订”。

我将严格依据评审意见中列出的强制性修订指令和建议性修订意见，对该 API 规范进行修订，以解决其与系统内其他核心服务接口行为不一致的关键问题，并提升规范的精确性。本次修订的核心目标是：统一写入操作的成功响应模式，并明确认证细节，以确保系统级的一致性和减少客户端的实现模糊性。

以下是根据上述评审意见修订后的完整文档。

---

### **L1-DP2 词汇服务 API 接口规范 (V1.2)**

**状态:** 已批准(Approved)

**版本说明:** 本文档 (V1.2) 是对 V1.1 版本的修订，旨在响应并解决《评审意见：关于<L1-DP2 词汇服务 API 接口规范 (V1.1)>》中指出的设计缺陷。核心变更包括：
1.  **统一 `PUT` 操作的成功响应模式 (指令1):** 重构了 `PUT /api/v1/lexicon` 端点的成功响应逻辑。为解决与 `L1-DP1` 模板服务 API 的行为不一致问题，对于资源更新操作，状态码已从 `204 No Content` 更改为 `200 OK`，并且响应体**必须**返回一个 `LexiconSummary` 对象。这确保了系统内核心服务接口行为的一致性，并为客户端提供了更新后的资源元数据，避免了额外查询。
2.  **明确认证头格式 (建议1):** 在“API 通用约定”中增加了 `Authorization` 头的格式示例，消除了客户端实现的模糊性，与系统内其他高质量 API 规范保持一致。

#### **1. 引言**

本文档详细定义了 `L1-DP2: 项目词汇服务` 对外提供服务的应用程序编程接口（API）。此 API 的核心职责是为系统提供一个管理和查询“项目词汇与约束”文件的标准化接口。根据 L1 设计，该服务是确保全项目术语、命名和格式一致性的唯一权威来源。

本规范将 API 分为两类：
1.  **管理接口:** 提供对整个词汇文件进行创建、替换和删除（CRUD）的能力，主要供管理工具或授权用户界面使用。
2.  **查询接口:** 提供高效、细粒度的查询能力，供其他系统组件（如 `L1-DP4`, `L1-DP5`, `L1-DP6`）在执行任务时按需获取特定规则或定义。该类接口包含一个批量查询端点，以避免 N+1 查询问题。

**设计依据:**
*   《公理设计辅助系统 L1 公理设计文档 (V1.1)》
*   《项目词汇与约束文件 Schema 规范 (V1.2)》
*   《软件用户需求文档 (V1.6)》
*   《评审意见：关于<L1-DP2 词汇服务 API 接口规范 (V1.1)>》

#### **2. API 通用约定**

*   **主机地址 (Base URL):** 本规范不定义具体的主机地址。在实际部署中，应通过服务发现机制或配置文件来提供。所有路径均基于此 Base URL。
*   **API 版本:** API 版本通过 URL 路径进行标识。本规范定义的版本为 `v1`。
    *   示例: `https://<hostname>/api/v1/...`
*   **数据格式:** 所有请求体（`Request Body`）和响应体（`Response Body`）均使用 `application/json` 格式，并采用 `UTF-8` 编码。
*   **认证与授权:** 本 API 要求所有请求**必须**同时包含**身份标识**和**认证凭据**。
    *   **认证方式 (Authentication):** 请求方必须在 HTTP Header 中提供一个承载秘密信息的 `Authorization` 字段。
        *   **值格式示例:** `Bearer <token>`
    *   **身份标识 (Identification):** 请求方必须在 HTTP Header 中提供 `X-System-Component-ID` 字段，其值为调用方组件的标识符（例如 `L1-DP6`）。
    *   **授权逻辑 (Authorization):** 服务实现层应包含一个可配置的访问控制列表（ACL）。查询操作（`GET`, `POST /query`）通常允许更广泛的组件访问，而写入操作（`PUT`, `DELETE`）的权限应被严格限制。
*   **错误处理:** API 使用标准的 HTTP 状态码。错误响应体应包含一个标准化的错误对象。

##### **2.1. 资源范围与部署假设 (Resource Scope & Deployment Assumption)**

本服务被设计为单租户模式，每个服务实例仅管理一个项目的词汇与约束文件。因此，词汇被建模为作用于根路径 `/lexicon` 的单例资源 (Singleton Resource)。在需要支持多个项目的环境中，应为每个项目部署独立的服务实例。此设计决策旨在简化 API 接口，并将多租户的复杂性交由更高层次的部署架构处理，从而确保本服务职责的单一性。

#### **3. 数据模型 (Data Models)**

##### **3.1. Lexicon (词汇与约束)**

完整的词汇数据结构由《项目词汇与约束文件 Schema 规范 (V1.2)》定义。管理接口接收和返回的词汇对象 **必须** 严格遵循该 Schema。

##### **3.2. Error (错误响应)**

```json
{
  "error": {
    "code": "string",
    "message": "string",
    "details": "string (optional)"
  }
}
```
*   `code` (string): 机器可读的错误代码（例如：`LEXICON_NOT_FOUND`, `SCHEMA_VALIDATION_FAILED`）。
*   `message` (string): 人类可读的错误信息。
*   `details` (string, 可选): 详细技术信息。

##### **3.3. BatchQueryResponse (批量查询响应)**

用于 `POST /lexicon/query` 端点的响应。它返回一个包含所有找到的条目的结构化对象。其结构保持不变。

##### **3.4. LexiconSummary (词汇摘要)**

用于在创建或更新操作成功后返回的轻量级响应体。

```json
{
  "schemaVersion": "string",
  "lastModified": "string"
}
```
*   `schemaVersion` (string): 被创建或更新的词汇文件所遵循的 Schema 版本号，例如 "1.2"。
*   `lastModified` (string): 资源最后被修改的时间戳，采用 ISO 8601 格式 (例如 `2024-06-08T10:00:00Z`)。

#### **4. 管理接口定义 (Management Endpoints)**

##### **GET /api/v1/lexicon**
*   **描述:** 检索完整的项目词汇与约束文件。
*   **成功响应:**
    *   **状态码:** `200 OK`
    *   **响应体:** 符合《项目词汇与约束文件 Schema 规范 (V1.2)》的完整 JSON 对象。
*   **错误响应:** `401 Unauthorized`, `403 Forbidden`, `404 Not Found`。

##### **PUT /api/v1/lexicon**
*   **描述:** 创建或完整替换项目词汇与约束文件。这是一个幂等操作。服务器在接受前**必须**对请求体执行完整的 Schema 验证。
*   **请求体:** 一个符合《项目词汇与约束文件 Schema 规范 (V1.2)》的完整 JSON 对象。
*   **成功响应:**
    *   **状态码:** `201 Created` (当资源首次被创建时)
        *   **Headers:** `Location: /api/v1/lexicon`
        *   **响应体:** `LexiconSummary` 对象。
    *   **状态码:** `200 OK` (当现有资源被成功替换时)
        *   **响应体:** `LexiconSummary` 对象。
*   **错误响应:**
    *   `400 Bad Request`: 请求体为空、非法的 JSON 格式或未能通过 Schema 验证。
    *   `401 Unauthorized`, `403 Forbidden`, `500 Internal Server Error`。

##### **DELETE /api/v1/lexicon**
*   **描述:** 删除项目词汇与约束文件。
*   **成功响应:**
    *   **状态码:** `204 No Content`
*   **错误响应:** `401 Unauthorized`, `403 Forbidden`, `404 Not Found`。

#### **5. 查询接口定义 (Query Endpoints)**

本服务同时提供全量获取和批量/细粒度查询两种接口。`GET /lexicon` 适用于客户端希望一次性获取并缓存整个词汇表的场景（例如，在应用启动时）。而批量与细粒度查询接口则为那些在运行时仅需少数特定规则、希望最小化网络传输和客户端解析开销的组件（如评审引擎 `L1-DP6`）提供了高效的按需访问方式。

##### **5.1. 细粒度查询 (Granular Queries)**
（此部分无变化）
###### **GET /api/v1/lexicon/glossary/{term}**
###### **GET /api/v1/lexicon/acronyms/{acronym}**
###### **GET /api/v1/lexicon/naming-conventions/{id}**
###### **GET /api/v1/lexicon/formatting-constraints/{id}**

##### **5.2. 批量查询 (Batch Query)**
（此部分无变化）
###### **POST /api/v1/lexicon/query**

#### **6. 示例：调用流程与cURL**

**场景1: `L1-DP6` (评审引擎) 批量校验文档中的术语和规则**
```bash
# L1-DP6 在审查文档前，一次性获取所有需要的定义和规则
curl -X POST \
  -H "Authorization: Bearer <component_token>" \
  -H "X-System-Component-ID: L1-DP6" \
  -H "Content-Type: application/json" \
  -d '{
    "glossary": ["Design Matrix", "Frozen Document"],
    "acronyms": ["URD", "DP"],
    "namingConventionIds": ["ARTIFACT_TYPE_AD_L2_DOC"],
    "formattingConstraintIds": ["DATA_TYPE_ISO_DATE"]
  }' \
  'https://<hostname>/api/v1/lexicon/query'

# 成功时返回 200 OK 和 BatchQueryResponse JSON 对象
```

**场景2: 管理员上传并替换整个词汇文件**
```bash
# 管理员通过UI代理组件，上传一个新的词汇文件内容
# 注意：请求体必须是完整的、符合 V1.2 Schema 的 JSON
curl -i -X PUT \
  -H "Authorization: Bearer <admin_user_token>" \
  -H "X-System-Component-ID: Admin-UI-Proxy" \
  -H "Content-Type: application/json" \
  -d @/path/to/new_lexicon.lexicon.json \
  'https://<hostname>/api/v1/lexicon'

# 场景 2a: 如果是创建新文件，成功时返回 201 Created 和 LexiconSummary
# HTTP/1.1 201 Created
# Location: /api/v1/lexicon
# Content-Type: application/json
#
# {
#   "schemaVersion": "1.2",
#   "lastModified": "2024-06-08T10:00:00Z"
# }

# 场景 2b: 如果是替换旧文件，成功时返回 200 OK 和 LexiconSummary
# HTTP/1.1 200 OK
# Content-Type: application/json
#
# {
#   "schemaVersion": "1.2",
#   "lastModified": "2024-06-08T10:15:30Z"
# }
```

---
Gemini 2.5 Pro 0605 writer

---

## L1-DP3_KnowledgeRetrievalService_TestOutline Freezed

好的，遵照指示。

我已仔细阅读了《评审意见：关于<L1-DP3 知识检索服务测试大纲 (V1.0)>》。评审意见指出的契约覆盖遗漏是准确的，对排序边缘情况的增强建议也将显著提升测试套件的鲁棒性。

我将根据评审意见中的强制性与建议性修订指令，对《L1-DP3 知识检索服务测试大纲》进行修订，生成 V1.1 版本。

---

### **L1-DP3 知识检索服务测试大纲 (V1.1)**

**状态:** 已批准 (Approved)

**版本说明:** 本文档 (V1.1) 是对 V1.0 的修订版。此版本旨在解决 V1.0 评审报告中指出的问题。主要修订内容包括：
1.  **新增 `metadata` 字段验证:** 根据强制性修订意见，在“数据模型验证测试”部分新增了测试用例 `TC-DP3-12`，以确保对《规范 V1.1》中可选的 `metadata` 字段的契约覆盖。
2.  **增强排序测试用例:** 根据建议性修订意见，强化了测试用例 `TC-DP3-05`，明确要求其能处理 `retrieval_score` 相等的情况，以提高测试的鲁棒性。

#### **1. 引言**

本文档定义了一套标准的测试用例和验收标准，旨在验证任何对《抽象知识库服务接口 (Abstract Knowledge Service Interface) 规范 (V1.1)》的具体实现（以下简称“服务实现”）是否符合其定义的契约。

**测试目标:** 本大纲的核心目标是确保**互操作性**和**可靠性**。任何通过本测试大纲的服务实现，都应能无缝地被 `L1-DP3: 知识检索服务` 调用，且其行为在成功和失败场景下都是可预测的。

**测试哲学:** 本大纲测试的是**“契约”而非“质量”**。即，它验证服务实现是否遵循了接口的数据格式、方法签名和行为逻辑，但**不**评估其检索结果的相关性或准确性（即 `retrieval_score` 的计算质量）。检索质量的评估应由服务实现自身的、更专业的测试集来覆盖。

**设计依据:**
*   《抽象知识库服务接口 (Abstract Knowledge Service Interface) 规范 (V1.1)》
*   《公理设计辅助系统 L1 公理设计文档 (V1.1)》
*   《项目代办事项列表 (V1.6)》

#### **2. 测试范围**

##### **2.1. 范围之内 (In Scope)**
*   对 `retrieve_fragments` 接口的输入 (`RetrievalRequest`) 和输出 (`RetrievalResponse`) 数据模型的严格验证。
*   对 `KnowledgeFragment` 数据模型所有字段的验证。
*   对《规范》中定义的成功响应 (`status: "SUCCESS"`) 行为的验证，包括找到结果和未找到结果两种情况。
*   对《规范》中定义的失败响应 (`status: "FAILED"`) 行为的验证，确保关键故障不会被静默处理。
*   对核心参数（如 `max_results`）功能的验证。

##### **2.2. 范围之外 (Out of Scope)**
*   **性能测试:** 本大纲不包括负载、压力或延迟测试。
*   **检索质量评估:** 本大纲不评估检索结果的业务价值、相关性或排名算法的优劣。
*   **安全测试:** 认证、授权等安全相关的测试由更高层次的系统测试负责。
*   **具体实现的内部逻辑:** 不测试服务实现的内部代码、算法或依赖项。

#### **3. 测试环境与前提**

*   **测试客户端:** 一个能够构造并发送 `RetrievalRequest` JSON 对象，并能接收和解析 `RetrievalResponse` JSON 对象的测试客户端。
*   **可配置的服务实现:** 测试应针对一个可以被配置为模拟不同场景的服务实现（例如，一个可以被强制返回特定错误或数据集的 Mock Server 或 Stub）。
*   **测试数据集:** 一套小型的、固定的知识库文档，其内容已知，以便于预测检索结果并进行断言。

#### **4. 测试用例**

为清晰起见，测试用例按功能类别进行组织。

##### **4.1. 契约遵从性与成功路径测试**

| 用例ID | 测试描述 | 测试步骤 | 预期结果 |
| :--- | :--- | :--- | :--- |
| **TC-DP3-01** | **成功检索-多结果:** 发送一个有效的、预期会匹配多个结果的请求。 | 1. 构造一个 `RetrievalRequest`，`query` 字段与测试数据集中多个片段相关。`max_results` 设置为 5。 | 1. 响应的 `status` 字段为 `"SUCCESS"`。 <br> 2. `fragments` 数组不为空，且长度小于或等于 5。 <br> 3. 数组中的每个元素都符合 `KnowledgeFragment` 结构。 <br> 4. `error_message` 字段为 `null` 或不存在。 |
| **TC-DP3-02** | **成功检索-单结果:** 发送一个有效的、预期只匹配一个结果的请求。 | 1. 构造一个 `RetrievalRequest`，`query` 字段与测试数据集中单个片段高度相关。 | 1. 响应的 `status` 字段为 `"SUCCESS"`。 <br> 2. `fragments` 数组长度为 1。 |
| **TC-DP3-03** | **成功检索-无结果:** 发送一个有效的、但预期不会匹配任何结果的请求。 | 1. 构造一个 `RetrievalRequest`，`query` 字段为无意义的字符串。 | 1. **(关键)** 响应的 `status` 字段为 `"SUCCESS"`。 <br> 2. `fragments` 数组必须为空数组 `[]`。 |
| **TC-DP3-04** | **`max_results` 参数验证:** 服务端有多个匹配结果，但 `max_results` 参数限制返回数量。 | 1. 确保测试数据集中有至少 5 个匹配项。 <br> 2. 构造 `RetrievalRequest`，`max_results` 设置为 2。 | 1. `fragments` 数组的长度**必须**为 2。 |
| **TC-DP3-05** | **`fragments` 数组排序验证:** 验证返回的片段是否按 `retrieval_score` 非严格降序排列，并能处理分数相等的情况。 | 1. 确保测试数据集中包含多个预期匹配的片段，**其中至少有两个片段的 `retrieval_score` 值被设计为完全相同**。 <br> 2. 构造一个能返回这些结果的请求。 <br> 3. 在测试客户端接收响应。 | 1. `fragments` 数组中的元素顺序，其 `retrieval_score` 值必须是**非严格**从高到低排列的（即 `score[i] >= score[i+1]`）。 <br> 2. 对于 `retrieval_score` 相同的元素，其相对顺序不做强制要求，但服务不应因此产生错误。 |

##### **4.2. 错误处理与韧性测试**

| 用例ID | 测试描述 | 测试步骤 | 预期结果 |
| :--- | :--- | :--- | :--- |
| **TC-DP3-06** | **服务内部失败:** 模拟服务实现的内部错误（如数据库连接失败）。 | 1. 配置 Mock Server，使其在处理请求时抛出内部异常。 <br> 2. 发送一个有效的 `RetrievalRequest`。 | 1. **(关键)** 响应的 `status` 字段为 `"FAILED"`。 <br> 2. `fragments` 数组**必须**为空数组 `[]`。 <br> 3. `error_message` 字段**必须**存在且为非空字符串，内容应描述失败原因。 |
| **TC-DP3-07** | **请求格式无效-缺少必需字段:** 发送一个缺少 `query` 字段的请求。 | 1. 构造一个不包含 `query` 键的 JSON 对象作为请求体。 | 1. 服务应在传输层拒绝该请求，返回 HTTP `400 Bad Request` 状态码。 <br> 2. 响应体不应是 `RetrievalResponse` 格式，而应是通用的客户端错误格式。 |
| **TC-DP3-08** | **请求格式无效-字段类型错误:** 发送一个 `max_results` 为字符串的请求。 | 1. 构造 `RetrievalRequest`，`max_results` 的值为 `"three"`。 | 1. 服务应在传输层拒绝该请求，返回 HTTP `400 Bad Request` 状态码。 |

##### **4.3. 数据模型验证测试**

| 用例ID | 测试描述 | 测试步骤 | 预期结果 |
| :--- | :--- | :--- | :--- |
| **TC-DP3-09** | **`retrieval_score` 范围验证:** 验证返回的 `retrieval_score` 是否总在 [0.0, 1.0] 区间内。 | 1. 执行 `TC-DP3-01`。 <br> 2. 遍历 `fragments` 数组中的所有元素。 | 1. 每个 `KnowledgeFragment` 对象的 `retrieval_score` 值都必须大于等于 0.0 且小于等于 1.0。 |
| **TC-DP3-10** | **`source` 字段格式验证:** 验证 `source` 字段是否为推荐的 URI 格式。 | 1. 执行 `TC-DP3-01`。 <br> 2. 检查 `fragments` 数组中每个元素的 `source` 字段。 | 1. `source` 字段的值应符合 URI 规范。 |
| **TC-DP3-11** | **`context` 对象接受度验证:** 验证服务实现是否能正确接收包含标准 `context` 字段的请求。 | 1. 构造一个 `RetrievalRequest`，包含 `context` 对象及推荐的 `source_document_uri` 和 `task_id` 字段。 | 1. 请求应被成功处理，不会导致服务失败。 <br> 2. 返回一个有效的 `RetrievalResponse` 对象。 |
| **TC-DP3-12** | **`metadata` 字段兼容性验证:** 验证服务实现能够正确返回可选的 `metadata` 字段，且其格式为有效的 JSON 对象。 | 1. 确保测试数据集中至少有一个知识片段包含 `metadata` 字段。 <br> 2. 构造一个能检索到该片段的 `RetrievalRequest`。 <br> 3. 检查响应中对应 `KnowledgeFragment` 对象的 `metadata` 字段。 | 1. `metadata` 字段存在且其值必须是一个 JSON 对象。 <br> 2. 服务返回包含 `metadata` 字段的响应不应导致任何错误。 <br> 3. (对客户端而言) 客户端应能正确解析包含此可选字段的响应。 |

#### **5. 通过标准**

*   所有定义的测试用例都必须被成功执行。
*   每个测试用例的实际结果必须与“预期结果”列中描述的所有条件完全匹配。
*   任何偏离预期的行为都将被视为测试失败，相关的服务实现必须在被系统集成前修复其缺陷。

---
Gemini 2.5 Pro 0605 writer

---

## L1-DP4_ArbitrationLogic_Definition Freezed

好的，遵照指示。

我将根据《项目代办事项列表 (V1.7)》中的待办事项，开始下一项工作：撰写《L1-DP4 知识冲突仲裁逻辑规则定义》。

这份文档旨在将《软件用户需求文档 (URD) V1.6》§5.3 中描述的知识源优先级规则，形式化为一套清晰、无歧义、可直接实现的逻辑规范。这对于确保系统在面对信息冲突时行为的确定性至关重要。

以下是本次工作的产出文档。

---

### **L1-DP4 知识冲突仲rac逻辑规则定义 (V1.0)**

**状态:** **已批准 (Approved)**

**版本说明:** 本文档 (V1.0) 是该规范的初版。其目的是对《软件用户需求文档 (URD) V1.6》中定义的知识源优先级规则进行形式化定义，为 `L1-DP4: 知识仲裁器` 的具体实现提供一个清晰、无歧义的逻辑基础。

#### **1. 引言**

本文档定义了 `L1-DP4: 知识仲裁器` 在处理来自不同知识源的信息冲突时，必须遵循的核心逻辑规则。根据《公理设计辅助系统 L1 公理设计文档 (V1.1)》，`L1-DP4` 的唯一职责是应用一个预定义的优先级规则，以确保系统在面对冲突时能够做出确定性的决策。

**文档目标:**
本文档的目标不是定义 API 接口或数据结构（这将在《L1-DP4 知识仲裁器 API 接口规范》中完成），而是以一种接近伪代码的形式，对决策逻辑本身进行精确描述。这确保了逻辑定义的清晰性，并使其可以被任何编程语言直接实现。

**设计依据:**
*   《软件用户需求文档 (URD) V1.6》 (特别是 §5.3)
*   《公理设计辅助系统 L1 公理设计文档 (V1.1)》 (特别是对 L1-FR4 和 L1-DP4 的定义)
*   《项目代办事项列表 (V1.7)》

#### **2. 核心规则定义**

系统内存在两种性质不同的知识源，它们通过不同的设计参数（DPs）提供给系统的其他部分：

1.  **确定性知识源 (Deterministic Source):** 由 `L1-DP2: 项目词汇服务` 提供。其内容源自《项目词汇与约束文件》，被视为项目内部的“法典(Canon)”，具有最高权威性。
2.  **检索性知识源 (Retrieved Source):** 由 `L1-DP3: 知识检索服务` 提供。其内容是从外部知识库中根据相关性检索而来的信息片段，本质上是辅助性的参考信息。

根据 URD §5.3 的规定，我们定义以下唯一且绝对的仲裁规则：

*   **规则 1：确定性知识源优先于检索性知识源。**
    *   **释义:** 当针对同一主题，同时存在来自 `L1-DP2` 和 `L1-DP3` 的信息时，**必须**采纳 `L1-DP2` 提供的信息，并**丢弃** `L1-DP3` 提供的信息。

#### **3. 形式化逻辑表述**

为了将上述规则转化为可实现的逻辑，我们可以将其表述为一个纯函数 (Pure Function)。该函数接收一组关于特定主题的、可能冲突的信息单元，并返回经过仲裁后被采纳的唯一信息单元（或在无有效信息时返回空）。

**伪代码表示:**

```
// 定义一个信息单元的数据结构
// (具体 Schema 将在 API 规范中定义)
DataStructure InformationUnit {
  content: string,        // 信息内容
  source_component: string // 来源组件标识, e.g., "L1-DP2", "L1-DP3"
  // ... 其他元数据
}

// 仲裁函数
Function ArbitrateKnowledge(information_units: List<InformationUnit>) -> InformationUnit | null {

  // 1. 查找来自 L1-DP2 (项目词汇服务) 的信息
  //    根据规则，此来源具有最高优先级。
  lexicon_entry = information_units.find(unit -> unit.source_component == "L1-DP2");

  // 2. 如果找到了来自 L1-DP2 的信息，则立即返回该信息。
  //    所有其他来源的信息都将被忽略。
  if (lexicon_entry is not null) {
    Log("Conflict resolved: Prioritizing entry from L1-DP2.");
    return lexicon_entry;
  }

  // 3. 如果没有来自 L1-DP2 的信息，则查找来自 L1-DP3 (知识检索服务) 的信息。
  knowledge_fragment = information_units.find(unit -> unit.source_component == "L1-DP3");

  // 4. 如果找到了来自 L1-DP3 的信息，则返回该信息。
  if (knowledge_fragment is not null) {
    Log("No entry from L1-DP2 found. Using entry from L1-DP3.");
    return knowledge_fragment;
  }
  
  // 5. 如果两个来源都没有提供信息，则返回 null。
  Log("No information found from any source.");
  return null;
}
```

#### **4. 应用场景示例**

##### **场景 A: 存在冲突，规则生效**

*   **背景:** `L1-DP5` (内容生成引擎) 在撰写文档时，需要获取术语 "FR" 的全称。
*   **输入:** `L1-DP4` 收到以下关于 "FR" 的信息单元列表：
    *   `unit_A`: `{ content: "Functional Requirement", source_component: "L1-DP2" }`
    *   `unit_B`: `{ content: "In finance, FR can mean 'Financial Reporting'.", source_component: "L1-DP3" }`
*   **执行过程:**
    1.  `ArbitrateKnowledge` 函数被调用，输入为 `[unit_A, unit_B]`。
    2.  函数在步骤 1 寻找到 `unit_A` 的 `source_component` 是 "L1-DP2"。
    3.  函数在步骤 2 进入 `if` 条件判断，直接返回 `unit_A`。`unit_B` 被忽略。
*   **输出:** `{ content: "Functional Requirement", source_component: "L1-DP2" }`

##### **场景 B: 无冲突，只有检索性知识**

*   **背景:** `L1-DP5` 需要了解 "微服务架构" 的相关信息。这个术语并未在项目词汇中定义。
*   **输入:** `L1-DP4` 收到以下信息单元列表：
    *   `unit_A`: `{ content: "Microservices is an architectural style that structures an application as a collection of services...", source_component: "L1-DP3" }`
*   **执行过程:**
    1.  `ArbitrateKnowledge` 函数被调用，输入为 `[unit_A]`。
    2.  函数在步骤 1 未找到来自 "L1-DP2" 的信息。
    3.  函数在步骤 3 寻找到来自 "L1-DP3" 的信息，即 `unit_A`。
    4.  函数在步骤 4 返回 `unit_A`。
*   **输出:** `{ content: "Microservices is an architectural style...", source_component: "L1-DP3" }`

#### **5. 实现者须知**

*   **无状态与确定性:** `L1-DP4` 的实现**必须**是无状态的。对于任何给定的输入，其输出必须永远相同。函数不应依赖任何外部状态或历史调用记录。
*   **单一职责:** `L1-DP4` 的职责严格限定于仲裁。它不负责获取信息，也不负责消费信息。它是一个纯粹的、逻辑简单的决策模块。
*   **日志记录:** 在发生冲突并成功仲裁时（如场景A），实现者应考虑记录一条明确的日志。这对于未来审计系统的决策过程至关重要。日志应包含被采纳和被丢弃的信息源。
*   **可扩展性:** 当前版本的规则非常简单。未来的设计可能会引入更多知识源或更复杂的优先级规则。实现时应考虑将规则逻辑与执行框架分离，以便未来能方便地扩展规则集（例如，通过配置或插件）。

---
Gemini 2.5 Pro 0605 writer

---

## L1-DP6_ReviewEngine_TestOutline Freezed

好的，遵照指示。

我已收到并深入理解了《评审意见：关于<L1-DP6 评审引擎测试大纲 (V1.0)>》。评审结论为“驳回，需强制性修订”。

我将依据评审意见中列出的两项强制性修订指令 (M1, M2) 和两项建议性修订意见 (S1, S2)，对该测试大纲进行修订。本次修订旨在解决原大纲中对关键业务规则（如“僵局”仲裁）和核心功能（如词汇表应用）的测试覆盖遗漏，并全面提升测试用例描述的精确性。

以下是根据上述评审意见修订后的完整文档。

---

### **L1-DP6 评审引擎测试大纲 (V1.1)**

**状态:** 已批准(approved)

**版本说明:** 本文档 (V1.1) 是对 V1.0 版本的重大修订。它依据《评审意见：关于<L1-DP6 评审引擎测试大纲 (V1.0)>》进行了强制性修订，以确保对所有关键业务规则和 API 契约的完整覆盖。核心变更包括：
1.  **补全仲裁逻辑测试 (M1):** 新增测试用例 `TC-DP6-05a`，专门用于验证因“僵局检测” (`STALEMATE_DETECTED`) 触发用户仲裁的场景，弥补了原先只测试“达到最大循环次数”的缺陷。
2.  **增加词汇表应用测试 (M2):** 新增测试用例 `TC-DP6-02a`，严格验证引擎是否能依据请求中提供的 `lexicon_uri` 来审查文档内容，确保了对上下文处理功能的测试覆盖。
3.  **增强上下文感知测试 (S1):** 新增测试用例 `TC-DP6-10`，显式验证 `previous_review_cycle` 字段对引擎后续行为的影响，提升了对循环评审连贯性的测试。
4.  **提高描述精确性 (S2):** 全面重写了所有测试用例的“测试步骤”描述，使其更精确、更面向自动化，可以直接指导测试脚本的实现。

#### **1. 引言**

本文档定义了一套标准的测试用例和验收标准，旨在验证 `L1-DP6: 评审与评估引擎` 的具体实现是否完全符合其定义的契约和功能需求。`L1-DP6` 是系统中负责保证文档质量和设计原则合规性的核心组件，因此对其行为的严格验证至关重要。

**测试目标:**
*   **契约遵从性:** 确保服务的实现严格遵循《L1-DP6 评审与评估引擎 API 接口规范 (V1.1)》中定义的异步模式、数据模型和错误处理机制。
*   **功能正确性:** 验证引擎是否能正确应用项目模板中定义的审查清单、执行可追溯性检查、分析设计矩阵，并依据公理设计原则进行评估。
*   **工作流驱动能力:** 验证引擎是否能在预设条件下（如达到最大审查次数、检测到僵局）正确地触发“用户仲裁”流程，生成包含 `ARBITRATION_REQUIRED` 决策的响应。

**测试哲学:** 本大纲遵循 **黑盒功能测试** 的原则。测试将通过调用 API 端点来验证服务的外部行为，而 **不** 关心其内部实现细节，如具体的 LLM Prompt 工程或其依赖的库。测试的核心是验证“服务做了什么”，而非“服务如何做”。

**设计依据:**
*   《L1-DP6 评审与评估引擎 API 接口规范 (V1.1)》 (核心测试对象)
*   《评审意见：关于<L1-DP6 评审引擎测试大纲 (V1.0)>》
*   《软件用户需求文档 (URD) V1.6》 (特别是 §2.1, §4.2, §4.3, §6.3)
*   《公理设计辅助系统 L1 公理设计文档 (V1.1)》
*   《项目模板 Schema 规范 (V1.2)》

#### **2. 测试范围**

##### **2.1. 范围之内 (In Scope)**
*   API 异步工作流的完整验证（`POST` 返回 202 -> `GET` 轮询 -> `GET` 返回最终结果）。
*   对 `ReviewRequest` 和 `ReviewResponse` 数据模型的严格验证。
*   对所有评审决策 (`APPROVED`, `REVISION_REQUESTED`, `ARBITRATION_REQUIRED`) 的逻辑验证。
*   对项目模板中 `reviewChecklist` 的应用情况验证，包括对特殊指令（如 `[TraceabilityCheck]`）和项目词汇表 (`lexicon_uri`) 的处理。
*   对公理一 (`[Axiom1-Check]`) 的评估能力验证。
*   对所有用户仲裁触发条件（`MAX_CYCLES_REACHED` 和 `STALEMATE_DETECTED`）的验证。
*   对 `previous_review_cycle` 上下文处理能力的验证。

##### **2.2. 范围之外 (Out of Scope)**
*   **性能测试:** 不包括负载、压力或延迟测试。
*   **评审质量的主观评估:** 不评估 LLM 生成的 `executive_summary` 或 `findings` 的“智能程度”或“洞察力”。测试只关心这些字段是否按要求生成且结构正确。
*   **安全测试:** 认证、授权等安全相关的测试由更高层次的系统测试负责。
*   **具体实现的内部逻辑:** 不测试服务实现的内部代码、算法或依赖项。

#### **3. 测试环境与前提**

*   **测试客户端:** 一个能够构造并发送 HTTP 请求，并能解析 JSON 响应的自动化测试框架。
*   **被测服务 (SUT):** 一个正在运行的 `L1-DP6` 服务实例。
*   **模拟依赖服务 (Mock Services):** **至关重要。** 由于 `L1-DP6` 依赖多个其他L1服务来获取上下文，测试环境必须提供以下服务的 **模拟实现**，以便返回可预测的、受控的测试数据：
    *   **Mock L1-DP1 (模板服务):** 用于提供包含特定审查清单和配置（如 `maxReviewCycles`）的测试模板。
    *   **Mock L1-DP2 (词汇服务):** 用于根据 `lexicon_uri` 提供测试用的词汇表。
    *   **Mock L1-DP7 (版本控制服务):** 用于根据 `document_uri` 提供受控的文档内容（如完美的草稿、有缺陷的草稿等）。

#### **4. 测试用例**

##### **4.1. 核心逻辑与成功路径测试**

| 用例ID | 测试描述 | 测试步骤 | 预期结果 |
| :--- | :--- | :--- | :--- |
| **TC-DP6-01** | **完美草稿-批准路径:** 评审一份完全符合所有标准和清单的文档草稿。 | 1. 在 Mock L1-DP7 中准备一份符合所有标准的文档草稿 (`perfect-doc.md`)。<br> 2. 构造指向 `perfect-doc.md` 的 `ReviewRequest`。<br> 3. `POST /api/v1/reviews` 提交请求，获取 `review_id`。<br> 4. 轮询 `GET /api/v1/reviews/{review_id}` 直至任务完成。<br> 5. 解析最终的 `ReviewResponse` JSON 对象。 | 1. 响应体中 `overall_decision` 字段为 `"APPROVED"`。<br> 2. `findings` 数组为空。<br> 3. `checklist_responses` 数组中所有项的 `status` 均为 `"PASSED"`。 |
| **TC-DP6-02** | **有缺陷草稿-修订路径:** 评审一份包含明显、简单缺陷的文档草稿。 | 1. 在 Mock L1-DP7 中准备一份有拼写错误的草稿 (`flawed-doc.md`)。<br> 2. 构造指向 `flawed-doc.md` 的 `ReviewRequest`。<br> 3. `POST /api/v1/reviews` 提交请求。<br> 4. 轮询 `GET` 端点直至任务完成。<br> 5. 解析最终的 `ReviewResponse`。 | 1. 响应体中 `overall_decision` 字段为 `"REVISION_REQUESTED"`。<br> 2. `findings` 数组不为空，且包含描述拼写问题的条目。<br> 3. `checklist_responses` 中对应项的 `status` 为 `"FAILED"`。 |

##### **4.2. 公理设计与上下文指令测试**

| 用例ID | 测试描述 | 测试步骤 | 预期结果 |
| :--- | :--- | :--- | :--- |
| **TC-DP6-02a** | **词汇表应用验证:** 评审一份使用了项目词汇表中禁用术语的文档。 | 1. 在 Mock L1-DP2 中准备一份词汇表 (`test.lexicon`)，定义“功能需求”唯一合法缩写为“FR”，禁止使用“FN”。<br> 2. 在 Mock L1-DP7 中准备一份草稿 (`lexicon-violation.md`)，其中故意使用“FN-1”。<br> 3. 构造 `ReviewRequest`，在 `context` 中提供指向 `test.lexicon` 的 `lexicon_uri`。<br> 4. `POST /api/v1/reviews` 提交请求，轮询直至完成。 | 1. `overall_decision` 为 `"REVISION_REQUESTED"`。<br> 2. `findings` 数组中必须包含一个条目，其 `description` 明确指出“违反项目词汇表约束”并定位到“FN-1”。<br> 3. `checklist_responses` 中与“术语一致性”相关的检查项状态为 `"FAILED"`。 |
| **TC-DP6-03** | **可追溯性检查 (`[TraceabilityCheck]`):** 评审一份L2设计文档，其某个FR无法追溯到L1父文档。 | 1. 在 Mock L1-DP1 提供的测试模板中加入 `"[TraceabilityCheck]..."` 指令。<br> 2. 准备一份L2草稿，其中一个L2-FR故意无法映射回L1-FR。<br> 3. 构造 `ReviewRequest`，并在 `upstream_documents` 中提供L1父文档的URI。<br> 4. `POST /api/v1/reviews` 提交请求，轮询直至完成。 | 1. `overall_decision` 为 `"REVISION_REQUESTED"`。<br> 2. `checklist_responses` 中 `[TraceabilityCheck]` 项的 `status` 为 `"FAILED"`。<br> 3. `findings` 数组中包含一个 `severity` 为 `MAJOR` 或 `CRITICAL` 的发现项，明确指出追溯性失败。 |
| **TC-DP6-04** | **独立公理检查 (`[Axiom1-Check]`):** 评审一份包含耦合设计矩阵的设计文档。 | 1. 在 Mock L1-DP1 提供的测试模板中加入 `"[Axiom1-Check]..."` 指令。<br> 2. 在 Mock L1-DP7 中准备一份带有非对角线设计矩阵的草稿。<br> 3. 构造 `ReviewRequest`。<br> 4. `POST /api/v1/reviews` 提交请求，轮询直至完成。 | 1. `overall_decision` 为 `"REVISION_REQUESTED"`。<br> 2. `checklist_responses` 中 `[Axiom1-Check]` 项的 `status` 为 `"FAILED"`。<br> 3. `findings` 数组中包含一个 `severity` 为 `CRITICAL` 的发现项，其 `description` 明确指出“违反独立公理”，且 `location` 精确定位到该设计矩阵。 |

##### **4.3. 工作流与仲裁触发测试**

| 用例ID | 测试描述 | 测试步骤 | 预期结果 |
| :--- | :--- | :--- | :--- |
| **TC-DP6-05** | **仲裁触发 (`MAX_CYCLES_REACHED`):** 模拟多次修订后仍未批准，触发用户仲裁。 | 1. 在 Mock L1-DP1 提供的项目模板中，将 `maxReviewCycles` 设置为 `3`。<br> 2. 连续三次 `POST` 对同一份有缺陷文档的评审请求。<br> 3. 针对第三次请求，轮询 `GET` 端点直至任务完成。 | 1. 第三次请求的最终响应中，`overall_decision` 字段**必须**为 `"ARBITRATION_REQUIRED"`。<br> 2. `decision_reason` 对象**必须**存在，且其 `code` 字段为 `"MAX_CYCLES_REACHED"`。 |
| **TC-DP6-05a** | **仲裁触发 (僵局检测):** 模拟撰写员连续两轮未能解决一个关键缺陷，触发用户仲裁。 | 1. 模板 `maxReviewCycles` 设为10。<br> 2. **Round 1:** `POST` 对一份含 `CRITICAL` 缺陷 (`finding-crit-01`) 草稿的评审请求。轮询并获取包含该 `finding` 的 `ReviewResponse`。<br> 3. **Round 2:** `POST` 第二次评审请求，草稿仍含 `finding-crit-01`，请求体中**必须**包含 `previous_review_cycle` 字段，引用第一轮的结果。<br> 4. **Round 3:** 轮询`GET`端点获取第二轮评审结果后，`POST` 第三次评审请求，草稿仍含 `finding-crit-01`，同样包含 `previous_review_cycle`。 | 1. 针对第三次请求的最终响应，`overall_decision` **必须**是 `ARBITRATION_REQUIRED`。<br> 2. `decision_reason` 对象**必须**存在，且其 `code` 字段**必须**为 `STALEMATE_DETECTED`。 |

##### **4.4. API 契约与健壮性测试**

| 用例ID | 测试描述 | 测试步骤 | 预期结果 |
| :--- | :--- | :--- | :--- |
| **TC-DP6-06** | **异步流程验证:** 验证 API 的基本异步调用流程。 | 1. `POST /api/v1/reviews`，使用任意有效请求体。 | 1. 服务立即返回 HTTP `202 Accepted`。<br> 2. 响应头包含一个有效的 `Location` 字段。<br> 3. 响应体是一个 `status` 为 `PENDING` 的 `ReviewStatus` 对象。 |
| **TC-DP6-07** | **轮询状态验证:** 验证轮询任务状态的正确性。 | 1. 执行 TC-DP6-06 后，立即 `GET` `Location` 头返回的 URL。 | 1. 服务返回 HTTP `200 OK`。<br> 2. 响应体是一个 `ReviewStatus` 对象，其 `status` 为 `PENDING` 或 `RUNNING`。 |
| **TC-DP6-08** | **无效请求-缺少字段:** 发送一个缺少 `document_uri` 的请求。 | 1. 构造一个不含 `document_uri` 键的 `ReviewRequest`。<br> 2. `POST /api/v1/reviews` 提交该请求。 | 1. 服务返回 HTTP `400 Bad Request`。<br> 2. 响应体是一个标准的 `Error` 对象。 |
| **TC-DP6-09** | **无效请求-URI无法解析:** 请求中引用的 `document_uri` 在 Mock L1-DP7 中不存在。 | 1. 构造一个 `document_uri` 指向不存在资源的请求。<br> 2. `POST /api/v1/reviews` 提交该请求。 | 1. 服务返回 HTTP `404 Not Found`。<br> 2. 响应体是一个标准的 `Error` 对象。 |
| **TC-DP6-10** | **上下文感知验证 (`previous_review_cycle`):** 验证引擎在收到上一轮评审上下文后，其响应能体现出对历史问题的认知。 | 1. **Round 1:** `POST` 对一份含轻微缺陷 (`finding-minor-01`)草稿的请求。获取响应。<br> 2. **Round 2:** `POST` 第二次请求，草稿未修复该缺陷，请求体中**必须**包含 `previous_review_cycle` 字段。<br> 3. 轮询并解析第二轮的最终响应。 | 1. 第二轮响应的 `executive_summary` 或 `findings` 中，针对 `finding-minor-01` 的描述应包含表明其为重复问题的措辞（如“问题**仍未**解决”、“先前已指出的问题”等）。 |

#### **5. 通过标准**

*   所有定义的测试用例都必须被成功执行。
*   每个测试用例的实际结果必须与“预期结果”列中描述的所有条件完全匹配。
*   任何偏离预期的行为都将被视为测试失败，相关的服务实现必须在被系统集成前修复其缺陷。

---
Gemini 2.5 Pro 0605 writer

---

## L1-DP6_ReviewFeedback_Schema Freezed

好的，遵照指示。

我将根据《项目代办事项列表 (V2.0)》中的顺序，开始执行下一项工作：**撰写《审查意见文档 (review_feedback.md) 结构化 Schema 规范》**。

这份文档旨在将《L1-DP6 评审与评估引擎 API 接口规范 (V1.1)》中定义的、由服务输出的 `ReviewResponse` JSON 对象，转换为一个既适合人类阅读、又能够被机器确定性解析的标准化 Markdown 文件格式。这份文件是连接“审查”与“修订”两个核心环节的关键数据载体。

以下是本次工作的产出文档。

---

### **审查意见文档 (review_feedback.md) 结构化 Schema 规范 (V1.0)**

**状态:** 已批准 (Approved)

**版本说明:** 本文档 (V1.0) 是该 Schema 规范的初版。其目的是为 `L1-DP6: 评审与评估引擎` 输出的审查意见文件（`review_feedback.md`）定义一个清晰、标准、可被机器解析的结构。

#### **1. 引言**

本文档定义了“审查意见文档” (`review_feedback.md`) 的标准结构。该文档是 `L1-DP6: 评审与评估引擎` 在完成评审任务后的核心产出，同时也是 `L1-DP5: 内容生成与修订引擎` 执行修订任务的关键输入。

**设计目标:**
*   **双重可读性 (Dual Readability):** 文件格式必须同时满足人类用户（进行审计或监督）和自动化系统（`L1-DP5`）的阅读需求。
*   **机器可解析性 (Machine-Parsable):** 文件的核心元数据和审查结论必须以结构化的方式嵌入，以便于系统进行确定性的解析和处理。
*   **可追溯性 (Traceability):** 每个发现项都拥有唯一的标识符，便于 `L1-DP5` 在后续的修订说明中明确回应，形成闭环。

本规范将 `L1-DP6` API 的 `ReviewResponse` 对象映射为 Markdown 文件，主要通过 **YAML Front Matter** 实现元数据的结构化，通过 **标准化的 Markdown 标题和表格** 实现内容的结构化。

**设计依据:**
*   《L1-DP6 评审与评估引擎 API 接口规范 (V1.1)》 (本规范是其响应体 `ReviewResponse` 的一种序列化形式)
*   《项目代办事项列表 (V2.0)》
*   《软件用户需求文档 (URD) V1.6》

#### **2. 文件结构定义**

`review_feedback.md` 文件由两部分组成：一个 YAML Front Matter 块和一个 Markdown 正文。

##### **2.1. YAML Front Matter**

此部分包含了所有用于驱动工作流和进行追溯的核心元数据。它必须位于文件的最顶部，并由三条短划线 (`---`) 包围。

| 键 (Key) | 类型 | 是否必需 | 描述 | 来源 (API Response) |
| :--- | :--- | :--- | :--- | :--- |
| `review_id` | string | 是 | 本次评审任务的唯一标识符。 | `ReviewResponse.review_id` |
| `document_uri` | string | 是 | 被评审文档的唯一版本化URI。 | `ReviewRequest.document_uri` |
| `overall_decision` | string | 是 | 最终评审决策。枚举值：`APPROVED`, `REVISION_REQUESTED`, `ARBITRATION_REQUIRED`。 | `ReviewResponse.overall_decision` |
| `decision_reason_code` | string | 否 | 当决策为 `ARBITRATION_REQUIRED` 时，提供机器可读的触发代码。 | `ReviewResponse.decision_reason.code` |
| `generated_at` | string | 是 | 本审查意见文档的生成时间戳 (ISO 8601格式)。 | `L1-DP6` 生成时的时间 |

##### **2.2. Markdown 正文 (Body)**

正文部分使用标准的 Markdown 语法，以人类可读的方式展示评审的详细内容。

*   **一级标题 (`#`):** `评审报告: <文档名>`
    *   动态生成，`<文档名>` 为被评审文档的友好名称。

*   **二级标题 (`##`):** `1. 总体摘要`
    *   **内容:** 直接渲染 `ReviewResponse.executive_summary` 字段的字符串内容。

*   **二级标题 (`##`):** `2. 审查清单响应`
    *   **内容:** 将 `ReviewResponse.checklist_responses` 数组渲染成一个 Markdown 表格。
    *   **表格列:**
        1.  **审查项 (Checklist Item):** 对应 `checklist_item_text`。
        2.  **状态 (Status):** 对应 `status`。推荐使用表情符号增强可读性 (如: ✅ `PASSED`, ❌ `FAILED`, 🤷 `NOT_APPLICABLE`)。
        3.  **说明/证据 (Evidence):** 对应 `evidence`。

*   **二级标题 (`##`):** `3. 详细发现`
    *   **内容:**
        *   如果 `ReviewResponse.findings` 数组为空，则显示“未发现具体问题。”
        *   如果数组不为空，则遍历每个 `Finding` 对象，并为每一项生成一个三级子标题和内容块。
    *   **三级标题 (`###`):** `发现项: <finding_id> (<severity>)`
        *   动态生成，`<finding_id>` 和 `<severity>` 分别对应 `Finding` 对象的同名字段。
    *   **内容块:** 使用定义列表或普通文本清晰地展示 `Finding` 对象的其他字段：
        *   **描述 (Description):** `Finding.description` 的内容。
        *   **建议 (Suggestion):** `Finding.suggestion` 的内容。
        *   **位置 (Location):** 使用 Markdown 引用块 (`>`) 来展示定位信息，包括行号和上下文片段。格式如下：
            ```markdown
            > [!NOTE]
            > **文件:** `<document_uri>`
            > **行号:** `start_line` - `end_line`
            >
            > ```<language>
            > <context_snippet>
            > ```
            ```

#### **3. 完整示例**

以下是一个完整的 `review_feedback.md` 文件示例，它精确地映射了《L1-DP6 评审与评估引擎 API 接口规范 (V1.1)》中的示例响应。

```markdown
---
review_id: "rev-20250608-x7y8z9"
document_uri: "vcs://project-alpha/docs/AD_L2_DP5_ContentEngine.md?commit=a1b2c3d4"
overall_decision: "ARBITRATION_REQUIRED"
decision_reason_code: "MAX_CYCLES_REACHED"
generated_at: "2025-06-08T14:30:00Z"
---

# 评审报告: AD_L2_DP5_ContentEngine.md

## 1. 总体摘要

在多次修订后，文档仍然未能解决一个关键的独立公理违反问题。现在需要用户仲裁才能继续。

## 2. 审查清单响应

| 审查项 | 状态 | 说明/证据 |
| :--- | :---: | :--- |
| [Axiom1-Check] 分析设计矩阵... | ❌ FAILED | 发现项 [find-001] 仍然未解决：L2设计矩阵仍未对角化或下三角化，表明存在持续的耦合。 |
| 验证所有功能需求(FRs)是否被满足。 | ✅ PASSED | 所有已定义的FR均有对应的DP实现。 |
| 检查与项目词汇约束文件的一致性。 | ✅ PASSED | 未发现术语或格式违规。 |

## 3. 详细发现

### 发现项: find-001 (CRITICAL)

*   **描述:** 独立公理违反：L2设计矩阵显示FR2对DP3存在依赖。这种耦合必须通过重新定义FR或DP来消除，以实现解耦设计。
*   **建议:** 考虑创建一个新的L2-DP来处理FR2从DP3所需的功能，或者重新定义FR2，使其不直接需要该信息。

> [!NOTE]
> **文件:** `vcs://project-alpha/docs/AD_L2_DP5_ContentEngine.md?commit=a1b2c3d4`
> **行号:** 85 - 92
>
> ```markdown
> | FR / DP | DP1 | DP2 | DP3 |
> | :--- | :---: | :---: | :---: |
> | **FR1** | X | | |
> | **FR2** | O_d | X | O_d |
> ```

---
Gemini 2.5 Pro 0605 writer
```

---

## L1-DP7_DependencyConfidenceScoringRules_Definition Freezed

好的，遵照指示。

我已收到并深入研究了《评审意见：关于<依赖关系置信度评分计算规则定义文档 (V1.0)>》。该评审结论为“批准，附带建议性修订”。

我将依据该评审文档中提出的三项建议性修订意见，对规范进行修订。本次修订的核心是增强算法定义的逻辑完备性和术语精确性。

以下是修订后的完整文档。

---

### **依赖关系置信度评分计算规则定义文档 (V1.1)**

**状态:** 已批准（Approved）

**版本说明:** 本文档 (V1.1) 是对 V1.0 版本的修订。它依据《评审意见：关于<依赖关系置信度评分计算规则定义文档 (V1.0)>》中提出的建议性意见进行修订，旨在增强文档的逻辑完备性与术语精确性。核心变更包括：
1.  **明确算法前提:** 新增了关于算法有效性前提的说明，明确指出其对“可引用元素必须拥有唯一标识符”这一系统级契约的依赖。
2.  **精化参数分类:** 重构了可配置参数表，将参数分类为更精确的“基准分权重”和“调整系数”，以消除术语上的歧义。
3.  **补充设计说明:** 为“关键词匹配”这一低置信度链接的简化评分模型增加了设计说明，阐明了当前设计的考量并为未来迭代指明了方向。

#### **1. 引言**

本文档详细定义了在变更管理流程中，用于计算下游文档依赖关系“置信度评分”的具体算法和规则。该评分是系统向用户呈现《变更影响报告》时的关键辅助信息，旨在帮助用户理解不同依赖关系的强度和变更所带来的潜在风险。

`L1-DP7: 版本控制与变更服务` 是本规则的唯一实现者和执行者。

**设计目标:**
*   **可解释性 (Interpretability):** 评分的计算过程必须是透明的，最终的评分和分类应能追溯到其所依据的具体规则。
*   **可配置性 (Configurability):** 算法中的关键参数（如权重、阈值）必须是可配置的，允许在项目模板中根据项目需求进行调整。
*   **确定性 (Determinism):** 对于任何给定的输入（源文档变更、下游文档、链接类型），算法的输出必须是完全可预测和可重复的。

**设计依据:**
*   《软件用户需求文档 (URD) V1.6》 (特别是 §3.2.3.1)
*   《L1-DP7 版本控制与变更服务 API 接口规范 (V1.1)》
*   《项目代办事项列表 (V2.4)》

#### **2. 设计哲学：基准与调整模型**

本算法采用“基准分与调整系数”模型。其核心思想是：
1.  首先根据**链接类型**的强度，确定一个**基准分 (Base Score)**。这是影响置信度的最主要因素。
2.  然后根据**变更范围**是否直接影响下游引用的具体内容，计算出一个**调整系数 (Adjustment Factor)**。
3.  最终得分由基准分和调整系数共同决定，然后根据可配置的阈值进行分类。

这种模型确保了评分的可解释性，每个部分都对应 URD 中的一个明确原则。

#### **3. 评分算法形式化定义**

**算法前提说明:** 本算法中“变更范围调整系数”的计算逻辑（步骤2），其有效性严格依赖于一个系统级契约：所有项目文档中可被追溯的元素（如功能需求FR、设计参数DP等）**必须**拥有唯一的、机器可解析的标识符。`ParseReferencedElements` 和 `WasReferencedElementModified` 函数的实现依赖此标识符的存在来进行精确匹配。

算法被设计为一个纯函数，用于评估一个下游文档 (`target_document`) 对一个已变更的源文档 (`source_document`) 的依赖置信度。

**伪代码表示:**

```
// 定义可配置的参数结构
DataStructure ScoringConfig {
  base_score_weights: {
    parent_child: float,        // 父子层级关系权重
    explicit_reference: float,  // 显式引用权重
    keyword_match: float        // 关键词匹配权重
  },
  adjustment_factors: {
    direct_impact: float,       // 变更范围直接命中的乘数
    semantic_factor: float      // 语义相似度得分的缩放系数
  },
  thresholds: {
    high: float,                // 高置信度分类阈值
    medium: float               // 中置信度分类阈值
  }
}

// 主函数：计算置信度
Function CalculateConfidence(source_doc_before: Document, source_doc_after: Document, target_document: Document, link_info: LinkInfo, config: ScoringConfig) -> {score: float, category: string, reason: string} {

  // 步骤 1: 根据链接类型确定基准分 (Base Score)
  base_score = 0.0;
  reason_base = "";
  switch (link_info.type) {
    case "PARENT_CHILD":
      base_score = config.base_score_weights.parent_child;
      reason_base = "直接父子层级关系";
      break;
    case "EXPLICIT_REFERENCE":
      base_score = config.base_score_weights.explicit_reference;
      reason_base = "通过结构化标签显式引用";
      break;
    case "SEMANTIC_SIMILARITY":
      // 注意：语义相似度的原始分由外部提供，此处仅应用缩放系数
      base_score = link_info.similarity_score * config.adjustment_factors.semantic_factor;
      reason_base = "通过语义相似性关联";
      break;
    case "KEYWORD_MATCH":
      base_score = config.base_score_weights.keyword_match;
      reason_base = "通过关键词匹配关联";
      break;
  }

  // 步骤 2: 计算变更范围调整系数 (Scope Adjustment Factor)
  scope_factor = 1.0;
  reason_scope = "";
  // 仅对高可信度的链接类型检查变更范围
  if (link_info.type == "PARENT_CHILD" || link_info.type == "EXPLICIT_REFERENCE") {
    // 找出 target_document 明确引用的 source_document 中的所有元素ID (如 FR-1, DP-2)
    referenced_element_ids = ParseReferencedElements(target_document);
    
    // 比较 source_doc_before 和 source_doc_after，判断被引用的元素是否被修改
    if (WasReferencedElementModified(source_doc_before, source_doc_after, referenced_element_ids)) {
      scope_factor = config.adjustment_factors.direct_impact;
      reason_scope = "变更内容直接影响了被引用的元素";
    }
  }

  // 步骤 3: 计算最终得分
  // 依赖距离调整：本算法在单次调用中只处理直接依赖，距离为1。
  // 更深层级的依赖由调用方（图遍历算法）处理，因此距离调整系数在此处为1.0。
  final_score = base_score * scope_factor;
  final_score = min(final_score, 1.0); // 得分上限为1.0

  // 步骤 4: 分类并生成说明
  category = "LOW";
  if (final_score >= config.thresholds.high) {
    category = "HIGH";
  } else if (final_score >= config.thresholds.medium) {
    category = "MEDIUM";
  }

  full_reason = reason_base + (reason_scope ? "; " + reason_scope : "");

  return {score: final_score, category: category, reason: full_reason};
}
```

#### **4. 可配置参数定义**

以下参数应由项目模板提供，并传递给 `L1-DP7` 服务。

| 分类             | 参数                 | 类型  | 默认值 | 描述                                                                          |
| :--------------- | :------------------- | :---- | :----- | :---------------------------------------------------------------------------- |
| **基准分权重**   | `parent_child`       | float | 0.9    | 父子层级关系（如 L2 对 L1 分解）的**基准分**。                                  |
| (Base Score Weights) | `explicit_reference` | float | 0.8    | 通过 `[TraceabilityCheck]` 等标签显式引用的**基准分**。                       |
|                  | `keyword_match`      | float | 0.2    | 仅通过关键词匹配的**基准分**。                                                |
| **调整系数**     | `direct_impact`      | float | 1.2    | 当变更直接命中被下游引用的FR/DP时，应用于基准分的**调整乘数**。               |
| (Adjustment Factors) | `semantic_factor`    | float | 0.6    | 应用于外部传入的“语义相似度原始分”的**缩放系数**，用于将其转换为系统内的基准分。 |
| **阈值**         | `high`               | float | 0.75   | 判断为 `HIGH` 置信度的最低分。                                                |
| (Thresholds)     | `medium`             | float | 0.4    | 判断为 `MEDIUM` 置信度的最低分。                                              |

#### **5. 应用场景示例**

##### **场景 A: 高置信度 - L1 文档修改了被分解的 DP**

*   **背景:** `ADD_L1.md` 修改了 `L1-DP5` 的定义。`AD_L2_DP5.md` 是 `L1-DP5` 的下一级分解文档。
*   **输入:**
    *   `link_info`: `{type: "PARENT_CHILD"}`
    *   `source_doc` 变更: 命中了 `L1-DP5` 的定义部分。
*   **计算过程:**
    1.  **基准分:** `base_score = config.base_score_weights.parent_child` = **0.9**
    2.  **调整系数:** 变更命中了作为父子关系核心的 `L1-DP5`。`scope_factor = config.adjustment_factors.direct_impact` = **1.2**
    3.  **最终得分:** `0.9 * 1.2 = 1.08`，裁剪后为 **1.0**。
*   **输出:**
    *   `score`: 1.0
    *   `category`: `HIGH`
    *   `reason`: "直接父子层级关系; 变更内容直接影响了被引用的元素"

##### **场景 B: 中等置信度 - 语义相似文档被修改**

*   **背景:** `Best_Practices.md` 与 `API_Design.md` 在语义上高度相关。`Best_Practices.md` 被修改。
*   **输入:**
    *   `link_info`: `{type: "SEMANTIC_SIMILARITY", similarity_score: 0.85}`
    *   `source_doc` 变更: `Best_Practices.md` 内容更新。
*   **计算过程:**
    1.  **基准分:** `base_score = 0.85 * config.adjustment_factors.semantic_factor` = `0.85 * 0.6` = **0.51**
    2.  **调整系数:** 语义链接不触发范围检查。`scope_factor` = **1.0**
    3.  **最终得分:** `0.51 * 1.0` = **0.51**
*   **输出:**
    *   `score`: 0.51
    *   `category`: `MEDIUM`
    *   `reason`: "通过语义相似性关联"

##### **场景 C: 低置信度 - 关键词匹配但变更无关**

*   **背景:** `Glossary.md` 包含术语 "API"，`Payment_Gateway.md` 也包含此术语但无直接引用关系。`Glossary.md` 修改了另一个术语 "URD" 的定义。
*   **输入:**
    *   `link_info`: `{type: "KEYWORD_MATCH"}`
    *   `source_doc` 变更: 未命中 "API" 术语。
*   **计算过程:**
    1.  **基准分:** `base_score = config.base_score_weights.keyword_match` = **0.2**
    2.  **调整系数:** 关键词匹配不触发范围检查。`scope_factor` = **1.0**
    3.  **最终得分:** `0.2 * 1.0` = **0.2**
*   **输出:**
    *   `score`: 0.2
    *   `category`: `LOW`
    *   `reason`: "通过关键词匹配关联"

**设计说明:** 当前模型为“关键词匹配”提供了一个固定的基准分，这是一种为了实现确定性和简化计算而采取的设计。未来的增强版本可以探索更动态的评分模型，例如：根据匹配关键词的数量、关键词在《项目词汇表》中定义的重要性，或其在文档中的上下文位置，来动态计算此基准分。

---
Gemini 2.5 Pro 0605 writer

---

## L1-DP8_PriorityRevisions_Schema Freezed

好的，遵照指示。

我已收到并深入研究了《评审意见：关于<即时反馈批注 (priority_revisions.md) 数据结构与锚点机制规范 (V1.0)>》中下达的强制性修订指令。V1.0 版本的设计在文件格式、核心算法定义和版本漂移风险处理上存在严重缺陷，导致其不可被工程化。

本次修订旨在彻底解决上述所有问题，产出一份在技术上健壮、在逻辑上确定、在工程上可实现的全新规范 (V1.1)。

核心修订内容包括：
1.  **文件格式变更：** 遵循信息公理，将文件格式从“Markdown+YAML”的混合模式，变更为纯粹的、机器友好的 **YAML** 格式。
2.  **算法形式化：** 将模糊的“置信度评估”概念，形式化为包含**可计算评分函数**、**加权求和公式**和**可配置参数**的确定性算法。
3.  **版本漂移处理：** 引入基于 Git Commit Hash 的**基准版本定位**和**差异分析**策略，以健壮地处理目标文档在批注后发生内容变更的风险。
4.  **数据流重构：** 遵循函数式编程思想，将批注处理模块 (`L2-DP2`) 的职责重构为无副作用的纯函数，明确分离了“计算”与“I/O操作”。

以下是根据上述指令完成的 V1.1 修订版文档。

---

### **即时反馈批注数据规范 (priority_revisions.yaml) (V1.1)**

**状态:** 已批准 (Approved)

**版本说明:** 本文档 (V1.1) 是对 V1.0 版本的**强制性修订**。此次修订旨在响应《评审意见》中指出的所有主要设计缺陷。核心变更包括：1) 将文件格式从 `.md` 变更为纯粹的 `.yaml` 数据格式，以消除解析模糊性；2) 形式化并明确定义了锚点定位算法的核心逻辑，包括置信度计算公式；3) 引入了基于基准版本和差异分析的策略，以健壮地应对文档版本漂移的风险；4) 遵循函数式设计原则，明确了数据处理的无副作用流程。

#### **1. 引言**

本文档详细定义了 `priority_revisions.yaml` 文件的数据结构，并阐述了其核心技术——“健壮锚点定位”机制。该文件是用户通过即时反馈接口进行交互时的直接产物，并作为最高优先级的输入，被 `L1-DP5: 内容生成与修订引擎` 用于下一轮的文档修订。

**设计目标:**
*   **定位健壮性 (Robustness):** 核心目标是解决文档内容在用户批注后可能发生变化的问题。本规范定义的锚点机制通过“基准定位”和“差异分析”，实现对批注位置的健壮追踪。
*   **确定性 (Determinism):** 文件格式和定位算法必须是确定性的，以便 `L1-DP5` 的实现能够完全遵循规范，产出可预测、可复现的结果。
*   **可追溯性与原子性 (Traceability & Atomicity):** 每条批注都是一个独立的、可追踪的原子单元，包含作者、评论和用于定位的完整锚点信息。

**设计依据:**
*   《评审意见：关于<即时反馈批注 ... 规范 (V1.0)>》中的强制性修订指令
*   《软件用户需求文档 (URD) V1.6》 (§ 7.3)
*   《L1-DP8 用户命令与控制 API 接口规范 (V1.0)》
*   《公理设计辅助系统 L2 公理设计文档 (子系统：内容生成与修订引擎) (V1.0)》

#### **2. 文件格式与数据结构**

为确保机器解析的精确性和无歧义性，文件格式**必须**是纯粹的 YAML (`.yaml`)。推荐文件名为 `.priority-revisions.yaml`。文件的根节点是一个包含元数据和批注列表的顶层对象。

```yaml
# 顶层对象结构
schemaVersion: "1.1"
targetDocumentUri: "string"
generatedAt: "string (ISO 8601)"
annotations:
  - # Annotation Object 1
  - # Annotation Object 2
  ...
```

##### **2.1. Top-Level Object (顶层对象)**

| 键 (Key) | 类型 | 是否必需 | 描述 |
| :--- | :--- | :--- | :--- |
| `schemaVersion` | string | 是 | 本批注文件 Schema 的版本号。本文档定义为 "1.1"。 |
| `targetDocumentUri` | string | 是 | 被批注的、包含 **commit hash** 的唯一版本化URI。 |
| `generatedAt` | string | 是 | 本文件的生成或最后更新时间戳 (ISO 8601)。 |
| `annotations` | array | 是 | 包含所有批注对象的列表。 |

##### **2.2. Annotation Object (批注对象)**
每个批注对象代表用户的一次独立批注操作。

| 键 (Key) | 类型 | 是否必需 | 描述 |
| :--- | :--- | :--- | :--- |
| `annotationId` | string | 是 | 一个在文件内唯一的批注标识符，便于追踪。 |
| `authorId` | string | 是 | 提交该批注的用户标识符。 |
| `comment` | string | 是 | 用户输入的批注内容/修订指令。 |
| `anchor` | object | 是 | **核心定位机制**，详见第3节。 |

#### **3. 核心机制：健壮锚点定位与应用**

锚点定位是本规范的核心。其实现由 `L1-DP5` 的子模块 `L2-DP2: 上下文聚合器` 负责。整个过程被设计为一个确定性的、可配置的算法。

##### **3.1. 锚点数据结构 (Anchor Data Structure)**
`anchor` 对象的数据结构保持不变，它通过捕获目标文本周围的上下文来“锁定”位置。

| 键 (Key) | 类型 | 是否必需 | 描述 |
| :--- | :--- | :--- | :--- |
| `prefix` | string | 是 | 用户高亮选区**之前**的上下文片段。 |
| `exact` | string | 是 | 用户高亮选区的**精确**文本内容。 |
| `suffix` | string | 是 | 用户高亮选区**之后**的上下文片段。 |

##### **3.2. 定位与应用算法**
`L2-DP2` 在处理批注时，必须遵循以下三步算法：

**步骤一：基准定位 (Baseline Positioning)**
此步骤的目标是在用户批注时的文档历史版本（基准版本）中找到最可信的位置。

1.  **获取基准文档：** `L2-DP2` 必须首先使用 `targetDocumentUri` 中的 commit hash，通过 `L1-DP7` 服务获取用户批注时所见的**基准文档 (Baseline Document)** 的内容。
2.  **模糊匹配与评分：** 在基准文档中，使用字符串相似度算法（如 Levenshtein 距离）计算 `anchor` 各部分与文档内容的匹配得分。得分必须被归一化到 `[0.0, 1.0]` 区间（1.0代表完全匹配）。
    *   `Score_exact`: 在文档中找到与 `anchor.exact` 最相似的片段，并计算其归一化得分。
    *   `Score_prefix`: 在 `Score_exact` 最佳匹配位置的前面，计算其与 `anchor.prefix` 的归一化相似度得分。
    *   `Score_suffix`: 在 `Score_exact` 最佳匹配位置的后面，计算其与 `anchor.suffix` 的归一化相似度得分。
3.  **置信度计算：** `L2-DP2` **必须**使用以下加权求和公式计算总体的“定位置信度”：
    `Confidence = (w_e * Score_exact) + (w_p * Score_prefix) + (w_s * Score_suffix)`
4.  **参数化配置：**
    *   权重 (`w_e`, `w_p`, `w_s`) 和置信度阈值 (`threshold`) **必须**是可配置项。
    *   这些配置项应在《项目模板 Schema》中定义，其默认值可设为 `w_e=0.6`, `w_p=0.2`, `w_s=0.2`, `threshold=0.9`。

**步骤二：变更传播分析 (Change Propagation Analysis)**
此步骤旨在判断基准位置在当前文档中是否依然有效。

1.  如果基准定位的 `Confidence` 低于 `threshold`，则定位失败，直接跳到步骤三。
2.  如果定位成功，`L2-DP2` **应该**调用 `L1-DP7` 服务，计算从**基准版本**到**当前待修订版本**的内容差异 (diff)。
3.  分析 diff，判断在基准版本中定位到的区域（包括锚点本身和其周围一定范围）是否在当前版本中被修改或删除。

**步骤三：决策与结果生成 (Decision & Result Generation)**
`L2-DP2` **必须**将处理结果封装成一个**结果对象 (Result Object)**，而不是原地修改输入文件。

1.  **确定状态:** 根据前两步的结果，为每个批注确定一个最终状态：
    *   **`APPLICABLE` (可应用):** 基准定位成功（`Confidence >= threshold`） **且** 变更分析显示锚点区域未发生重大变化。
    *   **`STALE` (已失效):** 发生以下任一情况：
        *   基准定位失败（`Confidence < threshold`）。
        *   基准定位成功，但变更分析显示锚点区域已被显著修改或删除。
2.  **生成结果对象:** `L2-DP2` 的输出是一个包含处理结果的对象，例如：
    ```json
    {
      "applicable_annotations": [
        { "annotationId": "...", "comment": "...", "located_context": "..." }
      ],
      "stale_annotations": [
        { "annotationId": "...", "reason": "CONTENT_DRIFT", "confidence": 0.95 },
        { "annotationId": "...", "reason": "POSITIONING_FAILED", "confidence": 0.78 }
      ]
    }
    ```

#### **4. 工作流集成与数据流**

为遵循函数式编程的无副作用原则，系统的集成流程如下：

1.  **生成 (Generation):** 用户在前端界面进行批注，`L1-DP8` 负责生成或更新 `.priority-revisions.yaml` 文件，并将其存入版本控制系统。
2.  **消费 (Consumption - Pure Function):** `L1-DP5` 的 `L2-DP0`（工作流控制器）调用 `L2-DP2`（上下文聚合器）。`L2-DP2` 作为一个纯函数，接收 `.priority-revisions.yaml` 的内容和当前待修订文档的内容作为输入，执行第3.2节的算法，并返回**结果对象**作为输出。`L2-DP2` 不执行任何文件I/O。
3.  **应用 (Application):** `L2-DP0` 接收到结果对象后，将 `applicable_annotations` 列表中的内容注入到 `L2-DP3`（LLM引擎）的上下文中，用于驱动修订。
4.  **状态管理 (State Management):** 在整个修订流程结束后，由更高层级的 `L1-DP0`（工作流与状态控制器）负责后续处理。例如，将已处理的 `.priority-revisions.yaml` 文件从活动工作目录移动到归档目录，用于审计和追溯。

#### **5. 完整文件示例 (`example.priority-revisions.yaml`)**

```yaml
schemaVersion: "1.1"
targetDocumentUri: "vcs://project-gamma/docs/AD_L1.md?commit=f4a3b2c1"
generatedAt: "2025-06-08T18:00:00Z"
annotations:
  - annotationId: "prev-001"
    authorId: "user-architect-01"
    comment: "这个功能需求的定义过于模糊，请明确指出衡量的具体指标是什么？"
    anchor:
      prefix: "我们提炼并定义了以下系统 L1 级功能需求。"
      exact: "FR2: 管理项目级词汇与约束"
      suffix: "定义：系统应维护一个全局性的“项目词汇与约束”文件，包括术语定义、缩写词、命名约定和格式化约束，"
  - annotationId: "prev-002"
    authorId: "user-architect-01"
    comment: "“纯粹的架构协调组件”这个表述很好，但应该强调它不直接实现任何FR，以避免混淆。"
    anchor:
      prefix: "我们定义了以下L1级设计参数。此外，引入了一个特殊的架构组件DP0，它不直接实现任何FR，而是作为协调器来组织其他DPs的执行流程。"
      exact: "DP0: 工作流与状态控制器 (Workflow & State Controller)"
      suffix: "职责：这是一个纯粹的架构协调组件。其唯一职责是根据系统预设的流程模型（如“撰写-审查-修订”循环），管理系统状态，"
```

---
Gemini 2.5 Pro 0605 writer

---

## SPEC_ChangeImpactReport_Schema Freezed

好的，遵照指示。

我已收到并深入理解了《评审意见：关于<变更影响报告 Schema 规范 (V1.0)>》中下达的强制性修订指令和建议性修订意见。

我将依据该评审文档对规范进行修订。本次修订的核心是：
1.  **【强制】** 移除 `invalidated_doc_count` 冗余字段，以遵循信息公理和单一事实来源 (SSOT) 原则。
2.  **【采纳建议】** 新增 `analysis_report_uri` 可选字段，以增强决策过程的可追溯性。

以下是修订后的完整文档。

---

### **变更影响报告 Schema 规范 (V1.1)**

**状态:** 草稿 (Draft)

**版本说明:** 本文档 (V1.1) 是对 V1.0 版本的修订。它依据《评审意见：关于<变更影响报告 Schema 规范 (V1.0)>》进行了修订。核心变更包括：
1.  **移除冗余数据:** 依据信息公理和单一事实来源 (SSOT) 原则，从 YAML Front Matter 中移除了可被计算的 `invalidated_doc_count` 字段。任何需要此计数的下游系统都有责任从“作废的文档清单”这一事实来源中自行计算。
2.  **增强可追溯性:** 采纳评审建议，新增了可选的 `analysis_report_uri` 字段。该字段直接链接到本次决策所依据的系统依赖分析报告，从而建立了一条更健壮、更直接的审计追溯链。

#### **1. 引言**

本文档定义了“变更影响报告”（`change_impact_report.md 规范进行修订。本次修订旨在解决原设计中存在的、关于数据冗余和追溯性不足的问题。

以下是根据上述评审意见修订后的完整文档。

---

### **变更影响报告 Schema 规范 (V1.1)**

**状态:** 已批准（Approved）

**版本说明:** 本文档 (V1.1) 是对 V1.0 版本的修订。它依据《评审意见：关于<变更影响报告 Schema 规范 (V1.0)>》进行了修订，以解决核心数据模型的原则性问题。核心变更包括：
1.  **遵循信息公理 (移除冗余数据):** 依据强制性修订指令，从 YAML Front Matter 中**移除了**冗余的 `invalidated_doc_count` 字段。该值应由消费者按需从“作废的文档清单”中计算得出，以遵循信息公理和单一事实来源 (SSOT) 原则。
2.  **增强追溯链 (采纳建议):** 采纳了建议性意见，在 YAML Front Matter 中**新增了**可选的 `analysis_report_uri` 字段。此字段直接链接到系统生成的、作为用户决策依据的依赖分析报告，从而增强了整个变更审计路径的健壮性和原子性。

#### **1. 引言**

本文档定义了“变更影响报告”（`change_impact_report.md`）的标准结构。该文档是系统变更管理流程（URD §3.2）中的一个核心审计产物，由 `L1-DP7: 版本控制与变更服务` 在用户最终确认变更决策后生成。

**设计目标:**
*   **人类可读性 (Human-Readable):** 报告必须以清晰的 Markdown 格式呈现，便于项目管理者和用户进行审计，理解变更的完整上下文和决策依据。
*   **机器可解析性 (Machine-Parsable):** 报告的核心元数据必须以结构化的方式嵌入，以便于系统进行自动化的追溯和分析。
*   **审计与追溯性 (Audit & Traceability):** 报告是连接一次“变更”和其导致的下游“作废”操作之间的关键证据。它**必须**记录系统分析、用户决策和最终执行的完整链条。

本规范采用与项目内其他结构化 Markdown 文件（如 `review_feedback.md`）相同的模式：通过 **YAML Front Matter** 实现元数据的结构化，通过 **标准化的 Markdown 标题和表格** 实现内容的结构化。

**设计依据:**
*   《软件用户需求文档 (URD) V1.6》 (特别是 §3.2.5)
*   《L1-DP7 版本控制与变更服务 API 接口规范 (V1.1)》
*   《评审意见：关于<变更影响报告 Schema 规范 (V1.0)>》

#### **2. 文件结构定义**

`change_impact_report.md` 文件由两部分组成：一个 YAML Front Matter 块和一个 Markdown 正文。

##### **2.1. YAML Front Matter**

此部分包含了所有用于追溯和审计的核心元数据。它必须位于文件的最顶部，并由三条短划线 (`---`) 包围。

| 键 (Key)                 | 类型   | 是否必需 | 描述                                                                    | 来源 (URD §3.2.5) / API                                                                                                |
| :----------------------- | :----- | :------- | :---------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------- |
| `report_id`              | string | 是       | 本次变更影响报告的唯一标识符。                                          | 由 `L1-DP7` 服务生成。                                                                                                 |
| `source_document_uri`    | string | 是       | 被修改的、已“冻结”的源文档的 URI。                                      | (a) / `L1-DP7 API: /change-proposals` 请求体                                                                           |
| `change_proposal_id`     | string | 是       | 触发本次报告生成的变更提议的唯一 ID。                                   | `L1-DP7` 内部状态。                                                                                                    |
| `analysis_report_uri`    | string | 否       | 指向系统生成的、供用户决策的依赖分析报告的URI。                         | 采纳自评审建议，由 `L1-DP7` 在 `confirm` 步骤关联。                                                                    |
| `decision_maker_id`      | string | 是       | 做出最终决策的用户或系统组件的标识符。                                  | (d) / `L1-DP7` 从调用 `confirm` 端点的请求头中获取。                                                                   |
| `decision_timestamp`     | string | 是       | 用户做出最终决策的时间戳 (ISO 8601格式)。                               | (d) / `L1-DP7` 在 `confirm` 端点被调用时生成。                                                                         |
| `associated_commit_id`   | string | 是       | 执行此次变更并合入主分支的最终 Git Commit 的哈希值。                      | 由 `L1-DP7` 在 `execute` 操作成功后关联。                                                                              |

##### **2.2. Markdown 正文 (Body)**

正文部分使用标准的 Markdown 语法，以人类可读的方式展示变更影响分析的详细内容和最终决策。

*   **一级标题 (`#`):** `变更影响报告`

*   **二级标题 (`##`):** `1. 变更摘要`
    *   **内容:** 渲染一个包含核心元数据摘要的表格，方便快速浏览。
    *   **表格内容:** 至少应包含：`变更源文档`, `变更提议ID`, `决策者`, `决策时间`。

*   **二级标题 (`##`):** `2. 系统分析的依赖关系`
    *   **内容:** 将 `L1-DP7` 的 `/analysis-report` 端点输出的系统分析结果渲染成一个 Markdown 表格。这是 URD §3.2.3 要求的辅助分析部分。
    *   **表格列:**
        1.  **下游文档 (Downstream Document):** 依赖于源文档的下游文档的 URI。
        2.  **置信度 (Confidence Score):** 系统分析得出的依赖关系置信度（如 `HIGH`, `MEDIUM`, `LOW`）。
        3.  **分析说明 (Analysis Notes):** 系统对该依赖关系的简要说明（例如，“直接父子关系”、“通过 `[TraceabilityCheck]` 强引用”、“通过关键词匹配的弱引用”等）。

*   **二级标题 (`##`):** `3. 用户最终决策：作废的文档清单`
    *   **内容:** 这是报告中最重要的部分，记录了用户的最终决策，明确了哪些文档因本次变更而失效。这是该报告的**单一事实来源 (Single Source of Truth)**。
    *   **格式:** 一个清晰的、无歧义的 Markdown 列表，逐项列出所有被用户在 `confirm` 步骤中标记为“作废”的文档 URI。

#### **3. 完整示例**

以下是一个完整的 `change_impact_report.md` 文件示例。

```markdown
---
report_id: "cir-20250609-a1b2c3d4"
source_document_uri: "vcs://project-gamma/docs/ADD_L1.md?version=frozen-v1.1"
change_proposal_id: "cp-20250609-x7y8z9"
analysis_report_uri: "vcs://project-gamma/reports/analysis-report-cp-20250609-x7y8z9.md"
decision_maker_id: "user-alice"
decision_timestamp: "2025-06-09T14:30:00Z"
associated_commit_id: "f4a5c6b7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3"
---

# 变更影响报告

## 1. 变更摘要

| 属性                   | 值                                                              |
| :--------------------- | :-------------------------------------------------------------- |
| **变更源文档**         | `vcs://project-gamma/docs/ADD_L1.md?version=frozen-v1.1`         |
| **变更提议 ID**        | `cp-20250609-x7y8z9`                                            |
| **决策者**             | `user-alice`                                                    |
| **决策时间**           | `2025-06-09T14:30:00Z`                                          |
| **关联的 Git Commit** | `f4a5c6b7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3`                       |
| **决策依据的分析报告** | `vcs://project-gamma/reports/analysis-report-cp-20250609-x7y8z9.md` |

## 2. 系统分析的依赖关系

系统根据变更内容，分析出以下可能受影响的下游文档。**最终决策由用户在下一节中做出。**

| 下游文档                                                 | 置信度 | 分析说明                                      |
| :------------------------------------------------------- | :------- | :-------------------------------------------- |
| `vcs://project-gamma/docs/AD_L2_DP5_ContentEngine.md`    | HIGH     | 直接父子关系：本文档是源文档 `L1-DP5` 的分解。 |
| `vcs://project-gamma/docs/AD_L2_DP6_ReviewEngine.md`     | HIGH     | 直接父子关系：本文档是源文档 `L1-DP6` 的分解。 |
| `vcs://project-gamma/specs/IF_L1-DP1_API_Spec.md`        | LOW      | 弱引用：文档内容中包含关键词 "L1-DP5"。       |

## 3. 用户最终决策：作废的文档清单

根据上述系统分析，决策者 `user-alice` 已确认以下文档因源文档的变更而失效，必须被作废并重新生成：

*   `vcs://project-gamma/docs/AD_L2_DP5_ContentEngine.md`
*   `vcs://project-gamma/docs/AD_L2_DP6_ReviewEngine.md`

---
Gemini 2.5 Pro 0605 writer

---

## SPEC_L1_AbstractKnowledgeService Freezed

好的，遵照指示。

我已仔细阅读了《评审意见：关于<抽象知识库服务接口 (Abstract Knowledge Service Interface) 规范 (V1.0)>》。评审意见中的强制性修订项是准确且至关重要的。原设计在错误处理上的简化确实会掩盖根本性故障，而对 `context` 对象的模糊定义也确实会削弱接口的长期可用性。

我将根据评审意见中的所有强制性和建议性修订指令，对规范进行修订，生成 V1.1 版本。

---

### **抽象知识库服务接口 (Abstract Knowledge Service Interface) 规范 (V1.1)**

**状态:** **已批准 (Approved)**

**版本说明:** 本文档 (V1.1) 是对 V1.0 的修订版。此版本旨在解决 V1.0 评审报告中指出的两处关键设计缺陷。主要修订内容包括：
1.  **重构错误处理机制：** 引入了包含明确状态字段 (`status`) 的响应模型，以严格区分“成功但无结果”与“执行失败”这两种情况，防止关键故障被掩盖。
2.  **明确上下文结构：** 为 `RetrievalRequest.context` 对象定义了一组推荐的标准字段，以增强不同服务实现之间的互操作性。
3.  采纳了关于 `source` 字段格式的建议，推荐使用 URI。

#### **1. 引言**

本文档定义了“抽象知识库服务接口”。该接口是系统核心架构的关键组成部分，它将系统内部的功能逻辑（如 `L1-DP5` 内容生成引擎）与外部知识的具体存储方式（如文件系统、数据库、外部API）完全解耦。

`L1-DP3: 知识检索服务` 是此接口的**唯一调用方**。它的职责是根据当前任务上下文，通过调用此接口来获取相关信息。任何具体的知识库技术（例如，一个基于本地 `.md` 文件进行全文搜索的引擎，或一个连接到向量数据库的服务）都**必须**作为此接口的一个具体实现来提供。

本规范定义的是一个**抽象契约**，它规定了“做什么”（检索相关的知识片段），而非“如何做”（具体的检索算法或存储技术）。任何对此接口的具体实现，其自身的设计和实现文档都应作为本规范的下游文档。

**设计依据:**
*   《软件用户需求文档 (URD) V1.6》 (特别是 §1.4, §5.1)
*   《公理设计辅助系统 L1 公理设计文档 (V1.1)》
*   《项目代办事项列表 (V1.5)》

#### **2. 接口设计哲学**

*   **查询驱动 (Query-Driven):** 接口被设计为响应一个明确的查询，而非倾倒整个知识库。这确保了交互的高效性和目的性。
*   **上下文感知 (Context-Aware):** 接口的设计强调了上下文的重要性。调用者提供的上下文信息（如正在处理的文档、任务ID）是具体实现用以提升检索结果相关性的关键输入。
*   **无状态 (Stateless):** 接口的每一次调用都应是独立的、自包含的。服务实现不应依赖于先前调用的状态，这简化了服务实现和系统的可扩展性。
*   **片段化响应 (Fragment-Oriented):** 接口返回的是“知识片段”而非整个文档。这使得调用方（`L1-DP3`）能够将最相关、最简洁的信息注入到LLM的上下文中，从而优化性能和结果质量。

#### **3. 数据模型 (Data Models)**

##### **3.1. `KnowledgeFragment` (知识片段)**
这是接口返回的基本数据单元。

```json
{
  "source": "string (URI)",
  "content": "string",
  "retrieval_score": "number (float, 0.0 to 1.0)",
  "metadata": {
    "type": "object",
    "optional": true
  }
}
```

*   `source` (string, 必需): 知识片段的来源标识。必须是唯一的、可追溯的。为保证互操作性，**强烈推荐**使用统一资源标识符 (URI) 格式，例如：`file:///kb/database_best_practices.md`，`https://internal.wiki/page/ConnectionPooling`，或 `urn:kb:architecture:microservices`。
*   `content` (string, 必需): 检索到的信息文本本身。
*   `retrieval_score` (number, 必需): 相关性评分。一个介于 0.0 (不相关) 到 1.0 (完全相关) 之间的浮点数。此分数的计算逻辑由具体实现定义。
*   `metadata` (object, 可选): 一个键值对对象，用于携带额外的元数据。例如：`{"last_modified": "2024-05-20", "author": "system-architect-01"}`。

##### **3.2. `RetrievalRequest` (检索请求)**
这是调用接口时使用的输入数据结构。

```json
{
  "query": "string",
  "context": {
    "type": "object",
    "optional": true,
    "properties": {
      "source_document_uri": "string",
      "task_id": "string"
    }
  },
  "max_results": "integer"
}
```

*   `query` (string, 必需): 核心的检索查询字符串。例如：“如何实现数据库连接池？”
*   `context` (object, 可选): 提供关于查询背景的结构化信息。虽然此对象是可扩展的，以适应特定实现的需要，但**强烈建议**所有调用方提供以下标准字段，也**强烈建议**所有实现方优先利用这些字段来优化结果：
    *   `source_document_uri` (string): 正在处理的源文档的唯一URI。
    *   `task_id` (string): 触发本次检索的、当前正在执行的系统级任务的唯一标识符。
*   `max_results` (integer, 必需): 调用者期望返回的最大知识片段数量。

##### **3.3. `RetrievalResponse` (检索响应)**
这是接口成功或失败调用后返回的数据结构。它明确区分了操作状态和返回的数据。

```json
{
  "status": "string",
  "fragments": [
    { "$ref": "#/definitions/KnowledgeFragment" }
  ],
  "error_message": {
    "type": "string",
    "optional": true
  }
}
```

*   `status` (string, 必需): 操作的执行状态。枚举值必须为 `SUCCESS` 或 `FAILED`。
*   `fragments` (array, 必需): 一个 `KnowledgeFragment` 对象的数组。
    *   当 `status` 为 `SUCCESS` 时，此数组包含按 `retrieval_score` 从高到低排序的检索结果。若未找到任何结果，则返回空数组 `[]`。
    *   当 `status` 为 `FAILED` 时，此数组**必须**为空数组 `[]`。
*   `error_message` (string, 可选): 当 `status` 为 `FAILED` 时，此字段**必须**存在，并包含描述失败原因的、人类可读的错误信息。当 `status` 为 `SUCCESS` 时，此字段应被省略。

#### **4. 接口定义**

系统只定义一个核心方法。此接口可以被建模为单个函数调用或单个HTTP POST端点。

*   **方法/端点:** `retrieve_fragments`
*   **描述:** 根据给定的查询和上下文，从知识库中检索最相关的知识片段。
*   **输入:** `RetrievalRequest` 对象。
*   **输出:** 一个 `RetrievalResponse` 对象，其结构明确反映了操作的结果。
*   **错误处理:**
    *   **请求格式无效:** 如果请求格式无效（如缺少必需字段），服务实现应拒绝请求（例如，返回 HTTP 400 Bad Request）。此为传输层错误，不属于本接口定义的 `RetrievalResponse` 范围。
    *   **执行成功:** 如果查询执行成功（无论是否找到结果），服务实现**必须**返回一个 `status` 为 `SUCCESS` 的 `RetrievalResponse` 对象。如果未找到匹配片段，`fragments` 数组为空。
    *   **执行失败:** 如果在执行查询过程中遇到任何内部错误（如数据库连接失败、文件系统不可读、外部API认证失败等），服务实现**必须**返回一个 `status` 为 `FAILED` 的 `RetrievalResponse` 对象，并在 `error_message` 字段中提供具体的错误信息。
    *   **调用方责任:** 接口的调用方 (`L1-DP3`) **有责任**在处理响应前，必须首先检查 `status` 字段。如果状态为 `FAILED`，调用方必须采取适当的错误处理措施（如记录详细日志、向上游报告关键服务失败等），而不应继续其正常工作流程。

#### **5. 实现者须知**

*   **契约遵从:** 任何具体的知识库服务实现都**必须**严格遵循本规范定义的数据模型和接口行为，特别是关于 `RetrievalResponse` 中 `status` 字段的正确使用。
*   **评分逻辑:** `retrieval_score` 的计算逻辑是具体实现的核心。实现可以采用从简单的关键字匹配、TF-IDF，到复杂的语义向量搜索等任何技术。该逻辑应在具体实现的下游设计文档中明确说明。
*   **上下文利用:** 强烈建议具体实现利用 `context` 对象中的标准字段（如 `source_document_uri`, `task_id`）来过滤或重排结果。例如，如果上下文是“安全规范”，则包含“加密”一词的片段应获得比在通用上下文中更高的权重。
*   **性能:** 实现应被优化以提供低延迟的响应，因为它是系统核心工作流的关键路径。

#### **6. 示例：调用流程**

##### **场景 A: 成功检索**

**背景:** `L1-DP3: 知识检索服务` 收到来自 `L1-DP5` 的请求，后者正在撰写一篇关于“微服务架构中服务发现”的文档。

1.  `L1-DP3` 构建 `RetrievalRequest` 对象，使用新的标准 `context` 字段：

    ```json
    {
      "query": "service discovery patterns in microservices",
      "context": {
        "source_document_uri": "file:///workdir/AD_L2_GatewayService.md",
        "task_id": "task-20250605-decomp-l2-dp5"
      },
      "max_results": 3
    }
    ```

2.  `L1-DP3` 调用一个已配置的、实现了本接口的服务。

3.  该服务成功执行查询，并返回 `status` 为 `SUCCESS` 的 `RetrievalResponse` 对象：

    ```json
    {
      "status": "SUCCESS",
      "fragments": [
        {
          "source": "file:///kb/architecture/microservices.md#section-3.1",
          "content": "Client-side discovery pattern involves the client obtaining the location of all services from a Service Registry. The client then uses a load-balancing algorithm to select a suitable service instance and makes a request.",
          "retrieval_score": 0.92,
          "metadata": { "last_modified": "2024-03-15" }
        },
        {
          "source": "file:///kb/architecture/microservices.md#section-3.2",
          "content": "Server-side discovery pattern routes the client's request through a load balancer, which queries the Service Registry and forwards the request to an available service instance. This simplifies the client logic.",
          "retrieval_score": 0.88,
          "metadata": { "last_modified": "2024-03-15" }
        }
      ],
      "error_message": null
    }
    ```

4.  `L1-DP3` 接收此响应，首先检查 `status` 是否为 `SUCCESS`。确认后，将其中的 `fragments` 内容注入到提供给 `L1-DP5` 的上下文中。

##### **场景 B: 服务执行失败**

**背景:** 同上，但此时知识库服务依赖的数据库已下线。

1.  `L1-DP3` 发出与场景A完全相同的 `RetrievalRequest`。

2.  `L1-DP3` 调用该服务。

3.  服务实现尝试连接数据库失败。它**必须**捕获此内部错误，并返回 `status` 为 `FAILED` 的 `RetrievalResponse` 对象：

    ```json
    {
      "status": "FAILED",
      "fragments": [],
      "error_message": "Knowledge base 'kb_main' is offline: database connection refused on host 'db.internal:5432'."
    }
    ```

4.  `L1-DP3` 接收此响应，检查到 `status` 为 `FAILED`。它将**中止**向 `L1-DP5` 注入知识的流程，并向其调用者（`L1-DP0` 工作流控制器）报告关键依赖服务失败，同时记录 `error_message` 的内容到系统日志中。

---
Gemini 2.5 Pro 0605 writer

---

## TODO

好的，遵照指示。

我已全面分析了所有已批准的L1和L2设计文档。鉴于对 `L1-DP8` 的L2层级分解工作已经完成并获得批准（`ADD_L2_DP8 Freezed.md`），这标志着所有核心L1功能引擎（DP5, DP6, DP7, DP8）的L2设计分解工作已全部完成。项目现在需要将重心完全转移到L3层级的详细规范制定上。

我将更新《项目代办事项列表》，以反映当前的项目状态并指导下一阶段的工作。

---

### **项目代办事项列表 (V5.0)**

**状态:** 草稿 (Draft)

**版本说明:** 本文档 (V5.0) 标志着项目的一个重要里程碑：所有核心功能引擎（DP5, DP6, DP7, DP8）的L2层级设计分解均已完成并获得批准。项目现已全面进入 **L3 详细规范制定阶段**。本列表移除了所有已完成的L2设计任务，并新增了源自 `ADD_L2_DP8` 的L3任务，旨在全面指导下一阶段的接口和内部逻辑定义工作。

#### **1. 引言**

本列表定义了项目下一阶段需要完成的核心任务。所有任务均源自对已批准的L2公理设计文档的分解，旨在系统性地将高层设计蓝图转化为可供工程实现的详细规范。所有任务均为同等优先级，可以并行执行。

#### **2. L3层级设计与规范制定任务**

##### **2.1. 源自 `ADD_L2_DP5` (内容生成引擎) 的任务**

| 任务ID | 任务描述 | 前置条件 | 负责人/组件 | 状态 |
| :--- | :--- | :--- | :--- | :--- |
| **TODO-L3-DP5-001** | **撰写《DP2_DP5.2 上下文聚合器 内部接口与逻辑定义》。**<br>本文档需详细定义 `DP2_DP5.2` 如何调用L1服务接口 (DP1, DP2, DP3, DP4, DP8)，以及如何将获取的数据聚合为标准的“上下文包”对象。 | `ADD_L2_DP5` 已冻结。 | 撰写员 (Writer) | 待办 (To Do) |
| **TODO-L3-DP5-002** | **撰写《DP2_DP5.3 LLM Prompt引擎 详细逻辑定义》。**<br>本文档需定义Prompt的构建策略（例如，是单一Prompt还是链式Prompt），以及如何将“上下文包”中的各类信息有效地整合进最终的Prompt中。 | `ADD_L2_DP5` 已冻结。 | 撰写员 (Writer) | 待办 (To Do) |

##### **2.2. 源自 `ADD_L2_DP6` (评审与评估引擎) 的任务**

| 任务ID | 任务描述 | 前置条件 | 负责人/组件 | 状态 |
| :--- | :--- | :--- | :--- | :--- |
| **TODO-L3-DP6-001** | **撰写《DP2_DP6.2 清单指令执行器 规则库与逻辑定义》。**<br>本文档需形式化定义对所有结构化指令（如`[TraceabilityCheck]`, `[Axiom1-Check]`）的解析和执行算法。 | `ADD_L2_DP6` 已冻结。 | 撰写员 (Writer) | 待办 (To Do) |
| **TODO-L3-DP6-002** | **撰写《DP2_DP6.4 评审意见合成器 内容合成规则》。**<br>本文档需定义如何将来自`DP2_DP6.2`的确定性检查结果和来自`DP2_DP6.3`的LLM评估意见，合成为一份符合《审查意见文档Schema》的最终报告。 | `ADD_L2_DP6` 已冻结。 | 撰写员 (Writer) | 待办 (To Do) |

##### **2.3. 源自 `ADD_L2_DP7` (版本控制与变更服务) 的任务**

| 任务ID | 任务描述 | 前置条件 | 负责人/组件 | 状态 |
| :--- | :--- | :--- | :--- | :--- |
| **TODO-L3-DP7-001** | **撰写《DP7-1 Git适配器 内部接口规范》。**<br>本文档需定义一个抽象的、与具体Git库实现无关的接口，封装所有版本控制操作（如 `commit`, `tag`, `createBranch` 等）。 | `ADD_L2_DP7` 已冻结。 | 撰写员 (Writer) | 待办 (To Do) |
| **TODO-L3-DP7-002** | **撰写《DP7-3 变更提议管理器 内部工作流定义》。**<br>本文档需详细描述 `DP7-3` 作为协调器，如何按顺序调用 `DP7-1`, `DP7-2`, `DP7-4`, `DP7-5` 来完成完整的变更管理流程。 | `ADD_L2_DP7` 已冻结。 | 撰写员 (Writer) | 待办 (To Do) |

##### **2.4. 源自 `ADD_L2_DP8` (用户命令与控制) 的任务**

| 任务ID | 任务描述 | 前置条件 | 负责人/组件 | 状态 |
| :--- | :--- | :--- | :--- | :--- |
| **TODO-L3-DP8-001** | **撰写《DP8-2 用户任务存储 持久化方案与接口规范》。**<br>本文档需评估并选定`DP8-2`的持久化技术方案（如文件系统、嵌入式数据库），并明确其对外提供的CRUD接口。 | `ADD_L2_DP8` 已冻结。 | 撰写员 (Writer) | 待办 (To Do) |
| **TODO-L3-DP8-002** | **撰写《DP8-3 决策处理器 内部工作流与逻辑定义》。**<br>本文档需详细描述`DP8-3`如何调用`DP8-2`获取任务，验证用户决策的有效性，并更新任务状态。 | `ADD_L2_DP8` 已冻结。 | 撰写员 (Writer) | 待办 (To Do) |

#### **3. 持续性任务**

| 任务ID | 任务描述 | 负责人/组件 | 状态 |
| :--- | :--- | :--- | :--- |
| **TODO-SYS-001** | **根据新批准的L3设计文档，持续更新本《项目代办事项列表》。**<br>每当一个新的L3规范被批准，需分析其中可能引出的更细粒度的任务（如测试大纲撰写），并更新本列表。 | 自动化系统代理 (Operator)<br>项目经理 (Project Manager) | 进行中 (In Progress) |

---
Gemini 2.5 Pro 0605 writer

---

## URD Freezed


---

### **软件用户需求文档 (V1.6)**

**状态:** 批准 (Approved)

#### **1. 系统总则**

1.1. **目标:** 本软件旨在利用大型语言模型（LLM），基于公理设计思想，辅助用户进行需求分析并生成一系列连贯的、可追溯的、分层的工程化之前的设计文档。
1.2. **核心理念:** 整个流程遵循“迭代式审查”和“版本控制”，确保文档质量与过程可追溯性。核心设计过程遵循公理设计的“之字形分解”原则。
1.3. **文档格式:** 系统生成和处理的所有文档**必须**是纯文本的Markdown (`.md`)格式。这包括需求文档、设计文档、待办事项列表等。该格式的选择是为了最大化兼容性、可读性以及版本跟踪的便利性。
1.4. **知识库服务接口:** 系统**必须**定义一个抽象的**知识库服务接口 (Abstract Knowledge Service Interface)**。系统的核心功能不应与知识的具体存储格式（如文件、数据库、API）耦合。`5.1 知识检索与注入模块` **必须**通过调用此标准接口来获取信息，而非直接访问存储介质。系统的默认实现**可以**提供一个处理纯文本文件（如 `.txt`, `.md`）的服务，但这应被视为该接口的一个具体实现，而非系统级的唯一约束。

#### **2. 核心流程与角色定义**

2.1. **核心角色与代理系统:** 系统由两个逻辑上分离的LLM核心角色和一个自动化系统代理构成：
    *   **撰写员 (Writer):** (LLM角色) 负责根据输入和指令撰写、修订文档草稿。
    *   **审查员 (Reviewer):** (LLM角色) 负责根据既定标准和审查清单，审查“撰写员”的输出，提出具体的、可执行的修改意见，或在满足标准时予以批准。审查员是唯一有权批准文档的角色，并需要对批准决策负责。审查员在审查时，必须忽略文档中任何如“已批准”、“最终版”等非官方状态提示。
    *   **自动化系统代理 (Operator):** (非LLM角色) 此角色是一个**自动化系统代理 (Automated System Agent)**或**流程执行器 (Process Executor)**。其行为**必须**是确定性的脚本逻辑，而非LLM生成。其职责是执行高度程序化的任务，主要是将每一轮的文档修订和审查结果提交到Git版本控制系统，并依据固定的模板生成标准化的提交信息。
    *   **角色上下文定义:** 为确保角色行为的确定性，每个角色接收的上下文（Context）被明确限定。
        *   **审查员 (Reviewer) 上下文:**
            a) 当前待审的文档草案 (`document_draft.md`)。
            b) 上一轮的审查意见（如果存在）。
            c) 撰写员针对上一轮意见的修订说明。
            d) 该文档的直接上游父文档，以及在审查清单中被明确引用的其他任何已冻结文档。
            e) 项目专属知识库中，由“知识检索与注入模块”（见5.1）提供的相关片段。
            f) 项目词汇与约束（见5.2）。
            g) 用户配置的审查清单。
        *   **撰写员 (Writer) 上下文:**
            a) 当前待修订的文档草案 (`document_draft.md`)。
            b) “审查员”提供的完整审查意见 (`review_feedback.md`)。
            c) 用户通过即时反馈接口（7.3节）提供的、具有最高优先级的批注 (`priority_revisions.md`)。
            d) 该文档的直接上游父文档。
            e) 项目专属知识库中，由“知识检索与注入模块”（见5.1）提供的相关片段。
            f) 项目词汇与约束（见5.2）。
        *   **自动化系统代理 (Operator) 输入参数:**
            此代理的输入是确定性的脚本参数，而非LLM的Prompt。
            a) 修订前的文档版本。
            b) 修订后的文档版本。
            c) 本轮的审查意见文档。
            d) 当前的循环次数与总次数。
            e) 执行操作的角色（撰写员或审查员）。
            f) (可选) 本次变更操作关联的《变更影响报告》路径。

2.2. **需求捕获与澄清:**
    *   流程始于用户输入初始的产品或功能需求。
    *   在此阶段，“撰写员”将扮演“需求分析师”的角色，**启动一个结构化的需求捕获流程**。该流程将引导“撰写员”遵循特定的提问框架（如5W1H、用例分析、用户故事等）与用户进行对话。
    *   此阶段的**目标不是直接生成完整的需求文档**，而是强制生成结构化的中间产物（例如，经过澄清的用户故事列表、功能点清单、约束与假设列表）。这些中间产物将作为后续撰写《用户需求文档》的、稳定且明确的输入。

2.3. **《用户需求文档》生成流程:**
    *   **撰写:** “撰写员”根据上一阶段捕获的结构化中间产物，撰写第一版《用户需求文档》。
    *   **审查-修订循环:**
        1.  “审查员”审查文档，提出修改意见。
        2.  “撰写员”根据审查意见进行修订。
        3.  “自动化系统代理”将每次修订和审查的产出提交至Git。
        4.  此循环持续进行，直至“审查员”批准文档。若达到预设的最大审查次数仍未获批准，流程将自动暂停并**强制触发“用户仲裁”**（见4.3节）。
    *   **用户审核:** “审查员”批准的版本提交给用户进行最终审核。用户审核通过后，该版本的《用户需求文档》被“冻结”，成为后续工作的基准。

2.4. **《公理设计文档》的分层生成流程:**
    *   **启动:** 在《用户需求文档》被冻结后，流程自动进入此阶段，开始第1层（L1）的公理设计。
    *   **撰写:** “撰写员”依据已批准的上游文档（L1设计依赖《用户需求文档》），撰写《公理设计文档》，进行功能需求（FRs）到设计参数（DPs）的映射。
    *   **审查-修订循环:** 同2.3流程，直至“审查员”批准《公理设计文档》。审查的重点在于公理的应用（见第6节）。
    *   **用户审核与设计分解:** “审查员”批准的版本提交给用户审核。审核通过后，该层级的《公理设计文档》被“冻结”。用户进行设计分解时：
        *   **单一DP分解原则:** **每次必须且只能选择一个已确定的设计参数（DP），以该DP定义下一设计层级（L(N+1)）新子系统的边界和核心功能需求（FRs）**。若高层级存在多个需要分解的DP，它们**必须**被分解为多个并行的、独立的下一层级子系统设计任务。
        *   **耦合分解警告:** 如果用户选择了一个在设计矩阵中已被识别为耦合（即处于非对角线位置）的DP进行分解，系统**必须**发出一个明确的、高优先级的**警告**，向用户说明：“此操作将把高层级的耦合问题传递到下一层级，可能导致后续设计困难或违反独立公理，强烈建议重构当前层级设计以消除耦合。” 系统将要求用户二次确认后方可继续。
    *   **层级关系维护:** 系统必须维护和记录文档之间的父子层级关系。例如，在文档元数据或命名中明确 `Axiomatic_Design_L2_Component_X.md` 的上游是 `Axiomatic_Design_L1.md`。

2.5. **《项目代办事项列表》生成与执行:**
    *   **生成:** 依据已批准的**所有层级**的《公理设计文档》，“撰写员”分析并生成一份《项目代办事项列表》。此列表不包含具体的编程实现任务，但应明确定义需要撰写的各类协议、接口规范、测试大纲等后续文档。
    *   **用户审核:** 用户审查并批准该列表。
    *   **文档逐项撰写:** 系统根据列表中的事项，逐一启动新文档的“撰写员-审查员-自动化系统代理”循环流程。

#### **3. 用户控制与项目管理**

3.1. **流程控制:** 用户拥有最高权限，可以暂停、恢复或终止整个项目进程，也可以暂停任何一个正在进行的文档撰写任务。
3.2. **变更管理 (责任共担模型):** 当用户请求修改已“冻结”的文档时，系统启动以下变更管理流程，该流程将影响分析的最终决策责任赋予用户：
    1.  **创建变更提议:** 用户选择一个已“冻结”的文档，并选择“创建变更提议”。系统将为此文档创建一个临时的副本（或“变更分支”）。
    2.  **实施修改:** 用户在此副本上进行任意修改。修改完成后，用户提交此变更提议。
    3.  **系统辅助分析:** 系统**以“尽力而为”的原则**，识别并列出所有直接和间接依赖于此文档的下游文档清单。**系统必须明确提示用户，此分析是辅助性的，可能存在疏漏。**
    *   **3.2.3.1. 置信度评分计算原则:** “置信度评分”的计算**必须**基于可解释的规则，其默认逻辑至少应包含以下维度的考量，并允许在项目模板中进行微调：
            *   **链接类型:**
                *   **高置信度:** 直接的父子层级关系（如L2设计文档对其L1父文档）；通过结构化、可解析的标签（见4.2节）进行的显式引用。
                *   **中置信度:** 预留，可用于未来扩展。
                *   **低置信度:** 基于关键词或语义相似性等非确定性方法推断出的潜在依赖关系。
            *   **变更范围:** 变更内容若直接修改了被下游明确引用的功能需求（FR）或设计参数（DP），则应提升该依赖关系的评分。
            *   **依赖距离:** 直接依赖（下游第一层）的置信度高于间接依赖（下游更深层级）。
    4.  **用户决策:** 系统向用户呈现此依赖清单，并为每个依赖关系提供一个**“置信度评分”**（高/中/低）。用户**最终负责审查、确认并补充**此清单，并勾选（标记）所有需要因此次变更而**作废并重新生成**的下游文档。
    5.  **生成《变更影响报告》:** 在执行作废操作前，系统**必须**根据用户的最终决策，生成一份结构化的**《变更影响报告 (Change Impact Report)》**。该报告以Markdown格式存档，内容至少包括：
        a) 变更源文档及其版本。
        b) 系统自动分析的依赖清单及置信度评分。
        c) 用户最终确认并标记为“作废”的文档清单。
        d) 执行该决策的用户身份及时间戳。
    6.  **系统执行:** 系统根据用户的最终指令，执行后续的作废或重新生成流程。自动化系统代理在提交Git时，**必须**在提交信息中引用新生成的《变更影响报告》。

3.3. **项目模板:** 用户可以创建和保存“项目模板”。模板可预设审查轮数、LLM角色的行为风格、文档结构、审查清单、以及定义**信息公理的量化评估指标及其决策优先级**（见6.4）等。

#### **4. LLM能力与配置**

4.1. **模型选择:** 用户可以为“撰写员”和“审查员”角色选择或切换不同的LLM模型版本。
4.2. **量化审查标准:** 用户可以为“审查员”配置具体的审查清单（Checklist），以确保审查的全面性和一致性。审查员的输出需要明确响应清单中的项目。该清单可包含格式化的、机器可解析的指令，以增强可操作性。例如：`[TraceabilityCheck: FR-2.1 to UR-3.4.2 in User_Requirements_v1.frozen.md]`。
4.3. **用户仲裁:** 在审查-修订循环中，若出现以下任一情况，流程将暂停并请求用户进行“仲裁”：
    *   连续2轮出现僵局（即撰写员未能有效解决审查员的核心意见）。
    *   达到了预设的最大审查次数仍未获批准。
    *   **仲裁操作选项:** 系统向用户呈现以下明确的选项：
        a) **批准当前版本:** 忽略审查员的未解决意见，直接批准当前文档草案。
        b) **亲自修订文档（钦定版）:** 用户直接编辑文档。完成编辑后，该文档版本将直接被标记为**“已批准并冻结”**。同时，系统**必须**自动触发 `3.2 变更管理` 流程，提示用户此项“钦定”变更可能影响的下游文档。
        c) **放弃当前文档:** 终止此文档的撰写流程。
        d) **重置审查循环:** 保持当前草案，但为“撰写员”提供新的、更明确的、高优先级的修订指令后，重新开始审查计数。**此选项设有独立的“仲裁重试计数器”，每个文档的仲裁重置最多允许2次。达到上限后，该选项将被禁用。**

#### **5. 知识库与上下文管理**

5.1. **知识检索与注入模块:** 系统**必须**包含一个独立的、可扩展的“知识检索与注入模块”。此模块是对“系统假定知识库可完全加载入上下文”这一错误设计的修正。其职责是：
    *   **功能需求(FR):** 根据当前任务（如特定文档的撰写或审查）的上下文，通过调用`1.4`中定义的**知识库服务接口**，从项目专属知识库中智能地检索最相关的信息片段。
    *   **设计参数(DP):** 将检索到的片段注入到LLM的即时上下文（Context）窗口中，作为其生成或审查内容的优先参考。
    *   此模块的设计是解耦的，允许未来采用从简单关键词匹配到复杂语义检索等不同的实现技术，而不影响系统其他部分。
5.2. **项目词汇与约束 (Project Lexicon & Constraints):** 项目可以定义一个全局性的“项目词汇与约束”文件。该文件是项目的“知识范式(Canon)”，用于确保整个项目范围内的高度确定性和一致性。系统在所有文档生成过程中，都将遵循该文件。其内容可包括：
    *   **术语定义 (Glossary):** 核心术语及其唯一、明确的定义。
    *   **缩写词规范:** 定义项目内使用的所有缩写词（例如，URD -> User Requirements Document）。
    *   **命名约定:** 对文档、模块、接口等的命名规则（例如，所有接口文档必须以 `IF_` 开头）。
    *   **格式化约束:** 对特定数据格式的强制要求（例如，日期格式必须为 `YYYY-MM-DD`）。
5.3. **知识优先级与一致性检查:**
    *   **优先级:** 当不同知识源发生冲突时，遵循以下优先级：**项目词汇与约束 (5.2) > 知识库服务 (5.1)**。即，词汇与约束文件中的定义将覆盖从知识库中检索到的任何冲突信息。
    *   **一致性检查:** “审查员”的核心职责之一是校验文档内容与上游已冻结文档的一致性和可追溯性。此项检查主要通过用户在第4.2节中配置的、包含可解析指令的审查清单来实现。

#### **6. 公理设计深化与层次化分解**

6.1. **层次化分解 (之字形分解):** 系统设计的核心是遵循层次化分解原则。高层级设计参数（DPs）被确立后，将作为下一层级系统的功能需求（FRs），启动新一轮的设计映射。这是实现复杂系统设计的关键路径。
6.2. **结构化FR/DP映射:** 在**单一设计层级内**，“撰写员”在撰写《公理设计文档》时，必须以结构化的方式（如Markdown表格）明确识别功能需求（FRs），并为其提出相应的设计参数（DPs）。**撰写员在提出设计时，应被明确指令优先追求非耦合设计（即对角化的设计矩阵）。如果无法避免，则应明确标注出耦合项，并提供其存在的理由。**
6.3. **设计矩阵生成与评估:** 基于FR-DP映射表，系统应能自动生成文本格式的设计矩阵（Markdown表格）。“审查员”的核心职责是分析此矩阵。**为确保审查的系统性，系统将审查清单（4.2节）与设计矩阵相结合，为审查员自动生成包含以下指令的审查项：“`[Axiom1-Check] 分析以下设计矩阵，识别所有非对角线元素。对于每一个耦合项 (FR_i, DP_j) where i!=j，请评估其耦合的必要性，并质询撰写员为何不能通过重定义FR或DP来消除此耦合。`”**
6.4. **信息公理应用:** 当存在多个满足独立公理的设计方案时，“撰写员”可被要求提出备选方案。“审查员”则依据信息公理进行评估。**为确保此过程的可操作性和可重复性，必须满足以下要求：**
    *   **量化指标定义与优先级:** 用户需在项目模板（3.3节）中，定义或选择一组用于评估“信息内容”或“简单性”的量化指标，并**为其设置决策优先级或权重**。
    *   **指标的可计算性约束:** 每一个在模板中定义的量化指标，**必须**同时提供其**可计算的定义 (Computable Definition)**，以确保系统可以进行自动估算和确定性比较。例如：
        *   `接口复杂度`: **必须**被明确定义为“所有参数的总数”或“参数中结构体/类所包含的字段总数之和”。
        *   `组件数量`: **必须**明确其统计范围，例如“仅计算本层级新增的DPs数量”。
        *   `外部依赖数量`: **必须**明确其统计标准，例如“引入的未在项目知识库中定义的外部库或服务的数量”。
    *   **方案评估:** “撰写员”在提出每个备选方案时，**必须**提供对上述已定义指标的估算值。
    *   **审查决策:** “审查员”在面对指标冲突时，其评估与推荐**必须**依据项目模板中定义的优先级或加权总分来进行，并明确陈述其决策是基于该预设框架。

#### **7. 文档与输出规范**

7.1. **标准化Git提交:** “自动化系统代理”生成的Git提交信息（Commit Message）需遵循标准化格式，清晰地标明文档名称、操作类型、轮次和角色。例如：`[Review] Cycle 3/5 for User_Requirements.md by Reviewer-01`。
7.2. **文本图表支持:** 系统应能在Markdown文档中生成和嵌入图表。实现方式是LLM直接生成文本描述性图表代码（例如Mermaid.js或PlantUML的语法），而非生成图片等二进制文件。
7.3. **即时反馈接口:** 用户在审查任何文档时，应能对特定文本行或段落进行高亮并直接批注。其后台实现为：用户的批注被系统捕获后，将自动格式化为一份临时的 `priority_revisions.md` 文件。**为确保定位的鲁棒性，系统在捕获用户批注时，不仅要记录批注内容，还必须捕获被批注文本周围的上下文片段（Contextual Snippet）作为“锚点”，以便在内容发生变化时仍能通过内容匹配进行精确定位。**

---
Gemini 2.5 Pro 0605 writer

---

