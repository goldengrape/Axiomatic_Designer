
---

### **软件用户需求文档 (V1.6)**

**状态:** 批准 (Approved)

#### **1. 系统总则**

1.1. **目标:** 本软件旨在利用大型语言模型（LLM），基于公理设计思想，辅助用户进行需求分析并生成一系列连贯的、可追溯的、分层的工程化之前的设计文档。
1.2. **核心理念:** 整个流程遵循“迭代式审查”和“版本控制”，确保文档质量与过程可追溯性。核心设计过程遵循公理设计的“之字形分解”原则。
1.3. **文档格式:** 系统生成和处理的所有文档**必须**是纯文本的Markdown (`.md`)格式。这包括需求文档、设计文档、待办事项列表等。该格式的选择是为了最大化兼容性、可读性以及版本跟踪的便利性。
1.4. **知识库服务接口:** 系统**必须**定义一个抽象的**知识库服务接口 (Abstract Knowledge Service Interface)**。系统的核心功能不应与知识的具体存储格式（如文件、数据库、API）耦合。`5.1 知识检索与注入模块` **必须**通过调用此标准接口来获取信息，而非直接访问存储介质。系统的默认实现**可以**提供一个处理纯文本文件（如 `.txt`, `.md`）的服务，但这应被视为该接口的一个具体实现，而非系统级的唯一约束。

#### **2. 核心流程与角色定义**

2.1. **核心角色与代理系统:** 系统由两个逻辑上分离的LLM核心角色和一个自动化系统代理构成：
    *   **撰写员 (Writer):** (LLM角色) 负责根据输入和指令撰写、修订文档草稿。
    *   **审查员 (Reviewer):** (LLM角色) 负责根据既定标准和审查清单，审查“撰写员”的输出，提出具体的、可执行的修改意见，或在满足标准时予以批准。审查员是唯一有权批准文档的角色，并需要对批准决策负责。审查员在审查时，必须忽略文档中任何如“已批准”、“最终版”等非官方状态提示。
    *   **自动化系统代理 (Operator):** (非LLM角色) 此角色是一个**自动化系统代理 (Automated System Agent)**或**流程执行器 (Process Executor)**。其行为**必须**是确定性的脚本逻辑，而非LLM生成。其职责是执行高度程序化的任务，主要是将每一轮的文档修订和审查结果提交到Git版本控制系统，并依据固定的模板生成标准化的提交信息。
    *   **角色上下文定义:** 为确保角色行为的确定性，每个角色接收的上下文（Context）被明确限定。
        *   **审查员 (Reviewer) 上下文:**
            a) 当前待审的文档草案 (`document_draft.md`)。
            b) 上一轮的审查意见（如果存在）。
            c) 撰写员针对上一轮意见的修订说明。
            d) 该文档的直接上游父文档，以及在审查清单中被明确引用的其他任何已冻结文档。
            e) 项目专属知识库中，由“知识检索与注入模块”（见5.1）提供的相关片段。
            f) 项目词汇与约束（见5.2）。
            g) 用户配置的审查清单。
        *   **撰写员 (Writer) 上下文:**
            a) 当前待修订的文档草案 (`document_draft.md`)。
            b) “审查员”提供的完整审查意见 (`review_feedback.md`)。
            c) 用户通过即时反馈接口（7.3节）提供的、具有最高优先级的批注 (`priority_revisions.md`)。
            d) 该文档的直接上游父文档。
            e) 项目专属知识库中，由“知识检索与注入模块”（见5.1）提供的相关片段。
            f) 项目词汇与约束（见5.2）。
        *   **自动化系统代理 (Operator) 输入参数:**
            此代理的输入是确定性的脚本参数，而非LLM的Prompt。
            a) 修订前的文档版本。
            b) 修订后的文档版本。
            c) 本轮的审查意见文档。
            d) 当前的循环次数与总次数。
            e) 执行操作的角色（撰写员或审查员）。
            f) (可选) 本次变更操作关联的《变更影响报告》路径。

2.2. **需求捕获与澄清:**
    *   流程始于用户输入初始的产品或功能需求。
    *   在此阶段，“撰写员”将扮演“需求分析师”的角色，**启动一个结构化的需求捕获流程**。该流程将引导“撰写员”遵循特定的提问框架（如5W1H、用例分析、用户故事等）与用户进行对话。
    *   此阶段的**目标不是直接生成完整的需求文档**，而是强制生成结构化的中间产物（例如，经过澄清的用户故事列表、功能点清单、约束与假设列表）。这些中间产物将作为后续撰写《用户需求文档》的、稳定且明确的输入。

2.3. **《用户需求文档》生成流程:**
    *   **撰写:** “撰写员”根据上一阶段捕获的结构化中间产物，撰写第一版《用户需求文档》。
    *   **审查-修订循环:**
        1.  “审查员”审查文档，提出修改意见。
        2.  “撰写员”根据审查意见进行修订。
        3.  “自动化系统代理”将每次修订和审查的产出提交至Git。
        4.  此循环持续进行，直至“审查员”批准文档。若达到预设的最大审查次数仍未获批准，流程将自动暂停并**强制触发“用户仲裁”**（见4.3节）。
    *   **用户审核:** “审查员”批准的版本提交给用户进行最终审核。用户审核通过后，该版本的《用户需求文档》被“冻结”，成为后续工作的基准。

2.4. **《公理设计文档》的分层生成流程:**
    *   **启动:** 在《用户需求文档》被冻结后，流程自动进入此阶段，开始第1层（L1）的公理设计。
    *   **撰写:** “撰写员”依据已批准的上游文档（L1设计依赖《用户需求文档》），撰写《公理设计文档》，进行功能需求（FRs）到设计参数（DPs）的映射。
    *   **审查-修订循环:** 同2.3流程，直至“审查员”批准《公理设计文档》。审查的重点在于公理的应用（见第6节）。
    *   **用户审核与设计分解:** “审查员”批准的版本提交给用户审核。审核通过后，该层级的《公理设计文档》被“冻结”。用户进行设计分解时：
        *   **单一DP分解原则:** **每次必须且只能选择一个已确定的设计参数（DP），以该DP定义下一设计层级（L(N+1)）新子系统的边界和核心功能需求（FRs）**。若高层级存在多个需要分解的DP，它们**必须**被分解为多个并行的、独立的下一层级子系统设计任务。
        *   **耦合分解警告:** 如果用户选择了一个在设计矩阵中已被识别为耦合（即处于非对角线位置）的DP进行分解，系统**必须**发出一个明确的、高优先级的**警告**，向用户说明：“此操作将把高层级的耦合问题传递到下一层级，可能导致后续设计困难或违反独立公理，强烈建议重构当前层级设计以消除耦合。” 系统将要求用户二次确认后方可继续。
    *   **层级关系维护:** 系统必须维护和记录文档之间的父子层级关系。例如，在文档元数据或命名中明确 `Axiomatic_Design_L2_Component_X.md` 的上游是 `Axiomatic_Design_L1.md`。

2.5. **《项目代办事项列表》生成与执行:**
    *   **生成:** 依据已批准的**所有层级**的《公理设计文档》，“撰写员”分析并生成一份《项目代办事项列表》。此列表不包含具体的编程实现任务，但应明确定义需要撰写的各类协议、接口规范、测试大纲等后续文档。
    *   **用户审核:** 用户审查并批准该列表。
    *   **文档逐项撰写:** 系统根据列表中的事项，逐一启动新文档的“撰写员-审查员-自动化系统代理”循环流程。

#### **3. 用户控制与项目管理**

3.1. **流程控制:** 用户拥有最高权限，可以暂停、恢复或终止整个项目进程，也可以暂停任何一个正在进行的文档撰写任务。
3.2. **变更管理 (责任共担模型):** 当用户请求修改已“冻结”的文档时，系统启动以下变更管理流程，该流程将影响分析的最终决策责任赋予用户：
    1.  **创建变更提议:** 用户选择一个已“冻结”的文档，并选择“创建变更提议”。系统将为此文档创建一个临时的副本（或“变更分支”）。
    2.  **实施修改:** 用户在此副本上进行任意修改。修改完成后，用户提交此变更提议。
    3.  **系统辅助分析:** 系统**以“尽力而为”的原则**，识别并列出所有直接和间接依赖于此文档的下游文档清单。**系统必须明确提示用户，此分析是辅助性的，可能存在疏漏。**
    *   **3.2.3.1. 置信度评分计算原则:** “置信度评分”的计算**必须**基于可解释的规则，其默认逻辑至少应包含以下维度的考量，并允许在项目模板中进行微调：
            *   **链接类型:**
                *   **高置信度:** 直接的父子层级关系（如L2设计文档对其L1父文档）；通过结构化、可解析的标签（见4.2节）进行的显式引用。
                *   **中置信度:** 预留，可用于未来扩展。
                *   **低置信度:** 基于关键词或语义相似性等非确定性方法推断出的潜在依赖关系。
            *   **变更范围:** 变更内容若直接修改了被下游明确引用的功能需求（FR）或设计参数（DP），则应提升该依赖关系的评分。
            *   **依赖距离:** 直接依赖（下游第一层）的置信度高于间接依赖（下游更深层级）。
    4.  **用户决策:** 系统向用户呈现此依赖清单，并为每个依赖关系提供一个**“置信度评分”**（高/中/低）。用户**最终负责审查、确认并补充**此清单，并勾选（标记）所有需要因此次变更而**作废并重新生成**的下游文档。
    5.  **生成《变更影响报告》:** 在执行作废操作前，系统**必须**根据用户的最终决策，生成一份结构化的**《变更影响报告 (Change Impact Report)》**。该报告以Markdown格式存档，内容至少包括：
        a) 变更源文档及其版本。
        b) 系统自动分析的依赖清单及置信度评分。
        c) 用户最终确认并标记为“作废”的文档清单。
        d) 执行该决策的用户身份及时间戳。
    6.  **系统执行:** 系统根据用户的最终指令，执行后续的作废或重新生成流程。自动化系统代理在提交Git时，**必须**在提交信息中引用新生成的《变更影响报告》。

3.3. **项目模板:** 用户可以创建和保存“项目模板”。模板可预设审查轮数、LLM角色的行为风格、文档结构、审查清单、以及定义**信息公理的量化评估指标及其决策优先级**（见6.4）等。

#### **4. LLM能力与配置**

4.1. **模型选择:** 用户可以为“撰写员”和“审查员”角色选择或切换不同的LLM模型版本。
4.2. **量化审查标准:** 用户可以为“审查员”配置具体的审查清单（Checklist），以确保审查的全面性和一致性。审查员的输出需要明确响应清单中的项目。该清单可包含格式化的、机器可解析的指令，以增强可操作性。例如：`[TraceabilityCheck: FR-2.1 to UR-3.4.2 in User_Requirements_v1.frozen.md]`。
4.3. **用户仲裁:** 在审查-修订循环中，若出现以下任一情况，流程将暂停并请求用户进行“仲裁”：
    *   连续2轮出现僵局（即撰写员未能有效解决审查员的核心意见）。
    *   达到了预设的最大审查次数仍未获批准。
    *   **仲裁操作选项:** 系统向用户呈现以下明确的选项：
        a) **批准当前版本:** 忽略审查员的未解决意见，直接批准当前文档草案。
        b) **亲自修订文档（钦定版）:** 用户直接编辑文档。完成编辑后，该文档版本将直接被标记为**“已批准并冻结”**。同时，系统**必须**自动触发 `3.2 变更管理` 流程，提示用户此项“钦定”变更可能影响的下游文档。
        c) **放弃当前文档:** 终止此文档的撰写流程。
        d) **重置审查循环:** 保持当前草案，但为“撰写员”提供新的、更明确的、高优先级的修订指令后，重新开始审查计数。**此选项设有独立的“仲裁重试计数器”，每个文档的仲裁重置最多允许2次。达到上限后，该选项将被禁用。**

#### **5. 知识库与上下文管理**

5.1. **知识检索与注入模块:** 系统**必须**包含一个独立的、可扩展的“知识检索与注入模块”。此模块是对“系统假定知识库可完全加载入上下文”这一错误设计的修正。其职责是：
    *   **功能需求(FR):** 根据当前任务（如特定文档的撰写或审查）的上下文，通过调用`1.4`中定义的**知识库服务接口**，从项目专属知识库中智能地检索最相关的信息片段。
    *   **设计参数(DP):** 将检索到的片段注入到LLM的即时上下文（Context）窗口中，作为其生成或审查内容的优先参考。
    *   此模块的设计是解耦的，允许未来采用从简单关键词匹配到复杂语义检索等不同的实现技术，而不影响系统其他部分。
5.2. **项目词汇与约束 (Project Lexicon & Constraints):** 项目可以定义一个全局性的“项目词汇与约束”文件。该文件是项目的“知识范式(Canon)”，用于确保整个项目范围内的高度确定性和一致性。系统在所有文档生成过程中，都将遵循该文件。其内容可包括：
    *   **术语定义 (Glossary):** 核心术语及其唯一、明确的定义。
    *   **缩写词规范:** 定义项目内使用的所有缩写词（例如，URD -> User Requirements Document）。
    *   **命名约定:** 对文档、模块、接口等的命名规则（例如，所有接口文档必须以 `IF_` 开头）。
    *   **格式化约束:** 对特定数据格式的强制要求（例如，日期格式必须为 `YYYY-MM-DD`）。
5.3. **知识优先级与一致性检查:**
    *   **优先级:** 当不同知识源发生冲突时，遵循以下优先级：**项目词汇与约束 (5.2) > 知识库服务 (5.1)**。即，词汇与约束文件中的定义将覆盖从知识库中检索到的任何冲突信息。
    *   **一致性检查:** “审查员”的核心职责之一是校验文档内容与上游已冻结文档的一致性和可追溯性。此项检查主要通过用户在第4.2节中配置的、包含可解析指令的审查清单来实现。

#### **6. 公理设计深化与层次化分解**

6.1. **层次化分解 (之字形分解):** 系统设计的核心是遵循层次化分解原则。高层级设计参数（DPs）被确立后，将作为下一层级系统的功能需求（FRs），启动新一轮的设计映射。这是实现复杂系统设计的关键路径。
6.2. **结构化FR/DP映射:** 在**单一设计层级内**，“撰写员”在撰写《公理设计文档》时，必须以结构化的方式（如Markdown表格）明确识别功能需求（FRs），并为其提出相应的设计参数（DPs）。**撰写员在提出设计时，应被明确指令优先追求非耦合设计（即对角化的设计矩阵）。如果无法避免，则应明确标注出耦合项，并提供其存在的理由。**
6.3. **设计矩阵生成与评估:** 基于FR-DP映射表，系统应能自动生成文本格式的设计矩阵（Markdown表格）。“审查员”的核心职责是分析此矩阵。**为确保审查的系统性，系统将审查清单（4.2节）与设计矩阵相结合，为审查员自动生成包含以下指令的审查项：“`[Axiom1-Check] 分析以下设计矩阵，识别所有非对角线元素。对于每一个耦合项 (FR_i, DP_j) where i!=j，请评估其耦合的必要性，并质询撰写员为何不能通过重定义FR或DP来消除此耦合。`”**
6.4. **信息公理应用:** 当存在多个满足独立公理的设计方案时，“撰写员”可被要求提出备选方案。“审查员”则依据信息公理进行评估。**为确保此过程的可操作性和可重复性，必须满足以下要求：**
    *   **量化指标定义与优先级:** 用户需在项目模板（3.3节）中，定义或选择一组用于评估“信息内容”或“简单性”的量化指标，并**为其设置决策优先级或权重**。
    *   **指标的可计算性约束:** 每一个在模板中定义的量化指标，**必须**同时提供其**可计算的定义 (Computable Definition)**，以确保系统可以进行自动估算和确定性比较。例如：
        *   `接口复杂度`: **必须**被明确定义为“所有参数的总数”或“参数中结构体/类所包含的字段总数之和”。
        *   `组件数量`: **必须**明确其统计范围，例如“仅计算本层级新增的DPs数量”。
        *   `外部依赖数量`: **必须**明确其统计标准，例如“引入的未在项目知识库中定义的外部库或服务的数量”。
    *   **方案评估:** “撰写员”在提出每个备选方案时，**必须**提供对上述已定义指标的估算值。
    *   **审查决策:** “审查员”在面对指标冲突时，其评估与推荐**必须**依据项目模板中定义的优先级或加权总分来进行，并明确陈述其决策是基于该预设框架。

#### **7. 文档与输出规范**

7.1. **标准化Git提交:** “自动化系统代理”生成的Git提交信息（Commit Message）需遵循标准化格式，清晰地标明文档名称、操作类型、轮次和角色。例如：`[Review] Cycle 3/5 for User_Requirements.md by Reviewer-01`。
7.2. **文本图表支持:** 系统应能在Markdown文档中生成和嵌入图表。实现方式是LLM直接生成文本描述性图表代码（例如Mermaid.js或PlantUML的语法），而非生成图片等二进制文件。
7.3. **即时反馈接口:** 用户在审查任何文档时，应能对特定文本行或段落进行高亮并直接批注。其后台实现为：用户的批注被系统捕获后，将自动格式化为一份临时的 `priority_revisions.md` 文件。**为确保定位的鲁棒性，系统在捕获用户批注时，不仅要记录批注内容，还必须捕获被批注文本周围的上下文片段（Contextual Snippet）作为“锚点”，以便在内容发生变化时仍能通过内容匹配进行精确定位。**

---
Gemini 2.5 Pro 0605 writer