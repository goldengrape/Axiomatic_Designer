好的，感谢您的明确指示。将所有文档统一为纯文本（Markdown）格式，并将知识库限定为可完全加载到上下文的纯文本文件，是非常明智的决策。这极大地简化了系统架构，并能完美地利用版本控制工具（如Git）进行变更跟踪。

这体现了公理设计中的**信息公理**思想——在满足功能需求的前提下，选择信息量最少（即最简单）的设计方案。纯文本是信息熵最低的载体之一。

根据您的最新输入，我现在为您整理和更新一份完整的、合并了所有讨论点的《软件用户需求文档》。

---

### **软件用户需求文档 (V1.1 草案)**

#### **1. 系统总则**

1.1. **目标:** 本软件旨在利用大型语言模型（LLM），基于公理设计思想，辅助用户进行需求分析并生成一系列连贯的、工程化之前的设计文档。
1.2. **核心理念:** 整个流程遵循“迭代式审查”和“版本控制”，确保文档质量与过程可追溯性。
1.3. **文档格式:** 系统生成和处理的所有文档**必须**是纯文本的Markdown (`.md`)格式。这包括需求文档、设计文档、待办事项列表等。该格式的选择是为了最大化兼容性、可读性以及版本跟踪的便利性。
1.4. **知识库:** 系统支持的知识库文件**必须**是纯文本格式（如 `.txt`, `.md`）。系统假定知识库总体积适中，可在运行时完全加载到LLM的上下文（Context）中，无需依赖向量数据库或外部检索系统。

#### **2. 核心流程与角色定义**

2.1. **LLM角色系统:** 系统内置三个逻辑上分离的LLM角色：
    *   **撰写员 (Writer):** 负责根据输入和指令撰写、修订文档草稿。
    *   **审查员 (Reviewer):** 负责根据既定标准和审查清单，审查“撰写员”的输出，提出具体的、可执行的修改意见，或在满足标准时予以批准。审查员是唯一有权批准文档的角色，并需要对批准决策负责。审查员在审查时，必须忽略文档中任何如“已批准”、“最终版”等非官方状态提示。
    *   **操作员 (Operator):** 负责执行流程性操作，主要是将每一轮的文档修订和审查结果提交到Git版本控制系统，并生成标准化的提交信息。

2.2. **需求捕获与澄清:**
    *   流程始于用户输入初始的产品或功能需求。
    *   LLM（可视为“撰写员”和“用户”的对话代理）应与用户进行多轮对话，通过提问、举例、甚至生成初步的文本流程图（使用Mermaid.js等语法）来帮助用户理清思路、补充和明确化需求细节。

2.3. **《用户需求文档》生成流程:**
    *   **撰写:** “撰写员”根据澄清后的用户需求，撰写第一版《用户需求文档》。
    *   **审查-修订循环:**
        1.  “审查员”审查文档，提出修改意见。
        2.  “撰写员”根据审查意见进行修订。
        3.  “操作员”将每次修订和审查的产出提交至Git。
        4.  此循环持续进行，直到“审查员”批准文档，或达到预设的最大审查次数（默认为5轮）。
    *   **用户审核:** “审查员”批准的版本提交给用户进行最终审核。用户审核通过后，该版本的《用户需求文档》被“冻结”，成为后续工作的基准。

2.4. **《公理设计文档》生成流程:**
    *   **启动:** 在《用户需求文档》被冻结后，流程自动进入此阶段。
    *   **撰写:** “撰写员”依据已批准的《用户需求文档》，撰写《公理设计文档》，进行功能需求（FRs）到设计参数（DPs）的映射。
    *   **审查-修订循环:** 同2.3流程，直至“审查员”批准《公理设计文档》。审查的重点在于公理的应用（见第6节）。
    *   **用户审核:** “审查员”批准的版本提交给用户审核。审核通过后，《公理设计文档》被“冻结”。

2.5. **《项目代办事项列表》生成与执行:**
    *   **生成:** 依据已批准的《公理设计文档》，“撰写员”分析并生成一份《项目代办事项列表》。此列表不包含具体的编程实现任务，但应明确定义需要撰写的各类协议、接口规范、测试大纲等后续文档。
    *   **用户审核:** 用户审查并批准该列表。
    *   **文档逐项撰写:** 系统根据列表中的事项，逐一启动新文档的“撰写员-审查员-操作员”循环流程。

#### **3. 用户控制与项目管理**

3.1. **流程控制:** 用户拥有最高权限，可以暂停、恢复或终止整个项目进程，也可以暂停任何一个正在进行的文档撰写任务。
3.2. **变更管理:** 用户可以修改已批准的《项目代办事项列表》。当用户请求修改已“冻结”的文档（如《用户需求文档》）时，系统应启动影响分析流程，报告该变更对所有下游文档的潜在影响，供用户决策。
3.3. **项目模板:** 用户可以创建和保存“项目模板”。模板可预设审查轮数、LLM角色的行为风格、文档结构、以及审查清单等。

#### **4. LLM能力与配置**

4.1. **模型选择:** 用户可以为“撰写员”和“审查员”角色选择或切换不同的LLM模型版本。
4.2. **量化审查标准:** 用户可以为“审查员”配置具体的审查清单（Checklist），以确保审查的全面性和一致性。审查员的输出需要明确响应清单中的项目。
4.3. **用户仲裁:** 在审查-修订循环中，若连续2轮出现僵局（即撰写员未能有效解决审查员的意见），系统应暂停并请求用户进行“仲裁”。

#### **5. 知识库与上下文管理**

5.1. **项目专属知识库:** 用户可为一个项目关联一个或多个纯文本知识库文件。系统在执行相关任务时，会将这些文件的全部内容加载到LLM的上下文中，作为生成内容的优先参考。
5.2. **全局术语表:** 项目可以定义一个全局术语表（Glossary）文件。系统在所有文档生成过程中，都将遵循该术语表，确保术语定义的一致性。
5.3. **跨文档一致性检查:** “审查员”在审查下游文档（如《公理设计文档》）时，其职责之一是校验其内容与上游已冻结文档（如《用户需求文档》）的一致性和可追溯性。

#### **6. 公理设计深化**

6.1. **结构化FR/DP映射:** “撰写员”在撰写《公理设计文档》时，必须以结构化的方式（如Markdown表格）明确识别功能需求（FRs），并为其提出相应的设计参数（DPs）。
6.2. **设计矩阵生成与评估:** 基于FR-DP映射表，系统应能自动生成文本格式的设计矩阵（Markdown表格）。“审查员”的核心职责是分析此矩阵，并依据**独立公理**明确判断设计是耦合、解耦还是非耦合的，并为不良设计提供改进建议。
6.3. **信息公理应用:** 当存在多个满足独立公理的设计方案时，“撰写员”可被要求提出备选方案，“审查员”则依据**信息公理**（简单性原则）进行评估和推荐。

#### **7. 文档与输出规范**

7.1. **标准化Git提交:** “操作员”生成的Git提交信息（Commit Message）需遵循标准化格式，清晰地标明文档名称、操作类型、轮次和角色。例如：`[Review] Cycle 3/5 for User_Requirements.md by Reviewer-01`。
7.2. **文本图表支持:** 系统应能在Markdown文档中生成和嵌入图表。实现方式是LLM直接生成文本描述性图表代码（例如Mermaid.js或PlantUML的语法），而非生成图片等二进制文件。
7.3. **即时反馈接口:** 用户在审查任何文档时，应能对特定文本行或段落进行高亮并直接批注。该批注将成为下一轮修订的最高优先级任务。

Gemini 2.5 Pro 0605 writer